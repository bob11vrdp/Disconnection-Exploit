/* Copyright (c) 2001, Stanford University
	All rights reserved.

	See the file LICENSE.txt for information on redistributing this software. */
	

/* DO NOT EDIT - THIS FILE AUTOMATICALLY GENERATED BY packspu_get.py SCRIPT */
#include "packspu.h"
#include "cr_packfunctions.h"
#include "cr_net.h"
#include "cr_mem.h"
#include "packspu_proto.h"


static GLboolean crPackIsPixelStoreParm(GLenum pname)
{
    if (pname == GL_UNPACK_ALIGNMENT
        || pname == GL_UNPACK_ROW_LENGTH
        || pname == GL_UNPACK_SKIP_PIXELS
        || pname == GL_UNPACK_LSB_FIRST
        || pname == GL_UNPACK_SWAP_BYTES
#ifdef CR_OPENGL_VERSION_1_2
        || pname == GL_UNPACK_IMAGE_HEIGHT
#endif
        || pname == GL_UNPACK_SKIP_ROWS
        || pname == GL_PACK_ALIGNMENT
        || pname == GL_PACK_ROW_LENGTH
        || pname == GL_PACK_SKIP_PIXELS
        || pname == GL_PACK_LSB_FIRST
        || pname == GL_PACK_SWAP_BYTES
#ifdef CR_OPENGL_VERSION_1_2
        || pname == GL_PACK_IMAGE_HEIGHT
#endif
        || pname == GL_PACK_SKIP_ROWS)
    {
        return GL_TRUE;
    }
    return GL_FALSE;
}


static struct nv_struct { GLenum pname; unsigned int num_values;
#ifdef VBOX_WITH_CRDUMPER 
const char* pszName;
#endif
} num_values_array[] = {


        	{ GL_ACCUM_ALPHA_BITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ACCUM_ALPHA_BITS"
#endif
        },
        

        	{ GL_ACCUM_BLUE_BITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ACCUM_BLUE_BITS"
#endif
        },
        

        	{ GL_ACCUM_CLEAR_VALUE, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ACCUM_CLEAR_VALUE"
#endif
        },
        

        	{ GL_ACCUM_GREEN_BITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ACCUM_GREEN_BITS"
#endif
        },
        

        	{ GL_ACCUM_RED_BITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ACCUM_RED_BITS"
#endif
        },
        
#ifdef CR_EXT_stencil_two_side

        	{ GL_ACTIVE_STENCIL_FACE_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_ACTIVE_STENCIL_FACE_EXT"
        #endif
        },
        
#endif /* CR_EXT_stencil_two_side */
#ifdef CR_ARB_multitexture

        	{ GL_ACTIVE_TEXTURE_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_ACTIVE_TEXTURE_ARB"
        #endif
        },
        
#endif /* CR_ARB_multitexture */
#ifdef CR_OPENGL_VERSION_1_2

        	{ GL_ALIASED_LINE_WIDTH_RANGE, 2
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_ALIASED_LINE_WIDTH_RANGE"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_OPENGL_VERSION_1_2

        	{ GL_ALIASED_POINT_SIZE_RANGE, 2
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_ALIASED_POINT_SIZE_RANGE"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_1_2 */

        	{ GL_ALPHA_BIAS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ALPHA_BIAS"
#endif
        },
        

        	{ GL_ALPHA_BITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ALPHA_BITS"
#endif
        },
        

        	{ GL_ALPHA_SCALE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ALPHA_SCALE"
#endif
        },
        

        	{ GL_ALPHA_TEST, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ALPHA_TEST"
#endif
        },
        

        	{ GL_ALPHA_TEST_FUNC, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ALPHA_TEST_FUNC"
#endif
        },
        

        	{ GL_ALPHA_TEST_REF, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ALPHA_TEST_REF"
#endif
        },
        
#ifdef CR_ARB_vertex_buffer_object

        	{ GL_ARRAY_BUFFER_BINDING_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_ARRAY_BUFFER_BINDING_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_buffer_object */

        	{ GL_ATTRIB_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ATTRIB_STACK_DEPTH"
#endif
        },
        

        	{ GL_AUTO_NORMAL, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_AUTO_NORMAL"
#endif
        },
        

        	{ GL_AUX_BUFFERS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_AUX_BUFFERS"
#endif
        },
        

        	{ GL_BLEND, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_BLEND"
#endif
        },
        
#ifdef CR_EXT_blend_color

        	{ GL_BLEND_COLOR_EXT, 4
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_BLEND_COLOR_EXT"
        #endif
        },
        
#endif /* CR_EXT_blend_color */

        	{ GL_BLEND_DST, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_BLEND_DST"
#endif
        },
        
#ifdef CR_EXT_blend_func_separate

        	{ GL_BLEND_DST_ALPHA_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_BLEND_DST_ALPHA_EXT"
        #endif
        },
        
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_func_separate

        	{ GL_BLEND_DST_RGB_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_BLEND_DST_RGB_EXT"
        #endif
        },
        
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_minmax

        	{ GL_BLEND_EQUATION_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_BLEND_EQUATION_EXT"
        #endif
        },
        
#endif /* CR_EXT_blend_minmax */

        	{ GL_BLEND_SRC, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_BLEND_SRC"
#endif
        },
        
#ifdef CR_EXT_blend_func_separate

        	{ GL_BLEND_SRC_ALPHA_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_BLEND_SRC_ALPHA_EXT"
        #endif
        },
        
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_func_separate

        	{ GL_BLEND_SRC_RGB_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_BLEND_SRC_RGB_EXT"
        #endif
        },
        
#endif /* CR_EXT_blend_func_separate */

        	{ GL_BLUE_BIAS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_BLUE_BIAS"
#endif
        },
        

        	{ GL_BLUE_BITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_BLUE_BITS"
#endif
        },
        

        	{ GL_BLUE_SCALE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_BLUE_SCALE"
#endif
        },
        
#ifdef CR_ARB_multitexture

        	{ GL_CLIENT_ACTIVE_TEXTURE_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_CLIENT_ACTIVE_TEXTURE_ARB"
        #endif
        },
        
#endif /* CR_ARB_multitexture */

        	{ GL_CLIENT_ATTRIB_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CLIENT_ATTRIB_STACK_DEPTH"
#endif
        },
        

        	{ GL_CLIP_PLANE0, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CLIP_PLANE0"
#endif
        },
        

        	{ GL_CLIP_PLANE1, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CLIP_PLANE1"
#endif
        },
        

        	{ GL_CLIP_PLANE2, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CLIP_PLANE2"
#endif
        },
        

        	{ GL_CLIP_PLANE3, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CLIP_PLANE3"
#endif
        },
        

        	{ GL_CLIP_PLANE4, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CLIP_PLANE4"
#endif
        },
        

        	{ GL_CLIP_PLANE5, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CLIP_PLANE5"
#endif
        },
        
#ifdef CR_EXT_clip_volume_hint

        	{ GL_CLIP_VOLUME_CLIPPING_HINT_EXT, 3
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_CLIP_VOLUME_CLIPPING_HINT_EXT"
        #endif
        },
        
#endif /* CR_EXT_clip_volume_hint */

        	{ GL_COLOR_ARRAY, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_ARRAY"
#endif
        },
        
#ifdef CR_ARB_vertex_buffer_object

        	{ GL_COLOR_ARRAY_BUFFER_BINDING_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_ARRAY_BUFFER_BINDING_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_buffer_object */

        	{ GL_COLOR_ARRAY_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_ARRAY_SIZE"
#endif
        },
        

        	{ GL_COLOR_ARRAY_STRIDE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_ARRAY_STRIDE"
#endif
        },
        

        	{ GL_COLOR_ARRAY_TYPE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_ARRAY_TYPE"
#endif
        },
        

        	{ GL_COLOR_CLEAR_VALUE, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_CLEAR_VALUE"
#endif
        },
        

        	{ GL_COLOR_LOGIC_OP, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_LOGIC_OP"
#endif
        },
        

        	{ GL_COLOR_MATERIAL, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_MATERIAL"
#endif
        },
        

        	{ GL_COLOR_MATERIAL_FACE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_MATERIAL_FACE"
#endif
        },
        

        	{ GL_COLOR_MATERIAL_PARAMETER, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_MATERIAL_PARAMETER"
#endif
        },
        

        	{ GL_COLOR_MATRIX, 16
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_MATRIX"
#endif
        },
        

        	{ GL_COLOR_MATRIX_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_MATRIX_STACK_DEPTH"
#endif
        },
        
#ifdef CR_NV_register_combiners

        	{ GL_COLOR_SUM_CLAMP_NV, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_SUM_CLAMP_NV"
        #endif
        },
        
#endif /* CR_NV_register_combiners */
#ifdef CR_EXT_secondary_color

        	{ GL_COLOR_SUM_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_SUM_EXT"
        #endif
        },
        
#endif /* CR_EXT_secondary_color */

        	{ GL_COLOR_TABLE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_TABLE"
#endif
        },
        

        	{ GL_COLOR_WRITEMASK, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_COLOR_WRITEMASK"
#endif
        },
        
#ifdef CR_NV_register_combiners

        	{ GL_CONSTANT_COLOR0_NV, 4
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_CONSTANT_COLOR0_NV"
        #endif
        },
        
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners

        	{ GL_CONSTANT_COLOR1_NV, 4
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_CONSTANT_COLOR1_NV"
        #endif
        },
        
#endif /* CR_NV_register_combiners */

        	{ GL_CONVOLUTION_1D, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CONVOLUTION_1D"
#endif
        },
        

        	{ GL_CONVOLUTION_2D, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CONVOLUTION_2D"
#endif
        },
        

        	{ GL_CULL_FACE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CULL_FACE"
#endif
        },
        

        	{ GL_CULL_FACE_MODE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CULL_FACE_MODE"
#endif
        },
        

        	{ GL_CURRENT_COLOR, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_COLOR"
#endif
        },
        
#ifdef CR_EXT_fog_coord

        	{ GL_CURRENT_FOG_COORDINATE_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_FOG_COORDINATE_EXT"
        #endif
        },
        
#endif /* CR_EXT_fog_coord */

        	{ GL_CURRENT_INDEX, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_INDEX"
#endif
        },
        

        	{ GL_CURRENT_NORMAL, 3
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_NORMAL"
#endif
        },
        
#ifdef CR_ARB_shader_objects

        	{ GL_CURRENT_PROGRAM, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_PROGRAM"
        #endif
        },
        
#endif /* CR_ARB_shader_objects */

        	{ GL_CURRENT_RASTER_COLOR, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_RASTER_COLOR"
#endif
        },
        

        	{ GL_CURRENT_RASTER_DISTANCE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_RASTER_DISTANCE"
#endif
        },
        

        	{ GL_CURRENT_RASTER_INDEX, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_RASTER_INDEX"
#endif
        },
        

        	{ GL_CURRENT_RASTER_POSITION, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_RASTER_POSITION"
#endif
        },
        

        	{ GL_CURRENT_RASTER_POSITION_VALID, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_RASTER_POSITION_VALID"
#endif
        },
        

        	{ GL_CURRENT_RASTER_TEXTURE_COORDS, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_RASTER_TEXTURE_COORDS"
#endif
        },
        
#ifdef CR_EXT_secondary_color

        	{ GL_CURRENT_SECONDARY_COLOR_EXT, 4
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_SECONDARY_COLOR_EXT"
        #endif
        },
        
#endif /* CR_EXT_secondary_color */

        	{ GL_CURRENT_TEXTURE_COORDS, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_CURRENT_TEXTURE_COORDS"
#endif
        },
        

        	{ GL_DEPTH_BIAS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_DEPTH_BIAS"
#endif
        },
        

        	{ GL_DEPTH_BITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_DEPTH_BITS"
#endif
        },
        

        	{ GL_DEPTH_CLEAR_VALUE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_DEPTH_CLEAR_VALUE"
#endif
        },
        

        	{ GL_DEPTH_FUNC, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_DEPTH_FUNC"
#endif
        },
        

        	{ GL_DEPTH_RANGE, 2
#ifdef VBOX_WITH_CRDUMPER
            , "GL_DEPTH_RANGE"
#endif
        },
        

        	{ GL_DEPTH_SCALE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_DEPTH_SCALE"
#endif
        },
        

        	{ GL_DEPTH_TEST, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_DEPTH_TEST"
#endif
        },
        

        	{ GL_DEPTH_WRITEMASK, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_DEPTH_WRITEMASK"
#endif
        },
        

        	{ GL_DITHER, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_DITHER"
#endif
        },
        

        	{ GL_DOUBLEBUFFER, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_DOUBLEBUFFER"
#endif
        },
        

        	{ GL_DRAW_BUFFER, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER"
#endif
        },
        
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER0, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER0"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER1, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER1"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER10, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER10"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER11, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER11"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER12, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER12"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER13, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER13"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER14, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER14"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER15, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER15"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER2, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER2"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER3, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER3"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER4, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER4"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER5, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER5"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER6, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER6"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER7, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER7"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER8, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER8"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_DRAW_BUFFER9, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_BUFFER9"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_EXT_framebuffer_blit

        	{ GL_DRAW_FRAMEBUFFER_BINDING_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_DRAW_FRAMEBUFFER_BINDING_EXT"
        #endif
        },
        
#endif /* CR_EXT_framebuffer_blit */

        	{ GL_EDGE_FLAG, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_EDGE_FLAG"
#endif
        },
        

        	{ GL_EDGE_FLAG_ARRAY, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_EDGE_FLAG_ARRAY"
#endif
        },
        
#ifdef CR_ARB_vertex_buffer_object

        	{ GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_buffer_object */

        	{ GL_EDGE_FLAG_ARRAY_STRIDE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_EDGE_FLAG_ARRAY_STRIDE"
#endif
        },
        
#ifdef CR_ARB_vertex_buffer_object

        	{ GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_buffer_object */

        	{ GL_FEEDBACK_BUFFER_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_FEEDBACK_BUFFER_SIZE"
#endif
        },
        

        	{ GL_FEEDBACK_BUFFER_TYPE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_FEEDBACK_BUFFER_TYPE"
#endif
        },
        

        	{ GL_FOG, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_FOG"
#endif
        },
        

        	{ GL_FOG_COLOR, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_FOG_COLOR"
#endif
        },
        
#ifdef CR_ARB_vertex_buffer_object

        	{ GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_EXT_fog_coord

        	{ GL_FOG_COORDINATE_ARRAY_STRIDE_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_FOG_COORDINATE_ARRAY_STRIDE_EXT"
        #endif
        },
        
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord

        	{ GL_FOG_COORDINATE_ARRAY_TYPE_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_FOG_COORDINATE_ARRAY_TYPE_EXT"
        #endif
        },
        
#endif /* CR_EXT_fog_coord */

        	{ GL_FOG_DENSITY, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_FOG_DENSITY"
#endif
        },
        
#ifdef CR_NV_fog_distance

        	{ GL_FOG_DISTANCE_MODE_NV, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_FOG_DISTANCE_MODE_NV"
        #endif
        },
        
#endif /* CR_NV_fog_distance */

        	{ GL_FOG_END, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_FOG_END"
#endif
        },
        

        	{ GL_FOG_HINT, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_FOG_HINT"
#endif
        },
        

        	{ GL_FOG_INDEX, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_FOG_INDEX"
#endif
        },
        

        	{ GL_FOG_MODE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_FOG_MODE"
#endif
        },
        

        	{ GL_FOG_START, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_FOG_START"
#endif
        },
        
#ifdef CR_NV_fragment_program

        	{ GL_FRAGMENT_PROGRAM_BINDING_NV, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_FRAGMENT_PROGRAM_BINDING_NV"
        #endif
        },
        
#endif /* CR_NV_fragment_program */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_FRAGMENT_SHADER_DERIVATIVE_HINT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_FRAGMENT_SHADER_DERIVATIVE_HINT"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_EXT_framebuffer_object

        	{ GL_FRAMEBUFFER_BINDING_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_FRAMEBUFFER_BINDING_EXT"
        #endif
        },
        
#endif /* CR_EXT_framebuffer_object */

        	{ GL_FRONT_FACE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_FRONT_FACE"
#endif
        },
        
#ifdef CR_SGIS_generate_mipmap

        	{ GL_GENERATE_MIPMAP_HINT_SGIS, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_GENERATE_MIPMAP_HINT_SGIS"
        #endif
        },
        
#endif /* CR_SGIS_generate_mipmap */

        	{ GL_GREEN_BIAS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_GREEN_BIAS"
#endif
        },
        

        	{ GL_GREEN_BITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_GREEN_BITS"
#endif
        },
        

        	{ GL_GREEN_SCALE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_GREEN_SCALE"
#endif
        },
        

        	{ GL_HISTOGRAM, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_HISTOGRAM"
#endif
        },
        

        	{ GL_INDEX_ARRAY, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_INDEX_ARRAY"
#endif
        },
        
#ifdef CR_ARB_vertex_buffer_object

        	{ GL_INDEX_ARRAY_BUFFER_BINDING_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_INDEX_ARRAY_BUFFER_BINDING_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_buffer_object */

        	{ GL_INDEX_ARRAY_STRIDE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_INDEX_ARRAY_STRIDE"
#endif
        },
        

        	{ GL_INDEX_ARRAY_TYPE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_INDEX_ARRAY_TYPE"
#endif
        },
        

        	{ GL_INDEX_BITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_INDEX_BITS"
#endif
        },
        

        	{ GL_INDEX_CLEAR_VALUE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_INDEX_CLEAR_VALUE"
#endif
        },
        

        	{ GL_INDEX_LOGIC_OP, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_INDEX_LOGIC_OP"
#endif
        },
        

        	{ GL_INDEX_MODE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_INDEX_MODE"
#endif
        },
        

        	{ GL_INDEX_OFFSET, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_INDEX_OFFSET"
#endif
        },
        

        	{ GL_INDEX_SHIFT, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_INDEX_SHIFT"
#endif
        },
        

        	{ GL_INDEX_WRITEMASK, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_INDEX_WRITEMASK"
#endif
        },
        

        	{ GL_LIGHT0, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT0"
#endif
        },
        

        	{ GL_LIGHT1, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT1"
#endif
        },
        

        	{ GL_LIGHT2, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT2"
#endif
        },
        

        	{ GL_LIGHT3, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT3"
#endif
        },
        

        	{ GL_LIGHT4, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT4"
#endif
        },
        

        	{ GL_LIGHT5, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT5"
#endif
        },
        

        	{ GL_LIGHT6, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT6"
#endif
        },
        

        	{ GL_LIGHT7, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT7"
#endif
        },
        

        	{ GL_LIGHTING, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHTING"
#endif
        },
        

        	{ GL_LIGHT_MODEL_AMBIENT, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT_MODEL_AMBIENT"
#endif
        },
        
#ifdef CR_OPENGL_VERSION_1_2

        	{ GL_LIGHT_MODEL_COLOR_CONTROL, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT_MODEL_COLOR_CONTROL"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_EXT_separate_specular_color

        	{ GL_LIGHT_MODEL_COLOR_CONTROL_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT_MODEL_COLOR_CONTROL_EXT"
        #endif
        },
        
#endif /* CR_EXT_separate_specular_color */

        	{ GL_LIGHT_MODEL_LOCAL_VIEWER, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT_MODEL_LOCAL_VIEWER"
#endif
        },
        

        	{ GL_LIGHT_MODEL_TWO_SIDE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIGHT_MODEL_TWO_SIDE"
#endif
        },
        

        	{ GL_LINE_SMOOTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LINE_SMOOTH"
#endif
        },
        

        	{ GL_LINE_SMOOTH_HINT, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LINE_SMOOTH_HINT"
#endif
        },
        

        	{ GL_LINE_STIPPLE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LINE_STIPPLE"
#endif
        },
        

        	{ GL_LINE_STIPPLE_PATTERN, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LINE_STIPPLE_PATTERN"
#endif
        },
        

        	{ GL_LINE_STIPPLE_REPEAT, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LINE_STIPPLE_REPEAT"
#endif
        },
        

        	{ GL_LINE_WIDTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LINE_WIDTH"
#endif
        },
        

        	{ GL_LINE_WIDTH_GRANULARITY, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LINE_WIDTH_GRANULARITY"
#endif
        },
        

        	{ GL_LINE_WIDTH_RANGE, 2
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LINE_WIDTH_RANGE"
#endif
        },
        

        	{ GL_LIST_BASE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIST_BASE"
#endif
        },
        

        	{ GL_LIST_INDEX, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIST_INDEX"
#endif
        },
        

        	{ GL_LIST_MODE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LIST_MODE"
#endif
        },
        

        	{ GL_LOGIC_OP_MODE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_LOGIC_OP_MODE"
#endif
        },
        

        	{ GL_MAP1_COLOR_4, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP1_COLOR_4"
#endif
        },
        

        	{ GL_MAP1_GRID_DOMAIN, 2
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP1_GRID_DOMAIN"
#endif
        },
        

        	{ GL_MAP1_GRID_SEGMENTS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP1_GRID_SEGMENTS"
#endif
        },
        

        	{ GL_MAP1_INDEX, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP1_INDEX"
#endif
        },
        

        	{ GL_MAP1_NORMAL, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP1_NORMAL"
#endif
        },
        

        	{ GL_MAP1_TEXTURE_COORD_1, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP1_TEXTURE_COORD_1"
#endif
        },
        

        	{ GL_MAP1_TEXTURE_COORD_2, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP1_TEXTURE_COORD_2"
#endif
        },
        

        	{ GL_MAP1_TEXTURE_COORD_3, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP1_TEXTURE_COORD_3"
#endif
        },
        

        	{ GL_MAP1_TEXTURE_COORD_4, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP1_TEXTURE_COORD_4"
#endif
        },
        

        	{ GL_MAP1_VERTEX_3, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP1_VERTEX_3"
#endif
        },
        

        	{ GL_MAP1_VERTEX_4, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP1_VERTEX_4"
#endif
        },
        

        	{ GL_MAP2_COLOR_4, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP2_COLOR_4"
#endif
        },
        

        	{ GL_MAP2_GRID_DOMAIN, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP2_GRID_DOMAIN"
#endif
        },
        

        	{ GL_MAP2_GRID_SEGMENTS, 2
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP2_GRID_SEGMENTS"
#endif
        },
        

        	{ GL_MAP2_INDEX, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP2_INDEX"
#endif
        },
        

        	{ GL_MAP2_NORMAL, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP2_NORMAL"
#endif
        },
        

        	{ GL_MAP2_TEXTURE_COORD_1, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP2_TEXTURE_COORD_1"
#endif
        },
        

        	{ GL_MAP2_TEXTURE_COORD_2, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP2_TEXTURE_COORD_2"
#endif
        },
        

        	{ GL_MAP2_TEXTURE_COORD_3, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP2_TEXTURE_COORD_3"
#endif
        },
        

        	{ GL_MAP2_TEXTURE_COORD_4, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP2_TEXTURE_COORD_4"
#endif
        },
        

        	{ GL_MAP2_VERTEX_3, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP2_VERTEX_3"
#endif
        },
        

        	{ GL_MAP2_VERTEX_4, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP2_VERTEX_4"
#endif
        },
        

        	{ GL_MAP_COLOR, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP_COLOR"
#endif
        },
        

        	{ GL_MAP_STENCIL, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAP_STENCIL"
#endif
        },
        

        	{ GL_MATRIX_MODE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MATRIX_MODE"
#endif
        },
        

        	{ GL_MAX_3D_TEXTURE_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_3D_TEXTURE_SIZE"
#endif
        },
        

        	{ GL_MAX_ATTRIB_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_ATTRIB_STACK_DEPTH"
#endif
        },
        

        	{ GL_MAX_CLIENT_ATTRIB_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_CLIENT_ATTRIB_STACK_DEPTH"
#endif
        },
        

        	{ GL_MAX_CLIP_PLANES, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_CLIP_PLANES"
#endif
        },
        
#ifdef CR_EXT_framebuffer_object

        	{ GL_MAX_COLOR_ATTACHMENTS_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_COLOR_ATTACHMENTS_EXT"
        #endif
        },
        
#endif /* CR_EXT_framebuffer_object */

        	{ GL_MAX_COLOR_MATRIX_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_COLOR_MATRIX_STACK_DEPTH"
#endif
        },
        
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */

        	{ GL_MAX_CONVOLUTION_HEIGHT, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_CONVOLUTION_HEIGHT"
#endif
        },
        

        	{ GL_MAX_CONVOLUTION_WIDTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_CONVOLUTION_WIDTH"
#endif
        },
        
#ifdef CR_ARB_texture_cube_map

        	{ GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB"
        #endif
        },
        
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_MAX_DRAW_BUFFERS, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_DRAW_BUFFERS"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_1_2

        	{ GL_MAX_ELEMENTS_INDICES, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_ELEMENTS_INDICES"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_OPENGL_VERSION_1_2

        	{ GL_MAX_ELEMENTS_VERTICES, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_ELEMENTS_VERTICES"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_1_2 */

        	{ GL_MAX_EVAL_ORDER, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_EVAL_ORDER"
#endif
        },
        
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_MAX_FRAGMENT_UNIFORM_COMPONENTS, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_FRAGMENT_UNIFORM_COMPONENTS"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_NV_register_combiners

        	{ GL_MAX_GENERAL_COMBINERS_NV, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_GENERAL_COMBINERS_NV"
        #endif
        },
        
#endif /* CR_NV_register_combiners */

        	{ GL_MAX_LIGHTS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_LIGHTS"
#endif
        },
        

        	{ GL_MAX_LIST_NESTING, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_LIST_NESTING"
#endif
        },
        

        	{ GL_MAX_MODELVIEW_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_MODELVIEW_STACK_DEPTH"
#endif
        },
        

        	{ GL_MAX_NAME_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_NAME_STACK_DEPTH"
#endif
        },
        

        	{ GL_MAX_PIXEL_MAP_TABLE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_PIXEL_MAP_TABLE"
#endif
        },
        
#ifdef CR_ARB_vertex_program

        	{ GL_MAX_PROGRAM_MATRICES_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_PROGRAM_MATRICES_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_program */
#ifdef CR_ARB_vertex_program

        	{ GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_program */

        	{ GL_MAX_PROJECTION_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_PROJECTION_STACK_DEPTH"
#endif
        },
        
#ifdef CR_NV_texture_rectangle

        	{ GL_MAX_RECTANGLE_TEXTURE_SIZE_NV, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_RECTANGLE_TEXTURE_SIZE_NV"
        #endif
        },
        
#endif /* CR_NV_texture_rectangle */
#ifdef CR_EXT_framebuffer_object

        	{ GL_MAX_RENDERBUFFER_SIZE_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_RENDERBUFFER_SIZE_EXT"
        #endif
        },
        
#endif /* CR_EXT_framebuffer_object */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_MAX_TEXTURE_COORDS, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_TEXTURE_COORDS"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_ARB_vertex_program

        	{ GL_MAX_TEXTURE_COORDS_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_TEXTURE_COORDS_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_program */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_MAX_TEXTURE_IMAGE_UNITS, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_TEXTURE_IMAGE_UNITS"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_ARB_fragment_program

        	{ GL_MAX_TEXTURE_IMAGE_UNITS_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_TEXTURE_IMAGE_UNITS_ARB"
        #endif
        },
        
#endif /* CR_ARB_fragment_program */
#ifdef CR_EXT_texture_lod_bias

        	{ GL_MAX_TEXTURE_LOD_BIAS_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_TEXTURE_LOD_BIAS_EXT"
        #endif
        },
        
#endif /* CR_EXT_texture_lod_bias */
#ifdef CR_EXT_texture_filter_anisotropic

        	{ GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT"
        #endif
        },
        
#endif /* CR_EXT_texture_filter_anisotropic */

        	{ GL_MAX_TEXTURE_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_TEXTURE_SIZE"
#endif
        },
        

        	{ GL_MAX_TEXTURE_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_TEXTURE_STACK_DEPTH"
#endif
        },
        
#ifdef CR_ARB_multitexture

        	{ GL_MAX_TEXTURE_UNITS_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_TEXTURE_UNITS_ARB"
        #endif
        },
        
#endif /* CR_ARB_multitexture */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_MAX_VARYING_FLOATS, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_VARYING_FLOATS"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_MAX_VERTEX_ATTRIBS, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_VERTEX_ATTRIBS"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_ARB_vertex_program

        	{ GL_MAX_VERTEX_ATTRIBS_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_VERTEX_ATTRIBS_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_program */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_MAX_VERTEX_UNIFORM_COMPONENTS, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_VERTEX_UNIFORM_COMPONENTS"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */

        	{ GL_MAX_VIEWPORT_DIMS, 2
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MAX_VIEWPORT_DIMS"
#endif
        },
        

        	{ GL_MINMAX, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MINMAX"
#endif
        },
        

        	{ GL_MODELVIEW_MATRIX, 16
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MODELVIEW_MATRIX"
#endif
        },
        

        	{ GL_MODELVIEW_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_MODELVIEW_STACK_DEPTH"
#endif
        },
        
#ifdef CR_ARB_multisample

        	{ GL_MULTISAMPLE_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_MULTISAMPLE_ARB"
        #endif
        },
        
#endif /* CR_ARB_multisample */

        	{ GL_NAME_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_NAME_STACK_DEPTH"
#endif
        },
        

        	{ GL_NORMALIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_NORMALIZE"
#endif
        },
        

        	{ GL_NORMAL_ARRAY, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_NORMAL_ARRAY"
#endif
        },
        
#ifdef CR_ARB_vertex_buffer_object

        	{ GL_NORMAL_ARRAY_BUFFER_BINDING_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_NORMAL_ARRAY_BUFFER_BINDING_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_buffer_object */

        	{ GL_NORMAL_ARRAY_STRIDE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_NORMAL_ARRAY_STRIDE"
#endif
        },
        

        	{ GL_NORMAL_ARRAY_TYPE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_NORMAL_ARRAY_TYPE"
#endif
        },
        
#ifdef CR_ARB_texture_compression

        	{ GL_NUM_COMPRESSED_TEXTURE_FORMATS, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_NUM_COMPRESSED_TEXTURE_FORMATS"
        #endif
        },
        
#endif /* CR_ARB_texture_compression */
#ifdef CR_ARB_texture_compression

        	{ GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB"
        #endif
        },
        
#endif /* CR_ARB_texture_compression */
#ifdef CR_NV_register_combiners

        	{ GL_NUM_GENERAL_COMBINERS_NV, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_NUM_GENERAL_COMBINERS_NV"
        #endif
        },
        
#endif /* CR_NV_register_combiners */

        	{ GL_PACK_ALIGNMENT, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PACK_ALIGNMENT"
#endif
        },
        
#ifdef CR_OPENGL_VERSION_1_2

        	{ GL_PACK_IMAGE_HEIGHT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_PACK_IMAGE_HEIGHT"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_1_2 */

        	{ GL_PACK_LSB_FIRST, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PACK_LSB_FIRST"
#endif
        },
        

        	{ GL_PACK_ROW_LENGTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PACK_ROW_LENGTH"
#endif
        },
        
#ifdef CR_OPENGL_VERSION_1_2

        	{ GL_PACK_SKIP_IMAGES, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_PACK_SKIP_IMAGES"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_1_2 */

        	{ GL_PACK_SKIP_PIXELS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PACK_SKIP_PIXELS"
#endif
        },
        

        	{ GL_PACK_SKIP_ROWS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PACK_SKIP_ROWS"
#endif
        },
        

        	{ GL_PACK_SWAP_BYTES, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PACK_SWAP_BYTES"
#endif
        },
        

        	{ GL_PERSPECTIVE_CORRECTION_HINT, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PERSPECTIVE_CORRECTION_HINT"
#endif
        },
        
#ifdef CR_NV_register_combiners2

        	{ GL_PER_STAGE_CONSTANTS_NV, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_PER_STAGE_CONSTANTS_NV"
        #endif
        },
        
#endif /* CR_NV_register_combiners2 */

        	{ GL_PIXEL_MAP_A_TO_A_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PIXEL_MAP_A_TO_A_SIZE"
#endif
        },
        

        	{ GL_PIXEL_MAP_B_TO_B_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PIXEL_MAP_B_TO_B_SIZE"
#endif
        },
        

        	{ GL_PIXEL_MAP_G_TO_G_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PIXEL_MAP_G_TO_G_SIZE"
#endif
        },
        

        	{ GL_PIXEL_MAP_I_TO_A_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PIXEL_MAP_I_TO_A_SIZE"
#endif
        },
        

        	{ GL_PIXEL_MAP_I_TO_B_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PIXEL_MAP_I_TO_B_SIZE"
#endif
        },
        

        	{ GL_PIXEL_MAP_I_TO_G_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PIXEL_MAP_I_TO_G_SIZE"
#endif
        },
        

        	{ GL_PIXEL_MAP_I_TO_I_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PIXEL_MAP_I_TO_I_SIZE"
#endif
        },
        

        	{ GL_PIXEL_MAP_I_TO_R_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PIXEL_MAP_I_TO_R_SIZE"
#endif
        },
        

        	{ GL_PIXEL_MAP_R_TO_R_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PIXEL_MAP_R_TO_R_SIZE"
#endif
        },
        

        	{ GL_PIXEL_MAP_S_TO_S_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PIXEL_MAP_S_TO_S_SIZE"
#endif
        },
        

        	{ GL_POINT_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POINT_SIZE"
#endif
        },
        

        	{ GL_POINT_SIZE_GRANULARITY, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POINT_SIZE_GRANULARITY"
#endif
        },
        

        	{ GL_POINT_SIZE_RANGE, 2
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POINT_SIZE_RANGE"
#endif
        },
        

        	{ GL_POINT_SMOOTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POINT_SMOOTH"
#endif
        },
        

        	{ GL_POINT_SMOOTH_HINT, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POINT_SMOOTH_HINT"
#endif
        },
        
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_POINT_SPRITE, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_POINT_SPRITE"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_ARB_point_sprite

        	{ GL_POINT_SPRITE_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_POINT_SPRITE_ARB"
        #endif
        },
        
#endif /* CR_ARB_point_sprite */

        	{ GL_POLYGON_MODE, 2
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POLYGON_MODE"
#endif
        },
        

        	{ GL_POLYGON_OFFSET_FACTOR, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POLYGON_OFFSET_FACTOR"
#endif
        },
        

        	{ GL_POLYGON_OFFSET_FILL, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POLYGON_OFFSET_FILL"
#endif
        },
        

        	{ GL_POLYGON_OFFSET_LINE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POLYGON_OFFSET_LINE"
#endif
        },
        

        	{ GL_POLYGON_OFFSET_POINT, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POLYGON_OFFSET_POINT"
#endif
        },
        

        	{ GL_POLYGON_OFFSET_UNITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POLYGON_OFFSET_UNITS"
#endif
        },
        

        	{ GL_POLYGON_SMOOTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POLYGON_SMOOTH"
#endif
        },
        

        	{ GL_POLYGON_SMOOTH_HINT, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POLYGON_SMOOTH_HINT"
#endif
        },
        

        	{ GL_POLYGON_STIPPLE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POLYGON_STIPPLE"
#endif
        },
        

        	{ GL_POST_COLOR_MATRIX_COLOR_TABLE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POST_COLOR_MATRIX_COLOR_TABLE"
#endif
        },
        

        	{ GL_POST_CONVOLUTION_ALPHA_BIAS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POST_CONVOLUTION_ALPHA_BIAS"
#endif
        },
        

        	{ GL_POST_CONVOLUTION_ALPHA_SCALE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POST_CONVOLUTION_ALPHA_SCALE"
#endif
        },
        

        	{ GL_POST_CONVOLUTION_BLUE_BIAS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POST_CONVOLUTION_BLUE_BIAS"
#endif
        },
        

        	{ GL_POST_CONVOLUTION_BLUE_SCALE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POST_CONVOLUTION_BLUE_SCALE"
#endif
        },
        

        	{ GL_POST_CONVOLUTION_COLOR_TABLE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POST_CONVOLUTION_COLOR_TABLE"
#endif
        },
        

        	{ GL_POST_CONVOLUTION_GREEN_BIAS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POST_CONVOLUTION_GREEN_BIAS"
#endif
        },
        

        	{ GL_POST_CONVOLUTION_GREEN_SCALE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POST_CONVOLUTION_GREEN_SCALE"
#endif
        },
        

        	{ GL_POST_CONVOLUTION_RED_BIAS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POST_CONVOLUTION_RED_BIAS"
#endif
        },
        

        	{ GL_POST_CONVOLUTION_RED_SCALE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_POST_CONVOLUTION_RED_SCALE"
#endif
        },
        
#ifdef CR_NV_fragment_program

        	{ GL_PROGRAM_ERROR_POSITION_NV, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_PROGRAM_ERROR_POSITION_NV"
        #endif
        },
        
#endif /* CR_NV_fragment_program */

        	{ GL_PROJECTION_MATRIX, 16
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PROJECTION_MATRIX"
#endif
        },
        

        	{ GL_PROJECTION_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PROJECTION_STACK_DEPTH"
#endif
        },
        

        	{ GL_PROXY_COLOR_TABLE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_PROXY_COLOR_TABLE"
#endif
        },
        
#ifdef CR_IBM_rasterpos_clip

        	{ GL_RASTER_POSITION_UNCLIPPED_IBM, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_RASTER_POSITION_UNCLIPPED_IBM"
        #endif
        },
        
#endif /* CR_IBM_rasterpos_clip */

        	{ GL_READ_BUFFER, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_READ_BUFFER"
#endif
        },
        
#ifdef CR_EXT_framebuffer_blit

        	{ GL_READ_FRAMEBUFFER_BINDING_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_READ_FRAMEBUFFER_BINDING_EXT"
        #endif
        },
        
#endif /* CR_EXT_framebuffer_blit */

        	{ GL_RED_BIAS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_RED_BIAS"
#endif
        },
        

        	{ GL_RED_BITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_RED_BITS"
#endif
        },
        

        	{ GL_RED_SCALE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_RED_SCALE"
#endif
        },
        
#ifdef CR_EXT_framebuffer_object

        	{ GL_RENDERBUFFER_BINDING_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_RENDERBUFFER_BINDING_EXT"
        #endif
        },
        
#endif /* CR_EXT_framebuffer_object */

        	{ GL_RENDER_MODE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_RENDER_MODE"
#endif
        },
        
#ifdef CR_OPENGL_VERSION_1_2

        	{ GL_RESCALE_NORMAL, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_RESCALE_NORMAL"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_1_2 */

        	{ GL_RGBA_MODE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_RGBA_MODE"
#endif
        },
        
#ifdef CR_ARB_multisample

        	{ GL_SAMPLES_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_SAMPLES_ARB"
        #endif
        },
        
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample

        	{ GL_SAMPLE_ALPHA_TO_COVERAGE_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_SAMPLE_ALPHA_TO_COVERAGE_ARB"
        #endif
        },
        
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample

        	{ GL_SAMPLE_ALPHA_TO_ONE_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_SAMPLE_ALPHA_TO_ONE_ARB"
        #endif
        },
        
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample

        	{ GL_SAMPLE_BUFFERS_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_SAMPLE_BUFFERS_ARB"
        #endif
        },
        
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample

        	{ GL_SAMPLE_COVERAGE_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_SAMPLE_COVERAGE_ARB"
        #endif
        },
        
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample

        	{ GL_SAMPLE_COVERAGE_INVERT_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_SAMPLE_COVERAGE_INVERT_ARB"
        #endif
        },
        
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample

        	{ GL_SAMPLE_COVERAGE_VALUE_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_SAMPLE_COVERAGE_VALUE_ARB"
        #endif
        },
        
#endif /* CR_ARB_multisample */

        	{ GL_SCISSOR_BOX, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_SCISSOR_BOX"
#endif
        },
        

        	{ GL_SCISSOR_TEST, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_SCISSOR_TEST"
#endif
        },
        
#ifdef CR_ARB_vertex_buffer_object

        	{ GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_EXT_secondary_color

        	{ GL_SECONDARY_COLOR_ARRAY_SIZE_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_SECONDARY_COLOR_ARRAY_SIZE_EXT"
        #endif
        },
        
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color

        	{ GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT"
        #endif
        },
        
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color

        	{ GL_SECONDARY_COLOR_ARRAY_TYPE_EXT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_SECONDARY_COLOR_ARRAY_TYPE_EXT"
        #endif
        },
        
#endif /* CR_EXT_secondary_color */

        	{ GL_SELECTION_BUFFER_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_SELECTION_BUFFER_SIZE"
#endif
        },
        

        	{ GL_SEPARABLE_2D, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_SEPARABLE_2D"
#endif
        },
        

        	{ GL_SHADE_MODEL, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_SHADE_MODEL"
#endif
        },
        
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_STENCIL_BACK_FAIL, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_BACK_FAIL"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_STENCIL_BACK_FUNC, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_BACK_FUNC"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_STENCIL_BACK_PASS_DEPTH_FAIL, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_BACK_PASS_DEPTH_FAIL"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_STENCIL_BACK_PASS_DEPTH_PASS, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_BACK_PASS_DEPTH_PASS"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_STENCIL_BACK_REF, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_BACK_REF"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_STENCIL_BACK_VALUE_MASK, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_BACK_VALUE_MASK"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */

        	{ GL_STENCIL_BITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_BITS"
#endif
        },
        

        	{ GL_STENCIL_CLEAR_VALUE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_CLEAR_VALUE"
#endif
        },
        

        	{ GL_STENCIL_FAIL, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_FAIL"
#endif
        },
        

        	{ GL_STENCIL_FUNC, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_FUNC"
#endif
        },
        

        	{ GL_STENCIL_PASS_DEPTH_FAIL, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_PASS_DEPTH_FAIL"
#endif
        },
        

        	{ GL_STENCIL_PASS_DEPTH_PASS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_PASS_DEPTH_PASS"
#endif
        },
        

        	{ GL_STENCIL_REF, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_REF"
#endif
        },
        

        	{ GL_STENCIL_TEST, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_TEST"
#endif
        },
        

        	{ GL_STENCIL_VALUE_MASK, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_VALUE_MASK"
#endif
        },
        

        	{ GL_STENCIL_WRITEMASK, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_STENCIL_WRITEMASK"
#endif
        },
        

        	{ GL_STEREO, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_STEREO"
#endif
        },
        

        	{ GL_SUBPIXEL_BITS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_SUBPIXEL_BITS"
#endif
        },
        

        	{ GL_TEXTURE_1D, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_1D"
#endif
        },
        

        	{ GL_TEXTURE_2D, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_2D"
#endif
        },
        
#ifdef CR_OPENGL_VERSION_1_2

        	{ GL_TEXTURE_3D, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_3D"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_1_2 */

        	{ GL_TEXTURE_BINDING_1D, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_BINDING_1D"
#endif
        },
        

        	{ GL_TEXTURE_BINDING_2D, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_BINDING_2D"
#endif
        },
        

        	{ GL_TEXTURE_BINDING_3D, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_BINDING_3D"
#endif
        },
        
#ifdef CR_ARB_texture_cube_map

        	{ GL_TEXTURE_BINDING_CUBE_MAP_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_BINDING_CUBE_MAP_ARB"
        #endif
        },
        
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_texture_rectangle

        	{ GL_TEXTURE_BINDING_RECTANGLE_NV, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_BINDING_RECTANGLE_NV"
        #endif
        },
        
#endif /* CR_NV_texture_rectangle */

        	{ GL_TEXTURE_COORD_ARRAY, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_COORD_ARRAY"
#endif
        },
        
#ifdef CR_ARB_vertex_buffer_object

        	{ GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_buffer_object */

        	{ GL_TEXTURE_COORD_ARRAY_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_COORD_ARRAY_SIZE"
#endif
        },
        

        	{ GL_TEXTURE_COORD_ARRAY_STRIDE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_COORD_ARRAY_STRIDE"
#endif
        },
        

        	{ GL_TEXTURE_COORD_ARRAY_TYPE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_COORD_ARRAY_TYPE"
#endif
        },
        
#ifdef CR_ARB_texture_cube_map

        	{ GL_TEXTURE_CUBE_MAP_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_CUBE_MAP_ARB"
        #endif
        },
        
#endif /* CR_ARB_texture_cube_map */

        	{ GL_TEXTURE_ENV_COLOR, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_ENV_COLOR"
#endif
        },
        

        	{ GL_TEXTURE_ENV_MODE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_ENV_MODE"
#endif
        },
        

        	{ GL_TEXTURE_GEN_Q, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_GEN_Q"
#endif
        },
        

        	{ GL_TEXTURE_GEN_R, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_GEN_R"
#endif
        },
        

        	{ GL_TEXTURE_GEN_S, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_GEN_S"
#endif
        },
        

        	{ GL_TEXTURE_GEN_T, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_GEN_T"
#endif
        },
        

        	{ GL_TEXTURE_MATRIX, 16
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_MATRIX"
#endif
        },
        
#ifdef CR_NV_texture_rectangle

        	{ GL_TEXTURE_RECTANGLE_NV, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_RECTANGLE_NV"
        #endif
        },
        
#endif /* CR_NV_texture_rectangle */

        	{ GL_TEXTURE_STACK_DEPTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_TEXTURE_STACK_DEPTH"
#endif
        },
        
#ifdef CR_ARB_transpose_matrix

        	{ GL_TRANSPOSE_COLOR_MATRIX_ARB, 16
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_TRANSPOSE_COLOR_MATRIX_ARB"
        #endif
        },
        
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_ARB_transpose_matrix

        	{ GL_TRANSPOSE_MODELVIEW_MATRIX_ARB, 16
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_TRANSPOSE_MODELVIEW_MATRIX_ARB"
        #endif
        },
        
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_ARB_transpose_matrix

        	{ GL_TRANSPOSE_PROJECTION_MATRIX_ARB, 16
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_TRANSPOSE_PROJECTION_MATRIX_ARB"
        #endif
        },
        
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_ARB_transpose_matrix

        	{ GL_TRANSPOSE_TEXTURE_MATRIX_ARB, 16
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_TRANSPOSE_TEXTURE_MATRIX_ARB"
        #endif
        },
        
#endif /* CR_ARB_transpose_matrix */

        	{ GL_UNPACK_ALIGNMENT, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_UNPACK_ALIGNMENT"
#endif
        },
        
#ifdef CR_OPENGL_VERSION_1_2

        	{ GL_UNPACK_IMAGE_HEIGHT, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_UNPACK_IMAGE_HEIGHT"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_1_2 */

        	{ GL_UNPACK_LSB_FIRST, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_UNPACK_LSB_FIRST"
#endif
        },
        

        	{ GL_UNPACK_ROW_LENGTH, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_UNPACK_ROW_LENGTH"
#endif
        },
        
#ifdef CR_OPENGL_VERSION_1_2

        	{ GL_UNPACK_SKIP_IMAGES, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_UNPACK_SKIP_IMAGES"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_1_2 */

        	{ GL_UNPACK_SKIP_PIXELS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_UNPACK_SKIP_PIXELS"
#endif
        },
        

        	{ GL_UNPACK_SKIP_ROWS, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_UNPACK_SKIP_ROWS"
#endif
        },
        

        	{ GL_UNPACK_SWAP_BYTES, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_UNPACK_SWAP_BYTES"
#endif
        },
        

        	{ GL_VERTEX_ARRAY, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_VERTEX_ARRAY"
#endif
        },
        
#ifdef CR_ARB_vertex_buffer_object

        	{ GL_VERTEX_ARRAY_BUFFER_BINDING_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_VERTEX_ARRAY_BUFFER_BINDING_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_buffer_object */

        	{ GL_VERTEX_ARRAY_SIZE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_VERTEX_ARRAY_SIZE"
#endif
        },
        

        	{ GL_VERTEX_ARRAY_STRIDE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_VERTEX_ARRAY_STRIDE"
#endif
        },
        

        	{ GL_VERTEX_ARRAY_TYPE, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_VERTEX_ARRAY_TYPE"
#endif
        },
        
#ifdef CR_NV_vertex_program

        	{ GL_VERTEX_PROGRAM_BINDING_NV, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_VERTEX_PROGRAM_BINDING_NV"
        #endif
        },
        
#endif /* CR_NV_vertex_program */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_VERTEX_PROGRAM_POINT_SIZE, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_VERTEX_PROGRAM_POINT_SIZE"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */
#ifdef CR_OPENGL_VERSION_2_0

        	{ GL_VERTEX_PROGRAM_TWO_SIDE, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_VERTEX_PROGRAM_TWO_SIDE"
        #endif
        },
        
#endif /* CR_OPENGL_VERSION_2_0 */

        	{ GL_VIEWPORT, 4
#ifdef VBOX_WITH_CRDUMPER
            , "GL_VIEWPORT"
#endif
        },
        
#ifdef CR_ARB_vertex_buffer_object

        	{ GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB, 1
        #ifdef VBOX_WITH_CRDUMPER
            , "GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB"
        #endif
        },
        
#endif /* CR_ARB_vertex_buffer_object */

        	{ GL_ZOOM_X, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ZOOM_X"
#endif
        },
        

        	{ GL_ZOOM_Y, 1
#ifdef VBOX_WITH_CRDUMPER
            , "GL_ZOOM_Y"
#endif
        },
        
	{ 0, 0 }
};
#define CR_MAX_GET_VALUES 16

static unsigned int __numValues( GLenum pname )
{
    struct nv_struct *temp;
    
    for (temp = num_values_array; temp->num_values != 0 ; temp++)
    {
        if (temp->pname == pname)
            return temp->num_values;
    }
    crDebug( "Invalid pname to __numValues: 0x%x\n", (int) pname );
    return 0;
}

GLuint PACKSPU_APIENTRY packspu_CreateShader(GLenum type)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLuint return_val = (GLuint) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_CreateShader doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackCreateShaderSWAP(type, &return_val, &writeback);
	}
	else
	{
		crPackCreateShader(type, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLuint) SWAP32(return_val);
	}
	return return_val;
}

void PACKSPU_APIENTRY packspu_GenFencesNV(GLsizei n, GLuint * fences)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GenFencesNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGenFencesNVSWAP(n, fences, &writeback);
	}
	else
	{
		crPackGenFencesNV(n, fences, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

GLuint PACKSPU_APIENTRY packspu_GenLists(GLsizei range)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLuint return_val = (GLuint) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GenLists doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGenListsSWAP(range, &return_val, &writeback);
	}
	else
	{
		crPackGenLists(range, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLuint) SWAP32(return_val);
	}
	return return_val;
}

void PACKSPU_APIENTRY packspu_GenProgramsARB(GLsizei n, GLuint * programs)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GenProgramsARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGenProgramsARBSWAP(n, programs, &writeback);
	}
	else
	{
		crPackGenProgramsARB(n, programs, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GenProgramsNV(GLsizei n, GLuint * ids)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GenProgramsNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGenProgramsNVSWAP(n, ids, &writeback);
	}
	else
	{
		crPackGenProgramsNV(n, ids, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GenQueriesARB(GLsizei n, GLuint * ids)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GenQueriesARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGenQueriesARBSWAP(n, ids, &writeback);
	}
	else
	{
		crPackGenQueriesARB(n, ids, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetBooleanv(GLenum pname, GLboolean * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetBooleanv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}

    if (crPackIsPixelStoreParm(pname)
        || pname == GL_DRAW_BUFFER
#ifdef CR_OPENGL_VERSION_1_3
        || pname == GL_ACTIVE_TEXTURE
#endif
#ifdef CR_ARB_multitexture
        || pname == GL_ACTIVE_TEXTURE_ARB
#endif
        || pname == GL_TEXTURE_BINDING_1D
        || pname == GL_TEXTURE_BINDING_2D
#ifdef CR_NV_texture_rectangle
        || pname == GL_TEXTURE_BINDING_RECTANGLE_NV
#endif
#ifdef CR_ARB_texture_cube_map
        || pname == GL_TEXTURE_BINDING_CUBE_MAP_ARB
#endif
#ifdef CR_ARB_vertex_program
        || pname == GL_MAX_VERTEX_ATTRIBS_ARB
#endif
#ifdef GL_EXT_framebuffer_object
        || pname == GL_FRAMEBUFFER_BINDING_EXT
        || pname == GL_READ_FRAMEBUFFER_BINDING_EXT
        || pname == GL_DRAW_FRAMEBUFFER_BINDING_EXT
#endif
        || pname == GL_ARRAY_BUFFER_BINDING
        || pname == GL_ELEMENT_ARRAY_BUFFER_BINDING
        || pname == GL_PIXEL_PACK_BUFFER_BINDING
        || pname == GL_PIXEL_UNPACK_BUFFER_BINDING
        )
        {
#ifdef DEBUG
            if (!crPackIsPixelStoreParm(pname)
#ifdef CR_ARB_vertex_program
                && (pname!=GL_MAX_VERTEX_ATTRIBS_ARB)
#endif
               )
            {
                GLboolean * localparams;
                localparams = (GLboolean *) crAlloc(__numValues(pname) * sizeof(*localparams));
                crStateGetBooleanv(pname, localparams);
                crPackGetBooleanv(pname, params, &writeback);
                packspuFlush( (void *) thread );
                CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
                for (i=0; i<__numValues(pname); ++i)
                {
                    if (localparams[i] != params[i])
                    {
                        crWarning("Incorrect local state in GetBooleanv for %x param %i", pname, i);
                        crWarning("Expected %i but got %i", (int)localparams[i], (int)params[i]);
                    }
                }
                crFree(localparams);
                return;
            }
            else
#endif
            {
                crStateGetBooleanv(pname, params);
                return;
            }

        }
            
	if (pack_spu.swap)
	{
		crPackGetBooleanvSWAP(pname, params, &writeback);
	}
	else
	{
		crPackGetBooleanv(pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < __numValues(pname); i++)
		{
			((GLuint *) params)[i] = (GLboolean) SWAP32(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetChromiumParametervCR(GLenum target, GLuint index, GLenum type, GLsizei count, GLvoid * values)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetChromiumParametervCR doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetChromiumParametervCRSWAP(target, index, type, count, values, &writeback);
	}
	else
	{
		crPackGetChromiumParametervCR(target, index, type, count, values, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetClipPlane(GLenum plane, GLdouble * equation)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetClipPlane doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetClipPlaneSWAP(plane, equation, &writeback);
	}
	else
	{
		crPackGetClipPlane(plane, equation, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < 4; i++)
		{
			equation[i] = SWAPDOUBLE(equation[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetCombinerInputParameterfvNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetCombinerInputParameterfvNVSWAP(stage, portion, variable, pname, params, &writeback);
	}
	else
	{
		crPackGetCombinerInputParameterfvNV(stage, portion, variable, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetCombinerInputParameterivNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetCombinerInputParameterivNVSWAP(stage, portion, variable, pname, params, &writeback);
	}
	else
	{
		crPackGetCombinerInputParameterivNV(stage, portion, variable, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetCombinerOutputParameterfvNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetCombinerOutputParameterfvNVSWAP(stage, portion, pname, params, &writeback);
	}
	else
	{
		crPackGetCombinerOutputParameterfvNV(stage, portion, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetCombinerOutputParameterivNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetCombinerOutputParameterivNVSWAP(stage, portion, pname, params, &writeback);
	}
	else
	{
		crPackGetCombinerOutputParameterivNV(stage, portion, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetCombinerStageParameterfvNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetCombinerStageParameterfvNVSWAP(stage, pname, params, &writeback);
	}
	else
	{
		crPackGetCombinerStageParameterfvNV(stage, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetDoublev(GLenum pname, GLdouble * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetDoublev doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}

    if (crPackIsPixelStoreParm(pname)
        || pname == GL_DRAW_BUFFER
#ifdef CR_OPENGL_VERSION_1_3
        || pname == GL_ACTIVE_TEXTURE
#endif
#ifdef CR_ARB_multitexture
        || pname == GL_ACTIVE_TEXTURE_ARB
#endif
        || pname == GL_TEXTURE_BINDING_1D
        || pname == GL_TEXTURE_BINDING_2D
#ifdef CR_NV_texture_rectangle
        || pname == GL_TEXTURE_BINDING_RECTANGLE_NV
#endif
#ifdef CR_ARB_texture_cube_map
        || pname == GL_TEXTURE_BINDING_CUBE_MAP_ARB
#endif
#ifdef CR_ARB_vertex_program
        || pname == GL_MAX_VERTEX_ATTRIBS_ARB
#endif
#ifdef GL_EXT_framebuffer_object
        || pname == GL_FRAMEBUFFER_BINDING_EXT
        || pname == GL_READ_FRAMEBUFFER_BINDING_EXT
        || pname == GL_DRAW_FRAMEBUFFER_BINDING_EXT
#endif
        || pname == GL_ARRAY_BUFFER_BINDING
        || pname == GL_ELEMENT_ARRAY_BUFFER_BINDING
        || pname == GL_PIXEL_PACK_BUFFER_BINDING
        || pname == GL_PIXEL_UNPACK_BUFFER_BINDING
        )
        {
#ifdef DEBUG
            if (!crPackIsPixelStoreParm(pname)
#ifdef CR_ARB_vertex_program
                && (pname!=GL_MAX_VERTEX_ATTRIBS_ARB)
#endif
               )
            {
                GLdouble * localparams;
                localparams = (GLdouble *) crAlloc(__numValues(pname) * sizeof(*localparams));
                crStateGetDoublev(pname, localparams);
                crPackGetDoublev(pname, params, &writeback);
                packspuFlush( (void *) thread );
                CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
                for (i=0; i<__numValues(pname); ++i)
                {
                    if (localparams[i] != params[i])
                    {
                        crWarning("Incorrect local state in GetDoublev for %x param %i", pname, i);
                        crWarning("Expected %i but got %i", (int)localparams[i], (int)params[i]);
                    }
                }
                crFree(localparams);
                return;
            }
            else
#endif
            {
                crStateGetDoublev(pname, params);
                return;
            }

        }
            
	if (pack_spu.swap)
	{
		crPackGetDoublevSWAP(pname, params, &writeback);
	}
	else
	{
		crPackGetDoublev(pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < __numValues(pname); i++)
		{
			params[i] = SWAPDOUBLE(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetFenceivNV(GLuint fence, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetFenceivNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetFenceivNVSWAP(fence, pname, params, &writeback);
	}
	else
	{
		crPackGetFenceivNV(fence, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetFinalCombinerInputParameterfvNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetFinalCombinerInputParameterfvNVSWAP(variable, pname, params, &writeback);
	}
	else
	{
		crPackGetFinalCombinerInputParameterfvNV(variable, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetFinalCombinerInputParameterivNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetFinalCombinerInputParameterivNVSWAP(variable, pname, params, &writeback);
	}
	else
	{
		crPackGetFinalCombinerInputParameterivNV(variable, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetFloatv(GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetFloatv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}

    if (crPackIsPixelStoreParm(pname)
        || pname == GL_DRAW_BUFFER
#ifdef CR_OPENGL_VERSION_1_3
        || pname == GL_ACTIVE_TEXTURE
#endif
#ifdef CR_ARB_multitexture
        || pname == GL_ACTIVE_TEXTURE_ARB
#endif
        || pname == GL_TEXTURE_BINDING_1D
        || pname == GL_TEXTURE_BINDING_2D
#ifdef CR_NV_texture_rectangle
        || pname == GL_TEXTURE_BINDING_RECTANGLE_NV
#endif
#ifdef CR_ARB_texture_cube_map
        || pname == GL_TEXTURE_BINDING_CUBE_MAP_ARB
#endif
#ifdef CR_ARB_vertex_program
        || pname == GL_MAX_VERTEX_ATTRIBS_ARB
#endif
#ifdef GL_EXT_framebuffer_object
        || pname == GL_FRAMEBUFFER_BINDING_EXT
        || pname == GL_READ_FRAMEBUFFER_BINDING_EXT
        || pname == GL_DRAW_FRAMEBUFFER_BINDING_EXT
#endif
        || pname == GL_ARRAY_BUFFER_BINDING
        || pname == GL_ELEMENT_ARRAY_BUFFER_BINDING
        || pname == GL_PIXEL_PACK_BUFFER_BINDING
        || pname == GL_PIXEL_UNPACK_BUFFER_BINDING
        )
        {
#ifdef DEBUG
            if (!crPackIsPixelStoreParm(pname)
#ifdef CR_ARB_vertex_program
                && (pname!=GL_MAX_VERTEX_ATTRIBS_ARB)
#endif
               )
            {
                GLfloat * localparams;
                localparams = (GLfloat *) crAlloc(__numValues(pname) * sizeof(*localparams));
                crStateGetFloatv(pname, localparams);
                crPackGetFloatv(pname, params, &writeback);
                packspuFlush( (void *) thread );
                CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
                for (i=0; i<__numValues(pname); ++i)
                {
                    if (localparams[i] != params[i])
                    {
                        crWarning("Incorrect local state in GetFloatv for %x param %i", pname, i);
                        crWarning("Expected %i but got %i", (int)localparams[i], (int)params[i]);
                    }
                }
                crFree(localparams);
                return;
            }
            else
#endif
            {
                crStateGetFloatv(pname, params);
                return;
            }

        }
            
	if (pack_spu.swap)
	{
		crPackGetFloatvSWAP(pname, params, &writeback);
	}
	else
	{
		crPackGetFloatv(pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < __numValues(pname); i++)
		{
			((GLuint *) params)[i] = SWAPFLOAT(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetFramebufferAttachmentParameterivEXT doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetFramebufferAttachmentParameterivEXTSWAP(target, attachment, pname, params, &writeback);
	}
	else
	{
		crPackGetFramebufferAttachmentParameterivEXT(target, attachment, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

VBoxGLhandleARB PACKSPU_APIENTRY packspu_GetHandleARB(GLenum pname)
{
	GET_THREAD(thread);
	int writeback = 1;
	VBoxGLhandleARB return_val = (VBoxGLhandleARB) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetHandleARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetHandleARBSWAP(pname, &return_val, &writeback);
	}
	else
	{
		crPackGetHandleARB(pname, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (VBoxGLhandleARB) SWAP32(return_val);
	}
	return return_val;
}

void PACKSPU_APIENTRY packspu_GetIntegerv(GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetIntegerv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}

    if (crPackIsPixelStoreParm(pname)
        || pname == GL_DRAW_BUFFER
#ifdef CR_OPENGL_VERSION_1_3
        || pname == GL_ACTIVE_TEXTURE
#endif
#ifdef CR_ARB_multitexture
        || pname == GL_ACTIVE_TEXTURE_ARB
#endif
        || pname == GL_TEXTURE_BINDING_1D
        || pname == GL_TEXTURE_BINDING_2D
#ifdef CR_NV_texture_rectangle
        || pname == GL_TEXTURE_BINDING_RECTANGLE_NV
#endif
#ifdef CR_ARB_texture_cube_map
        || pname == GL_TEXTURE_BINDING_CUBE_MAP_ARB
#endif
#ifdef CR_ARB_vertex_program
        || pname == GL_MAX_VERTEX_ATTRIBS_ARB
#endif
#ifdef GL_EXT_framebuffer_object
        || pname == GL_FRAMEBUFFER_BINDING_EXT
        || pname == GL_READ_FRAMEBUFFER_BINDING_EXT
        || pname == GL_DRAW_FRAMEBUFFER_BINDING_EXT
#endif
        || pname == GL_ARRAY_BUFFER_BINDING
        || pname == GL_ELEMENT_ARRAY_BUFFER_BINDING
        || pname == GL_PIXEL_PACK_BUFFER_BINDING
        || pname == GL_PIXEL_UNPACK_BUFFER_BINDING
        )
        {
#ifdef DEBUG
            if (!crPackIsPixelStoreParm(pname)
#ifdef CR_ARB_vertex_program
                && (pname!=GL_MAX_VERTEX_ATTRIBS_ARB)
#endif
               )
            {
                GLint * localparams;
                localparams = (GLint *) crAlloc(__numValues(pname) * sizeof(*localparams));
                crStateGetIntegerv(pname, localparams);
                crPackGetIntegerv(pname, params, &writeback);
                packspuFlush( (void *) thread );
                CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
                for (i=0; i<__numValues(pname); ++i)
                {
                    if (localparams[i] != params[i])
                    {
                        crWarning("Incorrect local state in GetIntegerv for %x param %i", pname, i);
                        crWarning("Expected %i but got %i", (int)localparams[i], (int)params[i]);
                    }
                }
                crFree(localparams);
                return;
            }
            else
#endif
            {
                crStateGetIntegerv(pname, params);
                return;
            }

        }
            
	if (pack_spu.swap)
	{
		crPackGetIntegervSWAP(pname, params, &writeback);
	}
	else
	{
		crPackGetIntegerv(pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < __numValues(pname); i++)
		{
			((GLuint *) params)[i] = SWAP32(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetLightfv(GLenum light, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetLightfv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetLightfvSWAP(light, pname, params, &writeback);
	}
	else
	{
		crPackGetLightfv(light, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			((GLuint *) params)[i] = SWAPFLOAT(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetLightiv(GLenum light, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetLightiv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetLightivSWAP(light, pname, params, &writeback);
	}
	else
	{
		crPackGetLightiv(light, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			((GLuint *) params)[i] = SWAP32(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetMapdv(GLenum target, GLenum query, GLdouble * v)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetMapdv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetMapdvSWAP(target, query, v, &writeback);
	}
	else
	{
		crPackGetMapdv(target, query, v, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetMapfv(GLenum target, GLenum query, GLfloat * v)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetMapfv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetMapfvSWAP(target, query, v, &writeback);
	}
	else
	{
		crPackGetMapfv(target, query, v, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetMapiv(GLenum target, GLenum query, GLint * v)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetMapiv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetMapivSWAP(target, query, v, &writeback);
	}
	else
	{
		crPackGetMapiv(target, query, v, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetMaterialfv(GLenum face, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetMaterialfv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetMaterialfvSWAP(face, pname, params, &writeback);
	}
	else
	{
		crPackGetMaterialfv(face, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			((GLuint *) params)[i] = SWAPFLOAT(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetMaterialiv(GLenum face, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetMaterialiv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetMaterialivSWAP(face, pname, params, &writeback);
	}
	else
	{
		crPackGetMaterialiv(face, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			((GLuint *) params)[i] = SWAP32(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetObjectParameterfvARB(VBoxGLhandleARB obj, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetObjectParameterfvARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetObjectParameterfvARBSWAP(obj, pname, params, &writeback);
	}
	else
	{
		crPackGetObjectParameterfvARB(obj, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetObjectParameterivARB(VBoxGLhandleARB obj, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetObjectParameterivARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetObjectParameterivARBSWAP(obj, pname, params, &writeback);
	}
	else
	{
		crPackGetObjectParameterivARB(obj, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramEnvParameterdvARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramEnvParameterdvARBSWAP(target, index, params, &writeback);
	}
	else
	{
		crPackGetProgramEnvParameterdvARB(target, index, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramEnvParameterfvARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramEnvParameterfvARBSWAP(target, index, params, &writeback);
	}
	else
	{
		crPackGetProgramEnvParameterfvARB(target, index, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramLocalParameterdvARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramLocalParameterdvARBSWAP(target, index, params, &writeback);
	}
	else
	{
		crPackGetProgramLocalParameterdvARB(target, index, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramLocalParameterfvARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramLocalParameterfvARBSWAP(target, index, params, &writeback);
	}
	else
	{
		crPackGetProgramLocalParameterfvARB(target, index, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte * name, GLdouble * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramNamedParameterdvNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramNamedParameterdvNVSWAP(id, len, name, params, &writeback);
	}
	else
	{
		crPackGetProgramNamedParameterdvNV(id, len, name, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte * name, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramNamedParameterfvNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramNamedParameterfvNVSWAP(id, len, name, params, &writeback);
	}
	else
	{
		crPackGetProgramNamedParameterfvNV(id, len, name, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramParameterdvNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramParameterdvNVSWAP(target, index, pname, params, &writeback);
	}
	else
	{
		crPackGetProgramParameterdvNV(target, index, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramParameterfvNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramParameterfvNVSWAP(target, index, pname, params, &writeback);
	}
	else
	{
		crPackGetProgramParameterfvNV(target, index, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramStringARB(GLenum target, GLenum pname, GLvoid * string)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramStringARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramStringARBSWAP(target, pname, string, &writeback);
	}
	else
	{
		crPackGetProgramStringARB(target, pname, string, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramStringNV(GLuint id, GLenum pname, GLubyte * program)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramStringNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramStringNVSWAP(id, pname, program, &writeback);
	}
	else
	{
		crPackGetProgramStringNV(id, pname, program, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramiv(GLuint program, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramiv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramivSWAP(program, pname, params, &writeback);
	}
	else
	{
		crPackGetProgramiv(program, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramivARB(GLenum target, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramivARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramivARBSWAP(target, pname, params, &writeback);
	}
	else
	{
		crPackGetProgramivARB(target, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetProgramivNV(GLuint id, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetProgramivNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetProgramivNVSWAP(id, pname, params, &writeback);
	}
	else
	{
		crPackGetProgramivNV(id, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetQueryObjectivARB(GLuint id, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetQueryObjectivARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetQueryObjectivARBSWAP(id, pname, params, &writeback);
	}
	else
	{
		crPackGetQueryObjectivARB(id, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetQueryObjectuivARB(GLuint id, GLenum pname, GLuint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetQueryObjectuivARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetQueryObjectuivARBSWAP(id, pname, params, &writeback);
	}
	else
	{
		crPackGetQueryObjectuivARB(id, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetQueryivARB(GLenum target, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetQueryivARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetQueryivARBSWAP(target, pname, params, &writeback);
	}
	else
	{
		crPackGetQueryivARB(target, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetRenderbufferParameterivEXT doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetRenderbufferParameterivEXTSWAP(target, pname, params, &writeback);
	}
	else
	{
		crPackGetRenderbufferParameterivEXT(target, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetShaderiv(GLuint shader, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetShaderiv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetShaderivSWAP(shader, pname, params, &writeback);
	}
	else
	{
		crPackGetShaderiv(shader, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetTexEnvfv(GLenum target, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetTexEnvfv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetTexEnvfvSWAP(target, pname, params, &writeback);
	}
	else
	{
		crPackGetTexEnvfv(target, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			((GLuint *) params)[i] = SWAPFLOAT(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetTexEnviv(GLenum target, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetTexEnviv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetTexEnvivSWAP(target, pname, params, &writeback);
	}
	else
	{
		crPackGetTexEnviv(target, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			((GLuint *) params)[i] = SWAP32(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetTexGendv(GLenum coord, GLenum pname, GLdouble * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetTexGendv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetTexGendvSWAP(coord, pname, params, &writeback);
	}
	else
	{
		crPackGetTexGendv(coord, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			params[i] = SWAPDOUBLE(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetTexGenfv(GLenum coord, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetTexGenfv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetTexGenfvSWAP(coord, pname, params, &writeback);
	}
	else
	{
		crPackGetTexGenfv(coord, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			((GLuint *) params)[i] = SWAPFLOAT(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetTexGeniv(GLenum coord, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetTexGeniv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetTexGenivSWAP(coord, pname, params, &writeback);
	}
	else
	{
		crPackGetTexGeniv(coord, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			((GLuint *) params)[i] = SWAP32(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetTexLevelParameterfv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetTexLevelParameterfvSWAP(target, level, pname, params, &writeback);
	}
	else
	{
		crPackGetTexLevelParameterfv(target, level, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			((GLuint *) params)[i] = SWAPFLOAT(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetTexLevelParameteriv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetTexLevelParameterivSWAP(target, level, pname, params, &writeback);
	}
	else
	{
		crPackGetTexLevelParameteriv(target, level, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			((GLuint *) params)[i] = SWAP32(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetTexParameterfv(GLenum target, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetTexParameterfv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetTexParameterfvSWAP(target, pname, params, &writeback);
	}
	else
	{
		crPackGetTexParameterfv(target, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			((GLuint *) params)[i] = SWAPFLOAT(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetTexParameteriv(GLenum target, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	unsigned int i;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetTexParameteriv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetTexParameterivSWAP(target, pname, params, &writeback);
	}
	else
	{
		crPackGetTexParameteriv(target, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		for (i = 0; i < crStateHlpComponentsCount(pname); i++)
		{
			((GLuint *) params)[i] = SWAP32(params[i]);
		}
	}
}

void PACKSPU_APIENTRY packspu_GetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetTrackMatrixivNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetTrackMatrixivNVSWAP(target, address, pname, params, &writeback);
	}
	else
	{
		crPackGetTrackMatrixivNV(target, address, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetUniformfv(GLuint program, GLint location, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetUniformfv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetUniformfvSWAP(program, location, params, &writeback);
	}
	else
	{
		crPackGetUniformfv(program, location, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetUniformiv(GLuint program, GLint location, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetUniformiv doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetUniformivSWAP(program, location, params, &writeback);
	}
	else
	{
		crPackGetUniformiv(program, location, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid ** pointer)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetVertexAttribPointervARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetVertexAttribPointervARBSWAP(index, pname, pointer, &writeback);
	}
	else
	{
		crPackGetVertexAttribPointervARB(index, pname, pointer, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid ** pointer)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetVertexAttribPointervNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetVertexAttribPointervNVSWAP(index, pname, pointer, &writeback);
	}
	else
	{
		crPackGetVertexAttribPointervNV(index, pname, pointer, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetVertexAttribdvARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetVertexAttribdvARBSWAP(index, pname, params, &writeback);
	}
	else
	{
		crPackGetVertexAttribdvARB(index, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetVertexAttribdvNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetVertexAttribdvNVSWAP(index, pname, params, &writeback);
	}
	else
	{
		crPackGetVertexAttribdvNV(index, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetVertexAttribfvARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetVertexAttribfvARBSWAP(index, pname, params, &writeback);
	}
	else
	{
		crPackGetVertexAttribfvARB(index, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetVertexAttribfvNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetVertexAttribfvNVSWAP(index, pname, params, &writeback);
	}
	else
	{
		crPackGetVertexAttribfvNV(index, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetVertexAttribivARB(GLuint index, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetVertexAttribivARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetVertexAttribivARBSWAP(index, pname, params, &writeback);
	}
	else
	{
		crPackGetVertexAttribivARB(index, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

void PACKSPU_APIENTRY packspu_GetVertexAttribivNV(GLuint index, GLenum pname, GLint * params)
{
	GET_THREAD(thread);
	int writeback = 1;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_GetVertexAttribivNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackGetVertexAttribivNVSWAP(index, pname, params, &writeback);
	}
	else
	{
		crPackGetVertexAttribivNV(index, pname, params, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
}

GLboolean PACKSPU_APIENTRY packspu_IsBufferARB(GLuint buffer)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_IsBufferARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackIsBufferARBSWAP(buffer, &return_val, &writeback);
	}
	else
	{
		crPackIsBufferARB(buffer, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

GLboolean PACKSPU_APIENTRY packspu_IsFenceNV(GLuint fence)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_IsFenceNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackIsFenceNVSWAP(fence, &return_val, &writeback);
	}
	else
	{
		crPackIsFenceNV(fence, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

GLboolean PACKSPU_APIENTRY packspu_IsFramebufferEXT(GLuint framebuffer)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_IsFramebufferEXT doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackIsFramebufferEXTSWAP(framebuffer, &return_val, &writeback);
	}
	else
	{
		crPackIsFramebufferEXT(framebuffer, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

GLboolean PACKSPU_APIENTRY packspu_IsList(GLuint list)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_IsList doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackIsListSWAP(list, &return_val, &writeback);
	}
	else
	{
		crPackIsList(list, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

GLboolean PACKSPU_APIENTRY packspu_IsProgram(GLuint program)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_IsProgram doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackIsProgramSWAP(program, &return_val, &writeback);
	}
	else
	{
		crPackIsProgram(program, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

GLboolean PACKSPU_APIENTRY packspu_IsProgramARB(GLuint program)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_IsProgramARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackIsProgramARBSWAP(program, &return_val, &writeback);
	}
	else
	{
		crPackIsProgramARB(program, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

GLboolean PACKSPU_APIENTRY packspu_IsQueryARB(GLuint id)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_IsQueryARB doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackIsQueryARBSWAP(id, &return_val, &writeback);
	}
	else
	{
		crPackIsQueryARB(id, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

GLboolean PACKSPU_APIENTRY packspu_IsRenderbufferEXT(GLuint renderbuffer)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_IsRenderbufferEXT doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackIsRenderbufferEXTSWAP(renderbuffer, &return_val, &writeback);
	}
	else
	{
		crPackIsRenderbufferEXT(renderbuffer, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

GLboolean PACKSPU_APIENTRY packspu_IsShader(GLuint shader)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_IsShader doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackIsShaderSWAP(shader, &return_val, &writeback);
	}
	else
	{
		crPackIsShader(shader, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

GLboolean PACKSPU_APIENTRY packspu_IsTexture(GLuint texture)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_IsTexture doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackIsTextureSWAP(texture, &return_val, &writeback);
	}
	else
	{
		crPackIsTexture(texture, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

GLint PACKSPU_APIENTRY packspu_RenderMode(GLenum mode)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLint return_val = (GLint) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_RenderMode doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackRenderModeSWAP(mode, &return_val, &writeback);
	}
	else
	{
		crPackRenderMode(mode, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLint) SWAP32(return_val);
	}
	return return_val;
}

GLboolean PACKSPU_APIENTRY packspu_TestFenceNV(GLuint fence)
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	if (!CRPACKSPU_IS_WDDM_CRHGSMI() && !(pack_spu.thread[pack_spu.idxThreadInUse].netServer.conn->actual_network))
	{
		crError( "packspu_TestFenceNV doesn't work when there's no actual network involved!\nTry using the simplequery SPU in your chain!" );
	}
	if (pack_spu.swap)
	{
		crPackTestFenceNVSWAP(fence, &return_val, &writeback);
	}
	else
	{
		crPackTestFenceNV(fence, &return_val, &writeback);
	}
	packspuFlush( (void *) thread );
	CRPACKSPU_WRITEBACK_WAIT(thread, writeback);
	if (pack_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

