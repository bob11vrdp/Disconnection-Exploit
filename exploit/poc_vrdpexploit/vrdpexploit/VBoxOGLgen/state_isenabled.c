/* Copyright (c) 2001, Stanford University
	All rights reserved.

	See the file LICENSE.txt for information on redistributing this software. */
	

/* DO NOT EDIT - THIS FILE GENERATED BY THE state_isenabled.py SCRIPT */
#include <stdio.h>
#include <math.h>

#include "state.h"
#include "state/cr_statetypes.h"

GLboolean STATE_APIENTRY crStateIsEnabled( GLenum pname )
{
	CRContext *g = GetCurrentContext();

	if (g->current.inBeginEnd)
	{
		crStateError(__LINE__, __FILE__, GL_INVALID_OPERATION, "glGet called in Begin/End");
		return 0;
	}

    switch (pname) {

	case GL_ALPHA_TEST:
		return g->buffer.alphaTest;
	case GL_AUTO_NORMAL:
		return g->eval.autoNormal;
	case GL_BLEND:
		return g->buffer.blend;
	case GL_CLIP_PLANE0:
		return g->transform.clip[0];
	case GL_CLIP_PLANE1:
		return g->transform.clip[1];
	case GL_CLIP_PLANE2:
		return g->transform.clip[2];
	case GL_CLIP_PLANE3:
		return g->transform.clip[3];
	case GL_CLIP_PLANE4:
		return g->transform.clip[4];
	case GL_CLIP_PLANE5:
		return g->transform.clip[5];
	case GL_COLOR_LOGIC_OP:
		return g->buffer.logicOp;
	case GL_COLOR_MATERIAL:
		return GL_FALSE;
	case GL_COLOR_SUM_EXT:
		return g->lighting.colorSumEXT;
	case GL_CULL_FACE:
		return g->polygon.cullFace;
	case GL_DEPTH_TEST:
		return g->buffer.depthTest;
	case GL_DEPTH_WRITEMASK:
		return g->buffer.depthMask;
	case GL_DITHER:
		return g->buffer.dither;
	case GL_FOG:
		return g->fog.enable;
	case GL_INDEX_LOGIC_OP:
		return g->buffer.indexLogicOp;
	case GL_LIGHT0:
		return g->lighting.light[0].enable;
	case GL_LIGHT1:
		return g->lighting.light[1].enable;
	case GL_LIGHT2:
		return g->lighting.light[2].enable;
	case GL_LIGHT3:
		return g->lighting.light[3].enable;
	case GL_LIGHT4:
		return g->lighting.light[4].enable;
	case GL_LIGHT5:
		return g->lighting.light[5].enable;
	case GL_LIGHT6:
		return g->lighting.light[6].enable;
	case GL_LIGHT7:
		return g->lighting.light[7].enable;
	case GL_LIGHTING:
		return g->lighting.lighting;
	case GL_LINE_SMOOTH:
		return g->line.lineSmooth;
	case GL_LINE_STIPPLE:
		return g->line.lineStipple;
	case GL_MAP1_COLOR_4:
		return g->eval.enable1D[GL_MAP1_COLOR_4-GL_MAP1_COLOR_4];
	case GL_MAP1_INDEX:
		return g->eval.enable1D[GL_MAP1_INDEX-GL_MAP1_COLOR_4];
	case GL_MAP1_NORMAL:
		return g->eval.enable1D[GL_MAP1_NORMAL-GL_MAP1_COLOR_4];
	case GL_MAP1_TEXTURE_COORD_1:
		return g->eval.enable1D[GL_MAP1_TEXTURE_COORD_1-GL_MAP1_COLOR_4];
	case GL_MAP1_TEXTURE_COORD_2:
		return g->eval.enable1D[GL_MAP1_TEXTURE_COORD_2-GL_MAP1_COLOR_4];
	case GL_MAP1_TEXTURE_COORD_3:
		return g->eval.enable1D[GL_MAP1_TEXTURE_COORD_3-GL_MAP1_COLOR_4];
	case GL_MAP1_TEXTURE_COORD_4:
		return g->eval.enable1D[GL_MAP1_TEXTURE_COORD_4-GL_MAP1_COLOR_4];
	case GL_MAP1_VERTEX_3:
		return g->eval.enable1D[GL_MAP1_VERTEX_3-GL_MAP1_COLOR_4];
	case GL_MAP1_VERTEX_4:
		return g->eval.enable1D[GL_MAP1_VERTEX_4-GL_MAP1_COLOR_4];
	case GL_MAP2_COLOR_4:
		return g->eval.enable2D[GL_MAP2_COLOR_4-GL_MAP2_COLOR_4];
	case GL_MAP2_INDEX:
		return g->eval.enable2D[GL_MAP2_INDEX-GL_MAP2_COLOR_4];
	case GL_MAP2_NORMAL:
		return g->eval.enable2D[GL_MAP2_NORMAL-GL_MAP2_COLOR_4];
	case GL_MAP2_TEXTURE_COORD_1:
		return g->eval.enable2D[GL_MAP2_TEXTURE_COORD_1-GL_MAP2_COLOR_4];
	case GL_MAP2_TEXTURE_COORD_2:
		return g->eval.enable2D[GL_MAP2_TEXTURE_COORD_2-GL_MAP2_COLOR_4];
	case GL_MAP2_TEXTURE_COORD_3:
		return g->eval.enable2D[GL_MAP2_TEXTURE_COORD_3-GL_MAP2_COLOR_4];
	case GL_MAP2_TEXTURE_COORD_4:
		return g->eval.enable2D[GL_MAP2_TEXTURE_COORD_4-GL_MAP2_COLOR_4];
	case GL_MAP2_VERTEX_3:
		return g->eval.enable2D[GL_MAP2_VERTEX_3-GL_MAP2_COLOR_4];
	case GL_MAP2_VERTEX_4:
		return g->eval.enable2D[GL_MAP2_VERTEX_4-GL_MAP2_COLOR_4];
	case GL_NORMALIZE:
		return g->transform.normalize;
	case GL_PACK_LSB_FIRST:
		return g->client.pack.psLSBFirst;
	case GL_PACK_SWAP_BYTES:
		return g->client.pack.swapBytes;
	case GL_PER_STAGE_CONSTANTS_NV:
		return g->regcombiner.enabledPerStageConstants;
	case GL_POINT_SMOOTH:
		return g->point.pointSmooth;
	case GL_POLYGON_OFFSET_FILL:
		return g->polygon.polygonOffsetFill;
	case GL_POLYGON_OFFSET_LINE:
		return g->polygon.polygonOffsetLine;
	case GL_POLYGON_OFFSET_POINT:
		return g->polygon.polygonOffsetPoint;
	case GL_POLYGON_SMOOTH:
		return g->polygon.polygonSmooth;
	case GL_POLYGON_STIPPLE:
		return g->polygon.polygonStipple;
	case GL_REGISTER_COMBINERS_NV:
		return g->regcombiner.enabledRegCombiners;
	case GL_RGBA_MODE:
		return GL_TRUE;
	case GL_SCISSOR_TEST:
		return g->viewport.scissorTest;
	case GL_STENCIL_TEST:
		return g->stencil.stencilTest;
	case GL_TEXTURE_1D:
		return g->texture.unit[g->texture.curTextureUnit].enabled1D;
	case GL_TEXTURE_2D:
		return g->texture.unit[g->texture.curTextureUnit].enabled2D;
	case GL_TEXTURE_CUBE_MAP_ARB:
		return g->texture.unit[g->texture.curTextureUnit].enabledCubeMap;
	case GL_TEXTURE_GEN_Q:
		return g->texture.unit[g->texture.curTextureUnit].textureGen.q;
	case GL_TEXTURE_GEN_R:
		return g->texture.unit[g->texture.curTextureUnit].textureGen.r;
	case GL_TEXTURE_GEN_S:
		return g->texture.unit[g->texture.curTextureUnit].textureGen.s;
	case GL_TEXTURE_GEN_T:
		return g->texture.unit[g->texture.curTextureUnit].textureGen.t;
	case GL_UNPACK_LSB_FIRST:
		return g->client.unpack.psLSBFirst;
	case GL_UNPACK_SWAP_BYTES:
		return g->client.unpack.swapBytes;
#ifdef CR_EXT_fog_coord
	case GL_FOG_COORDINATE_ARRAY_EXT:
		return g->client.array.f.enabled;
#endif /* CR_EXT_fog_coord */
#ifdef CR_ARB_fragment_program
	case GL_FRAGMENT_PROGRAM_ARB:
		return g->program.fpEnabledARB;
#endif /* CR_ARB_fragment_program */
#ifdef CR_NV_fragment_program
	case GL_FRAGMENT_PROGRAM_NV:
		return g->program.fpEnabled;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB0_4_NV:
		return g->eval.enableAttrib1D[0];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB10_4_NV:
		return g->eval.enableAttrib1D[10];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB11_4_NV:
		return g->eval.enableAttrib1D[11];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB12_4_NV:
		return g->eval.enableAttrib1D[12];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB13_4_NV:
		return g->eval.enableAttrib1D[13];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB14_4_NV:
		return g->eval.enableAttrib1D[14];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB15_4_NV:
		return g->eval.enableAttrib1D[15];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB1_4_NV:
		return g->eval.enableAttrib1D[1];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB2_4_NV:
		return g->eval.enableAttrib1D[2];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB3_4_NV:
		return g->eval.enableAttrib1D[3];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB4_4_NV:
		return g->eval.enableAttrib1D[4];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB5_4_NV:
		return g->eval.enableAttrib1D[5];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB6_4_NV:
		return g->eval.enableAttrib1D[6];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB7_4_NV:
		return g->eval.enableAttrib1D[7];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB8_4_NV:
		return g->eval.enableAttrib1D[8];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP1_VERTEX_ATTRIB9_4_NV:
		return g->eval.enableAttrib1D[9];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB0_4_NV:
		return g->eval.enableAttrib2D[0];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB10_4_NV:
		return g->eval.enableAttrib2D[10];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB11_4_NV:
		return g->eval.enableAttrib2D[11];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB12_4_NV:
		return g->eval.enableAttrib2D[12];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB13_4_NV:
		return g->eval.enableAttrib2D[13];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB14_4_NV:
		return g->eval.enableAttrib2D[14];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB15_4_NV:
		return g->eval.enableAttrib2D[15];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB1_4_NV:
		return g->eval.enableAttrib2D[1];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB2_4_NV:
		return g->eval.enableAttrib2D[2];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB3_4_NV:
		return g->eval.enableAttrib2D[3];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB4_4_NV:
		return g->eval.enableAttrib2D[4];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB5_4_NV:
		return g->eval.enableAttrib2D[5];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB6_4_NV:
		return g->eval.enableAttrib2D[6];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB7_4_NV:
		return g->eval.enableAttrib2D[7];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB8_4_NV:
		return g->eval.enableAttrib2D[8];
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_MAP2_VERTEX_ATTRIB9_4_NV:
		return g->eval.enableAttrib2D[9];
#endif /* CR_NV_vertex_program */
#ifdef CR_ARB_multisample
	case GL_MULTISAMPLE_ARB:
		return g->multisample.enabled;
#endif /* CR_ARB_multisample */
#ifdef CR_IBM_rasterpos_clip
	case GL_RASTER_POSITION_UNCLIPPED_IBM:
		return g->transform.rasterPositionUnclipped;
#endif /* CR_IBM_rasterpos_clip */
#ifdef CR_OPENGL_VERSION_1_2
	case GL_RESCALE_NORMAL:
		return g->transform.rescaleNormals;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_ARB_multisample
	case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
		return g->multisample.sampleAlphaToCoverage;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
	case GL_SAMPLE_ALPHA_TO_ONE_ARB:
		return g->multisample.sampleAlphaToOne;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
	case GL_SAMPLE_COVERAGE_ARB:
		return g->multisample.sampleCoverage;
#endif /* CR_ARB_multisample */
#ifdef CR_EXT_secondary_color
	case GL_SECONDARY_COLOR_ARRAY_EXT:
		return g->client.array.s.enabled;
#endif /* CR_EXT_secondary_color */
#ifdef CR_OPENGL_VERSION_1_2
	case GL_TEXTURE_3D:
		return g->texture.unit[g->texture.curTextureUnit].enabled3D;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_NV_texture_rectangle
	case GL_TEXTURE_RECTANGLE_NV:
		return g->texture.unit[g->texture.curTextureUnit].enabledRect;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY0_NV:
		return g->client.array.a[0].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY10_NV:
		return g->client.array.a[10].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY11_NV:
		return g->client.array.a[11].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY12_NV:
		return g->client.array.a[12].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY13_NV:
		return g->client.array.a[13].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY14_NV:
		return g->client.array.a[14].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY15_NV:
		return g->client.array.a[15].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY1_NV:
		return g->client.array.a[1].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY2_NV:
		return g->client.array.a[2].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY3_NV:
		return g->client.array.a[3].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY4_NV:
		return g->client.array.a[4].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY5_NV:
		return g->client.array.a[5].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY6_NV:
		return g->client.array.a[6].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY7_NV:
		return g->client.array.a[7].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY8_NV:
		return g->client.array.a[8].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_ATTRIB_ARRAY9_NV:
		return g->client.array.a[9].enabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_PROGRAM_NV:
		return g->program.vpEnabled;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
		return g->program.vpPointSize;
#endif /* CR_NV_vertex_program */
#ifdef CR_NV_vertex_program
	case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
		return g->program.vpTwoSide;
#endif /* CR_NV_vertex_program */
	default:
		crStateError(__LINE__, __FILE__, GL_INVALID_ENUM, "glIsEnabled: Unknown enum: %d", pname);
		return 0;
	}
}
