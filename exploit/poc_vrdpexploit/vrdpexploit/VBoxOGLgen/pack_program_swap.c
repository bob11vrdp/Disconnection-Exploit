/* THIS FILE IS AUTOGENERATED FROM E:/home/src/VirtualBox/src/VBox/GuestHost/OpenGL/packer/pack_program.c BY pack_swap.py */


/* Copyright (c) 2001, Stanford University
 * All rights reserved
 *
 * See the file LICENSE.txt for information on redistributing this software.
 */

/*
 * Packer functions for GL_NV_vertex_program extension.
 * XXX: Quite a few of these functions are unfinished.
 */


#include "packer.h"
#include "cr_error.h"


void PACK_APIENTRY crPackProgramParameters4dvNVSWAP(GLenum target, GLuint index, GLuint num, const GLdouble * params)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    int packet_length = sizeof(int) + sizeof(target) + sizeof(index) + sizeof(num) + num * 4 * sizeof(GLdouble);

    CR_GET_BUFFERED_POINTER(pc, packet_length);
    WRITE_DATA(0, int, SWAP32(packet_length));
    WRITE_DATA(sizeof(int) + 0, GLenum, SWAP32(target));
    WRITE_DATA(sizeof(int) + 4, GLuint, SWAP32(index));
    WRITE_DATA(sizeof(int) + 8, GLuint, SWAP32(num));
    crMemcpy(data_ptr + sizeof(int) + 12, params, num * 4 * sizeof(GLdouble));

    WRITE_OPCODE(pc, CR_PROGRAMPARAMETERS4DVNV_EXTEND_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}


void PACK_APIENTRY crPackProgramParameters4fvNVSWAP(GLenum target, GLuint index, GLuint num, const GLfloat * params)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    int packet_length = sizeof(int) + sizeof(target) + sizeof(index) + sizeof(num) + num * 4 * sizeof(GLfloat);

    CR_GET_BUFFERED_POINTER(pc, packet_length);
    WRITE_DATA(0, int, SWAP32(packet_length));
    WRITE_DATA(sizeof(int) + 0, GLenum, SWAP32(target));
    WRITE_DATA(sizeof(int) + 4, GLuint, SWAP32(index));
    WRITE_DATA(sizeof(int) + 8, GLuint, SWAP32(num));
    crMemcpy(data_ptr + sizeof(int) + 12, params, num * 4 * sizeof(GLfloat));

    WRITE_OPCODE(pc, CR_PROGRAMPARAMETERS4FVNV_EXTEND_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}


void PACK_APIENTRY crPackVertexAttribs1dvNVSWAP(GLuint index, GLsizei n, const GLdouble *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib1dvARBSWAP(index + i, v + i);
}


void PACK_APIENTRY crPackVertexAttribs1fvNVSWAP(GLuint index, GLsizei n, const GLfloat *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib1fvARBSWAP(index + i, v + i);
}


void PACK_APIENTRY crPackVertexAttribs1svNVSWAP(GLuint index, GLsizei n, const GLshort *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib1svARBSWAP(index + i, v + i);
}


void PACK_APIENTRY crPackVertexAttribs2dvNVSWAP(GLuint index, GLsizei n, const GLdouble *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib2dvARBSWAP(index + i, v + 2 * i);
}

void PACK_APIENTRY crPackVertexAttribs2fvNVSWAP(GLuint index, GLsizei n, const GLfloat *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib2fvARBSWAP(index + i, v + 2 * i);
}

void PACK_APIENTRY crPackVertexAttribs2svNVSWAP(GLuint index, GLsizei n, const GLshort *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib2svARBSWAP(index + i, v + 2 * i);
}

void PACK_APIENTRY crPackVertexAttribs3dvNVSWAP(GLuint index, GLsizei n, const GLdouble *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib3dvARBSWAP(index + i, v + 3 * i);
}

void PACK_APIENTRY crPackVertexAttribs3fvNVSWAP(GLuint index, GLsizei n, const GLfloat *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib3fvARBSWAP(index + i, v + 3 * i);
}

void PACK_APIENTRY crPackVertexAttribs3svNVSWAP(GLuint index, GLsizei n, const GLshort *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib3svARBSWAP(index + i, v + 3 * i);
}

void PACK_APIENTRY crPackVertexAttribs4dvNVSWAP(GLuint index, GLsizei n, const GLdouble *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib4dvARBSWAP(index + i, v + 4 * i);
}

void PACK_APIENTRY crPackVertexAttribs4fvNVSWAP(GLuint index, GLsizei n, const GLfloat *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib4fvARBSWAP(index + i, v + 4 * i);
}

void PACK_APIENTRY crPackVertexAttribs4svNVSWAP(GLuint index, GLsizei n, const GLshort *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib4svARBSWAP(index + i, v + 4 * i);
}

void PACK_APIENTRY crPackVertexAttribs4ubvNVSWAP(GLuint index, GLsizei n, const GLubyte *v)
{
    GLint i;
    /* reverse order so we hit index 0 last (provoking glVertex) */
    for (i = n - 1; i >= 0; i--)
        crPackVertexAttrib4ubvARBSWAP(index + i, v + 4 * i);
}


void PACK_APIENTRY crPackExecuteProgramNVSWAP(GLenum target, GLuint id, const GLfloat *params)
{
    const int packet_length = 32;
    unsigned char *data_ptr = NULL;
    CR_GET_PACKER_CONTEXT(pc);

    CR_GET_BUFFERED_POINTER(pc, packet_length);
    WRITE_DATA(0, int, SWAP32(packet_length));
    WRITE_DATA(4, GLenum, SWAP32(CR_EXECUTEPROGRAMNV_EXTEND_OPCODE));
    WRITE_DATA(8, GLenum, SWAP32(target));
    WRITE_DATA(12, GLuint, SWAP32(id));
    WRITE_DATA(16, GLuint, SWAPFLOAT(params[0]));
    WRITE_DATA(20, GLuint, SWAPFLOAT(params[1]));
    WRITE_DATA(24, GLuint, SWAPFLOAT(params[2]));
    WRITE_DATA(28, GLuint, SWAPFLOAT(params[3]));
    WRITE_OPCODE(pc, CR_EXTEND_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackLoadProgramNVSWAP(GLenum target, GLuint id, GLsizei len, const GLubyte *program)
{
    const int packet_length = 20 + len;
    unsigned char *data_ptr = NULL;
    CR_GET_PACKER_CONTEXT(pc);

    CR_GET_BUFFERED_POINTER(pc, packet_length);
    WRITE_DATA(0, int, SWAP32(packet_length));
    WRITE_DATA(4, GLenum, SWAP32(CR_LOADPROGRAMNV_EXTEND_OPCODE));
    WRITE_DATA(8, GLenum, SWAP32(target));
    WRITE_DATA(12, GLuint, SWAP32(id));
    WRITE_DATA(16, GLsizei, SWAP32(len));
    crMemcpy((void *) (data_ptr + 20), program, len);
    WRITE_OPCODE(pc, CR_EXTEND_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackRequestResidentProgramsNVSWAP(GLsizei n, const GLuint *ids)
{
    CR_GET_PACKER_CONTEXT(pc);
    (void) pc;
    (void) n;
    (void) ids;
    /* We're no-op'ing this function for now. */
}


void PACK_APIENTRY crPackProgramNamedParameter4fNVSWAP (GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    int packet_length = 32 + len;

    CR_GET_BUFFERED_POINTER(pc, packet_length);
    WRITE_DATA(0, GLint, SWAP32(packet_length));
    WRITE_DATA(4, GLenum, SWAP32(CR_PROGRAMNAMEDPARAMETER4FNV_EXTEND_OPCODE));
    WRITE_DATA(8, GLuint, SWAP32(id));
    WRITE_DATA(12, GLsizei, SWAP32(len));
    WRITE_DATA(16, GLuint, SWAPFLOAT(x));
    WRITE_DATA(20, GLuint, SWAPFLOAT(y));
    WRITE_DATA(24, GLuint, SWAPFLOAT(z));
    WRITE_DATA(28, GLuint, SWAPFLOAT(w));
    crMemcpy((void *) (data_ptr + 32), name, len);
    WRITE_OPCODE(pc, CR_EXTEND_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackProgramNamedParameter4dNVSWAP (GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    int packet_length = 48 + len;

    CR_GET_BUFFERED_POINTER(pc, packet_length);
    WRITE_DATA(0, GLint, SWAP32(packet_length));
    WRITE_DATA(4, GLenum, SWAP32(CR_PROGRAMNAMEDPARAMETER4DNV_EXTEND_OPCODE));
    WRITE_DATA(8, GLenum, SWAP32(id));
    WRITE_DATA(12, GLuint, SWAP32(len));
    WRITE_SWAPPED_DOUBLE(16, x);
    WRITE_SWAPPED_DOUBLE(24, y);
    WRITE_SWAPPED_DOUBLE(32, z);
    WRITE_SWAPPED_DOUBLE(40, w);
    crMemcpy((void *) (data_ptr + 48), name, len);

    WRITE_OPCODE(pc, CR_EXTEND_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackProgramNamedParameter4fvNVSWAP (GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v)
{
    crPackProgramNamedParameter4fNVSWAP(id, len, name, v[0], v[1], v[2], v[3]);
}

void PACK_APIENTRY crPackProgramNamedParameter4dvNVSWAP (GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v)
{
    crPackProgramNamedParameter4dNVSWAP(id, len, name, v[0], v[1], v[2], v[3]);
}


void PACK_APIENTRY
crPackAreProgramsResidentNVSWAP(GLsizei n, const GLuint * programs,
                                                        GLboolean *residences, GLboolean *return_val,
                                                        int *writeback)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    int packet_length;

    (void) return_val; /* Caller must compute this from residences!!! */

    packet_length = sizeof(int) +   /* packet length */
        sizeof(GLenum) +                        /* extend opcode */
        sizeof(n) +                                 /* num programs */
        n * sizeof(*programs) +         /* programs */
        8 + 8;

    CR_GET_BUFFERED_POINTER(pc, packet_length);
    WRITE_DATA(0, int, SWAP32(packet_length));
    WRITE_DATA(4, GLenum, SWAP32(CR_AREPROGRAMSRESIDENTNV_EXTEND_OPCODE));
    WRITE_DATA(8, GLsizei, SWAP32(n));
    crMemcpy(data_ptr + 12, programs, n * sizeof(*programs));
    WRITE_NETWORK_POINTER(12 + n * sizeof(*programs),   (void *) residences);
    WRITE_NETWORK_POINTER(20 + n * sizeof(*programs), (void *) writeback);
    WRITE_OPCODE(pc, CR_EXTEND_OPCODE);
    CR_CMDBLOCK_CHECK_FLUSH(pc);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}


void PACK_APIENTRY crPackGetProgramNamedParameterfvNVSWAP(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params, int *writeback)
{
    int packet_length = 32 + len;
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, packet_length);
    WRITE_DATA(0, GLint, SWAP32(packet_length));
    WRITE_DATA(4, GLenum, SWAP32(CR_GETPROGRAMNAMEDPARAMETERFVNV_EXTEND_OPCODE));
    WRITE_DATA(8, GLuint, SWAP32(id));
    WRITE_DATA(12, GLsizei, SWAP32(len));
    crMemcpy(data_ptr + 16, name, len);
    WRITE_NETWORK_POINTER(16 + len, (void *) params);
    WRITE_NETWORK_POINTER(16 + len + 8, (void *) writeback);
    WRITE_OPCODE(pc, CR_EXTEND_OPCODE);
    CR_CMDBLOCK_CHECK_FLUSH(pc);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackGetProgramNamedParameterdvNVSWAP(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params, int *writeback)
{
    int packet_length = 32 + len;
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, packet_length);
    WRITE_DATA(0, GLint, SWAP32(packet_length));
    WRITE_DATA(4, GLenum, SWAP32(CR_GETPROGRAMNAMEDPARAMETERDVNV_EXTEND_OPCODE));
    WRITE_DATA(8, GLuint, SWAP32(id));
    WRITE_DATA(12, GLsizei, SWAP32(len));
    crMemcpy(data_ptr + 16, name, len);
    WRITE_NETWORK_POINTER(16 + len, (void *) params);
    WRITE_NETWORK_POINTER(16 + len + 8, (void *) writeback);
    WRITE_OPCODE(pc, CR_EXTEND_OPCODE);
    CR_CMDBLOCK_CHECK_FLUSH(pc);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}


void PACK_APIENTRY crPackDeleteProgramsARBSWAP(GLsizei n, const GLuint *ids)
{
    unsigned char *data_ptr = NULL;
    int packet_length = sizeof(GLenum) + sizeof(n) + n * sizeof(*ids);

    if (!ids)
        return;

    data_ptr = (unsigned char *) crPackAlloc(packet_length);
    WRITE_DATA(0, GLenum, SWAP32(CR_DELETEPROGRAMSARB_EXTEND_OPCODE));
    WRITE_DATA(4, GLsizei, SWAP32(n));
    crMemcpy(data_ptr + 8, ids, n * sizeof(*ids));
    crHugePacket(CR_EXTEND_OPCODE, data_ptr);
    crPackFree(data_ptr);
}


void PACK_APIENTRY  crPackProgramStringARBSWAP(GLenum target, GLenum format, GLsizei len, const void *string)
{
    const int packet_length = 20 + len;
    unsigned char *data_ptr = NULL;
    CR_GET_PACKER_CONTEXT(pc);

    CR_GET_BUFFERED_POINTER(pc, packet_length);
    WRITE_DATA(0, int, SWAP32(packet_length));
    WRITE_DATA(4, GLenum, SWAP32(CR_PROGRAMSTRINGARB_EXTEND_OPCODE));
    WRITE_DATA(8, GLenum, SWAP32(target));
    WRITE_DATA(12, GLuint, SWAP32(format));
    WRITE_DATA(16, GLsizei, SWAP32(len));
    crMemcpy((void *) (data_ptr + 20), string, len);
    WRITE_OPCODE(pc, CR_EXTEND_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}


/*
 * Can't easily auto-generate these functions since there aren't
 * non-vector versions.
 */

void PACK_APIENTRY crPackVertexAttrib4NbvARBSWAP(GLuint index, const GLbyte *v)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, 8);
    pc->current.c.vertexAttrib.b4[index] = data_ptr + 4;
    pc->current.attribsUsedMask |= (1 << index);
    WRITE_DATA(0, GLuint, SWAP32(index));
    WRITE_DATA(4, GLbyte, v[0]);
    WRITE_DATA(5, GLbyte, v[1]);
    WRITE_DATA(6, GLbyte, v[2]);
    WRITE_DATA(7, GLbyte, v[3]);
    WRITE_OPCODE(pc, CR_VERTEXATTRIB4NBVARB_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackVertexAttrib4NivARBSWAP(GLuint index, const GLint *v)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, 20);
    pc->current.c.vertexAttrib.i4[index] = data_ptr + 4;
    pc->current.attribsUsedMask |= (1 << index);
    WRITE_DATA(0, GLuint, SWAP32(index));
    WRITE_DATA(4, GLint, SWAP32(v[0]));
    WRITE_DATA(8, GLint, SWAP32(v[1]));
    WRITE_DATA(12, GLint, SWAP32(v[2]));
    WRITE_DATA(16, GLint, SWAP32(v[3]));
    WRITE_OPCODE(pc, CR_VERTEXATTRIB4NIVARB_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackVertexAttrib4NsvARBSWAP(GLuint index, const GLshort *v)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, 12);
    pc->current.c.vertexAttrib.s4[index] = data_ptr + 4;
    pc->current.attribsUsedMask |= (1 << index);
    WRITE_DATA(0, GLuint, SWAP32(index));
    WRITE_DATA(4, GLshort, SWAP16(v[0]));
    WRITE_DATA(6, GLshort, SWAP16(v[1]));
    WRITE_DATA(8, GLshort, SWAP16(v[2]));
    WRITE_DATA(10, GLshort, SWAP16(v[3]));
    WRITE_OPCODE(pc, CR_VERTEXATTRIB4NSVARB_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackVertexAttrib4NubvARBSWAP(GLuint index, const GLubyte * v)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, 8);
    pc->current.c.vertexAttrib.ub4[index] = data_ptr + 4;
    pc->current.attribsUsedMask |= (1 << index);
    WRITE_DATA(0, GLuint, SWAP32(index));
    WRITE_DATA(4, GLubyte, v[0]);
    WRITE_DATA(5, GLubyte, v[1]);
    WRITE_DATA(6, GLubyte, v[2]);
    WRITE_DATA(7, GLubyte, v[3]);
    WRITE_OPCODE(pc, CR_VERTEXATTRIB4NUBVARB_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackVertexAttrib4NuivARBSWAP(GLuint index, const GLuint * v)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, 20);
    pc->current.c.vertexAttrib.ui4[index] = data_ptr + 4;
    pc->current.attribsUsedMask |= (1 << index);
    WRITE_DATA(0, GLuint, SWAP32(index));
    WRITE_DATA(4, GLuint, SWAP32(v[0]));
    WRITE_DATA(8, GLuint, SWAP32(v[1]));
    WRITE_DATA(12, GLuint, SWAP32(v[2]));
    WRITE_DATA(16, GLuint, SWAP32(v[3]));
    WRITE_OPCODE(pc, CR_VERTEXATTRIB4NUIVARB_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackVertexAttrib4NusvARBSWAP(GLuint index, const GLushort * v)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, 12);
    pc->current.c.vertexAttrib.s4[index] = data_ptr + 4;
    pc->current.attribsUsedMask |= (1 << index);
    WRITE_DATA(0, GLuint, SWAP32(index));
    WRITE_DATA(4, GLushort, SWAP16(v[0]));
    WRITE_DATA(6, GLushort, SWAP16(v[1]));
    WRITE_DATA(8, GLushort, SWAP16(v[2]));
    WRITE_DATA(10, GLushort, SWAP16(v[3]));
    WRITE_OPCODE(pc, CR_VERTEXATTRIB4NUSVARB_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackVertexAttrib4bvARBSWAP(GLuint index, const GLbyte * v)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, 8);
    pc->current.c.vertexAttrib.b4[index] = data_ptr + 4;
    pc->current.attribsUsedMask |= (1 << index);
    WRITE_DATA(0, GLuint, SWAP32(index));
    WRITE_DATA(4, GLbyte, v[0]);
    WRITE_DATA(5, GLbyte, v[1]);
    WRITE_DATA(6, GLbyte, v[2]);
    WRITE_DATA(7, GLbyte, v[3]);
    WRITE_OPCODE(pc, CR_VERTEXATTRIB4BVARB_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackVertexAttrib4ivARBSWAP(GLuint index, const GLint * v)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, 20);
    pc->current.c.vertexAttrib.i4[index] = data_ptr + 4;
    pc->current.attribsUsedMask |= (1 << index);
    WRITE_DATA(0, GLuint, SWAP32(index));
    WRITE_DATA(4, GLint, SWAP32(v[0]));
    WRITE_DATA(8, GLint, SWAP32(v[1]));
    WRITE_DATA(12, GLint, SWAP32(v[2]));
    WRITE_DATA(16, GLint, SWAP32(v[3]));
    WRITE_OPCODE(pc, CR_VERTEXATTRIB4IVARB_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackVertexAttrib4uivARBSWAP(GLuint index, const GLuint * v)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, 20);
    pc->current.c.vertexAttrib.ui4[index] = data_ptr + 4;
    pc->current.attribsUsedMask |= (1 << index);
    WRITE_DATA(0, GLuint, SWAP32(index));
    WRITE_DATA(4, GLuint, SWAP32(v[0]));
    WRITE_DATA(8, GLuint, SWAP32(v[1]));
    WRITE_DATA(12, GLuint, SWAP32(v[2]));
    WRITE_DATA(16, GLuint, SWAP32(v[3]));
    WRITE_OPCODE(pc, CR_VERTEXATTRIB4UIVARB_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackVertexAttrib4usvARBSWAP(GLuint index, const GLushort * v)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, 12);
    pc->current.c.vertexAttrib.s4[index] = data_ptr + 4;
    pc->current.attribsUsedMask |= (1 << index);
    WRITE_DATA(0, GLuint, SWAP32(index));
    WRITE_DATA(4, GLushort, SWAP16(v[0]));
    WRITE_DATA(6, GLushort, SWAP16(v[1]));
    WRITE_DATA(8, GLushort, SWAP16(v[2]));
    WRITE_DATA(10, GLushort, SWAP16(v[3]));
    WRITE_OPCODE(pc, CR_VERTEXATTRIB4USVARB_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}


void PACK_APIENTRY crPackVertexAttrib4ubvARBSWAP(GLuint index, const GLubyte * v)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr = NULL;
    CR_GET_BUFFERED_POINTER(pc, 8);
    pc->current.c.vertexAttrib.ub4[index] = data_ptr + 4;
    pc->current.attribsUsedMask |= (1 << index);
    WRITE_DATA(0, GLuint, SWAP32(index));
    WRITE_DATA(4, GLubyte, v[0]);
    WRITE_DATA(5, GLubyte, v[1]);
    WRITE_DATA(6, GLubyte, v[2]);
    WRITE_DATA(7, GLubyte, v[3]);
    WRITE_OPCODE(pc, CR_VERTEXATTRIB4UBVARB_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

