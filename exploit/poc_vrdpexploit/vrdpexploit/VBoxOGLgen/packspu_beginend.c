/* Copyright (c) 2001, Stanford University
	All rights reserved.

	See the file LICENSE.txt for information on redistributing this software. */
	
/* DO NOT EDIT - AUTOMATICALLY GENERATED BY packspu_beginend.py */
#include "packspu.h"
#include "assert.h"
#include "cr_packfunctions.h"
#include "packspu_proto.h"

void PACKSPU_APIENTRY packspu_Begin( GLenum mode )
{
    CRPackBuffer *buf;
#if CR_ARB_vertex_buffer_object
    GET_CONTEXT(ctx);
#else
    GET_THREAD(thread);
#endif

    buf = &thread->BeginEndBuffer;

    /* XXX comparing mode >= 0 here is not needed since mode is unsigned */
    CRASSERT( /*mode >= GL_POINTS && */mode <= GL_POLYGON );

#if CR_ARB_vertex_buffer_object
    {
        GLboolean serverArrays = GL_FALSE;
        if (ctx->clientState->extensions.ARB_vertex_buffer_object)
            serverArrays = crStateUseServerArrays();
        if (serverArrays) {
            CRClientState *clientState = &(ctx->clientState->client);
            if (clientState->array.locked && !clientState->array.synced)
            {
                crPackLockArraysEXT(clientState->array.lockFirst, clientState->array.lockCount);
                clientState->array.synced = GL_TRUE;
            }
        }
    }
#endif

    if (pack_spu.swap)
    {
        crPackBeginSWAP( mode );
    }
    else
    {
        crPackBegin( mode );
    }

    if ( thread->netServer.conn->Barf ) {
        thread->BeginEndMode = mode;
        thread->BeginEndState = -1;
        if ( mode == GL_LINES || mode == GL_TRIANGLES || mode == GL_QUADS || mode == GL_POLYGON )
        {
            CRASSERT(!buf->pack);

            crPackReleaseBuffer( thread->packer );
            buf->pack = crNetAlloc( thread->netServer.conn );
            crPackInitBuffer( buf, buf->pack, thread->netServer.conn->buffer_size, thread->netServer.conn->mtu );
            buf->holds_BeginEnd = 1;
            buf->in_BeginEnd = 1;
            crPackSetBuffer( thread->packer, buf );

            thread->BeginEndState = 0;
        }
    }
}

void PACKSPU_APIENTRY packspu_End( void )
{
    GET_THREAD(thread);
    CRPackBuffer *buf = &thread->BeginEndBuffer;

    if ( thread->netServer.conn->Barf &&
        (thread->BeginEndMode == GL_LINES
        || thread->BeginEndMode == GL_TRIANGLES
        || thread->BeginEndMode == GL_QUADS
        || thread->BeginEndMode == GL_POLYGON ) )
    {
        CRASSERT(buf->pack);

        crPackReleaseBuffer( thread->packer );
        crPackSetBuffer( thread->packer, &thread->normBuffer );
        if ( !crPackCanHoldBuffer( buf ) )
            packspuFlush( (void *) thread );

        crPackAppendBuffer( buf );
        crNetFree( thread->netServer.conn, buf->pack );
        buf->pack = NULL;
    }

    if (pack_spu.swap)
    {
        crPackEndSWAP();
    }
    else
    {
        crPackEnd();
    }
}

static void DoVertex( void )
{
    GET_THREAD(thread);
    CRPackBuffer *buf = &thread->BeginEndBuffer;
    CRPackBuffer *gbuf = &thread->normBuffer;
    int num_data;
    int num_opcode;

    /*crDebug( "really doing Vertex" );*/
    crPackReleaseBuffer( thread->packer );
    num_data = buf->data_current - buf->data_start;
    num_opcode = buf->opcode_start - buf->opcode_current;
    crPackSetBuffer( thread->packer, gbuf );
    if ( !crPackCanHoldBuffer( buf ) )
        /* doesn't hold, first flush gbuf*/
        packspuFlush( (void *) thread );

    crPackAppendBuffer( buf );
    crPackReleaseBuffer( thread->packer );
    crPackSetBuffer( thread->packer, buf );
    crPackResetPointers(thread->packer);
}

static void RunState( void )
{
    GET_THREAD(thread);
    if (! thread->netServer.conn->Barf ) return;
    if (thread->BeginEndState == -1) return;
    switch(thread->BeginEndMode) {
    case GL_POLYGON:
        return;
    case GL_LINES:
        thread->BeginEndState = (thread->BeginEndState + 1) % 2;
        if (thread->BeginEndState)
            return;
        break;
    case GL_TRIANGLES:
        thread->BeginEndState = (thread->BeginEndState + 1) % 3;
        if (thread->BeginEndState)
            return;
        break;
    case GL_QUADS:
        thread->BeginEndState = (thread->BeginEndState + 1) % 4;
        if (thread->BeginEndState)
            return;
        break;
    }
    DoVertex();
}

void PACKSPU_APIENTRY packspu_Vertex2d(GLdouble x, GLdouble y)
{
	if (pack_spu.swap)
	{
		crPackVertex2dSWAP(x, y);
	}
	else
	{
		crPackVertex2d(x, y);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex2dv(const GLdouble * v)
{
	if (pack_spu.swap)
	{
		crPackVertex2dvSWAP(v);
	}
	else
	{
		crPackVertex2dv(v);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex2f(GLfloat x, GLfloat y)
{
	if (pack_spu.swap)
	{
		crPackVertex2fSWAP(x, y);
	}
	else
	{
		crPackVertex2f(x, y);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex2fv(const GLfloat * v)
{
	if (pack_spu.swap)
	{
		crPackVertex2fvSWAP(v);
	}
	else
	{
		crPackVertex2fv(v);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex2i(GLint x, GLint y)
{
	if (pack_spu.swap)
	{
		crPackVertex2iSWAP(x, y);
	}
	else
	{
		crPackVertex2i(x, y);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex2iv(const GLint * v)
{
	if (pack_spu.swap)
	{
		crPackVertex2ivSWAP(v);
	}
	else
	{
		crPackVertex2iv(v);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex2s(GLshort x, GLshort y)
{
	if (pack_spu.swap)
	{
		crPackVertex2sSWAP(x, y);
	}
	else
	{
		crPackVertex2s(x, y);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex2sv(const GLshort * v)
{
	if (pack_spu.swap)
	{
		crPackVertex2svSWAP(v);
	}
	else
	{
		crPackVertex2sv(v);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex3d(GLdouble x, GLdouble y, GLdouble z)
{
	if (pack_spu.swap)
	{
		crPackVertex3dSWAP(x, y, z);
	}
	else
	{
		crPackVertex3d(x, y, z);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex3dv(const GLdouble * v)
{
	if (pack_spu.swap)
	{
		crPackVertex3dvSWAP(v);
	}
	else
	{
		crPackVertex3dv(v);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex3f(GLfloat x, GLfloat y, GLfloat z)
{
	if (pack_spu.swap)
	{
		crPackVertex3fSWAP(x, y, z);
	}
	else
	{
		crPackVertex3f(x, y, z);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex3fv(const GLfloat * v)
{
	if (pack_spu.swap)
	{
		crPackVertex3fvSWAP(v);
	}
	else
	{
		crPackVertex3fv(v);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex3i(GLint x, GLint y, GLint z)
{
	if (pack_spu.swap)
	{
		crPackVertex3iSWAP(x, y, z);
	}
	else
	{
		crPackVertex3i(x, y, z);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex3iv(const GLint * v)
{
	if (pack_spu.swap)
	{
		crPackVertex3ivSWAP(v);
	}
	else
	{
		crPackVertex3iv(v);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex3s(GLshort x, GLshort y, GLshort z)
{
	if (pack_spu.swap)
	{
		crPackVertex3sSWAP(x, y, z);
	}
	else
	{
		crPackVertex3s(x, y, z);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex3sv(const GLshort * v)
{
	if (pack_spu.swap)
	{
		crPackVertex3svSWAP(v);
	}
	else
	{
		crPackVertex3sv(v);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	if (pack_spu.swap)
	{
		crPackVertex4dSWAP(x, y, z, w);
	}
	else
	{
		crPackVertex4d(x, y, z, w);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex4dv(const GLdouble * v)
{
	if (pack_spu.swap)
	{
		crPackVertex4dvSWAP(v);
	}
	else
	{
		crPackVertex4dv(v);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	if (pack_spu.swap)
	{
		crPackVertex4fSWAP(x, y, z, w);
	}
	else
	{
		crPackVertex4f(x, y, z, w);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex4fv(const GLfloat * v)
{
	if (pack_spu.swap)
	{
		crPackVertex4fvSWAP(v);
	}
	else
	{
		crPackVertex4fv(v);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex4i(GLint x, GLint y, GLint z, GLint w)
{
	if (pack_spu.swap)
	{
		crPackVertex4iSWAP(x, y, z, w);
	}
	else
	{
		crPackVertex4i(x, y, z, w);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex4iv(const GLint * v)
{
	if (pack_spu.swap)
	{
		crPackVertex4ivSWAP(v);
	}
	else
	{
		crPackVertex4iv(v);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
	if (pack_spu.swap)
	{
		crPackVertex4sSWAP(x, y, z, w);
	}
	else
	{
		crPackVertex4s(x, y, z, w);
	}
	RunState();
}
void PACKSPU_APIENTRY packspu_Vertex4sv(const GLshort * v)
{
	if (pack_spu.swap)
	{
		crPackVertex4svSWAP(v);
	}
	else
	{
		crPackVertex4sv(v);
	}
	RunState();
}
