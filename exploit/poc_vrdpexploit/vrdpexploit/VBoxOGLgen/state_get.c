/* Copyright (c) 2001, Stanford University
	All rights reserved.

	See the file LICENSE.txt for information on redistributing this software. */
	

/* DO NOT EDIT - THIS FILE GENERATED BY state_get.txt AND THE state_get.py SCRIPT */
#include <stdio.h>
#include <math.h>

#include "state.h"
#include "state/cr_statetypes.h"

static GLint __clampd_to_int(GLdouble d)
{
	/* -1.0 -> MIN_INT, 1.0 -> MAX_INT */
	if (d > 1.0)
		return 0x7fffffff;
	if (d < -1.0)
		return 0x80000000;
	return (GLint) floor(d * 2147483647.5);
}

static GLint __clampf_to_int(GLfloat f)
{
	/* -1.0f -> MIN_INT, 1.0f -> MAX_INT */
	if (f > 1.0f)
		return 0x7fffffff;
	if (f < -1.0f)
		return 0x80000000;
	return (GLint) floor(f * 2147483647.5f);
}

static GLenum __getDrawBuffer(CRContext *g)
{
    return g->framebufferobject.drawFB ? g->framebufferobject.drawFB->drawbuffer[0] : g->buffer.drawBuffer;
}

static GLenum __getReadBuffer(CRContext *g)
{
    return g->framebufferobject.readFB ? g->framebufferobject.readFB->readbuffer : g->buffer.readBuffer;
}


void STATE_APIENTRY crStateGetBooleanv( GLenum pname, GLboolean *params )

{
	CRContext *g = GetCurrentContext();

	if (g->current.inBeginEnd)
	{
		crStateError(__LINE__, __FILE__, GL_INVALID_OPERATION,
			"glGet called in Begin/End");
		return;
	}

	if (pname == GL_CURRENT_INDEX || pname == GL_CURRENT_COLOR ||
		pname == GL_CURRENT_SECONDARY_COLOR_EXT ||
		pname == GL_CURRENT_FOG_COORDINATE_EXT ||
		pname == GL_CURRENT_NORMAL || pname == GL_EDGE_FLAG ||
		pname == GL_CURRENT_TEXTURE_COORDS )
	{
#if 0
		crStateError(__LINE__,__FILE__, GL_INVALID_OPERATION,
			"Unimplemented glGet of a 'current' value" );
#else
		crStateCurrentRecover();/* &g->current, &sb->current, g->bitID );*/
		
#endif
	}

	switch (pname) {

		case GL_ACCUM_ALPHA_BITS:
			params[0] = (GLboolean) (g->limits.accumAlphaBits != 0);
			break;
		case GL_ACCUM_BLUE_BITS:
			params[0] = (GLboolean) (g->limits.accumBlueBits != 0);
			break;
		case GL_ACCUM_CLEAR_VALUE:
			params[0] = (GLboolean) (g->buffer.accumClearValue.r != 0.0f);
			params[1] = (GLboolean) (g->buffer.accumClearValue.g != 0.0f);
			params[2] = (GLboolean) (g->buffer.accumClearValue.b != 0.0f);
			params[3] = (GLboolean) (g->buffer.accumClearValue.a != 0.0f);
			break;
		case GL_ACCUM_GREEN_BITS:
			params[0] = (GLboolean) (g->limits.accumGreenBits != 0);
			break;
		case GL_ACCUM_RED_BITS:
			params[0] = (GLboolean) (g->limits.accumRedBits != 0);
			break;
		case GL_ACTIVE_STENCIL_FACE_EXT:
			params[0] = (GLboolean) (g->stencil.activeStencilFace != 0);
			break;
		case GL_ACTIVE_TEXTURE_ARB:
			params[0] = (GLboolean) (g->texture.curTextureUnit+GL_TEXTURE0_ARB != 0);
			break;
		case GL_ALIASED_LINE_WIDTH_RANGE:
			params[0] = (GLboolean) (g->limits.aliasedLineWidthRange[0] != 0.0f);
			params[1] = (GLboolean) (g->limits.aliasedLineWidthRange[1] != 0.0f);
			break;
		case GL_ALIASED_POINT_SIZE_RANGE:
			params[0] = (GLboolean) (g->limits.aliasedPointSizeRange[0] != 0.0f);
			params[1] = (GLboolean) (g->limits.aliasedPointSizeRange[1] != 0.0f);
			break;
		case GL_ALPHA_BIAS:
			params[0] = (GLboolean) (g->pixel.bias.a != 0.0f);
			break;
		case GL_ALPHA_BITS:
			params[0] = (GLboolean) (g->limits.alphaBits != 0);
			break;
		case GL_ALPHA_SCALE:
			params[0] = (GLboolean) (g->pixel.scale.a != 0.0f);
			break;
		case GL_ALPHA_TEST:
			params[0] = (GLboolean) (g->buffer.alphaTest != 0);
			break;
		case GL_ALPHA_TEST_FUNC:
			params[0] = (GLboolean) (g->buffer.alphaTestFunc != 0);
			break;
		case GL_ALPHA_TEST_REF:
			params[0] = (GLboolean) (g->buffer.alphaTestRef != 0);
			break;
		case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
			params[0] = (GLboolean) (g->client.array.lockCount != 0);
			break;
		case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
			params[0] = (GLboolean) (g->client.array.lockFirst != 0);
			break;
		case GL_ATTRIB_STACK_DEPTH:
			params[0] = (GLboolean) (g->attrib.attribStackDepth != 0);
			break;
		case GL_AUTO_NORMAL:
			params[0] = (GLboolean) (g->eval.autoNormal != 0);
			break;
		case GL_AUX_BUFFERS:
			params[0] = (GLboolean) (g->limits.auxBuffers != 0);
			break;
		case GL_BLEND:
			params[0] = (GLboolean) (g->buffer.blend != 0);
			break;
		case GL_BLEND_DST:
			params[0] = (GLboolean) (g->buffer.blendDstRGB != 0);
			break;
		case GL_BLEND_SRC:
			params[0] = (GLboolean) (g->buffer.blendSrcRGB != 0);
			break;
		case GL_BLUE_BIAS:
			params[0] = (GLboolean) (g->pixel.bias.b != 0.0f);
			break;
		case GL_BLUE_BITS:
			params[0] = (GLboolean) (g->limits.blueBits != 0);
			break;
		case GL_BLUE_SCALE:
			params[0] = (GLboolean) (g->pixel.scale.b != 0.0f);
			break;
		case GL_CLIENT_ACTIVE_TEXTURE_ARB:
			params[0] = (GLboolean) (g->client.curClientTextureUnit+GL_TEXTURE0_ARB != 0);
			break;
		case GL_CLIP_PLANE0:
			params[0] = (GLboolean) (g->transform.clip[0] != 0);
			break;
		case GL_CLIP_PLANE1:
			params[0] = (GLboolean) (g->transform.clip[1] != 0);
			break;
		case GL_CLIP_PLANE2:
			params[0] = (GLboolean) (g->transform.clip[2] != 0);
			break;
		case GL_CLIP_PLANE3:
			params[0] = (GLboolean) (g->transform.clip[3] != 0);
			break;
		case GL_CLIP_PLANE4:
			params[0] = (GLboolean) (g->transform.clip[4] != 0);
			break;
		case GL_CLIP_PLANE5:
			params[0] = (GLboolean) (g->transform.clip[5] != 0);
			break;
		case GL_COLOR_ARRAY:
			params[0] = (GLboolean) (g->client.array.c.enabled != 0);
			break;
		case GL_COLOR_ARRAY_SIZE:
			params[0] = (GLboolean) (g->client.array.c.size != 0);
			break;
		case GL_COLOR_ARRAY_STRIDE:
			params[0] = (GLboolean) (g->client.array.c.stride != 0);
			break;
		case GL_COLOR_ARRAY_TYPE:
			params[0] = (GLboolean) (g->client.array.c.type != 0);
			break;
		case GL_COLOR_CLEAR_VALUE:
			params[0] = (GLboolean) (g->buffer.colorClearValue.r != 0.0f);
			params[1] = (GLboolean) (g->buffer.colorClearValue.g != 0.0f);
			params[2] = (GLboolean) (g->buffer.colorClearValue.b != 0.0f);
			params[3] = (GLboolean) (g->buffer.colorClearValue.a != 0.0f);
			break;
		case GL_COLOR_LOGIC_OP:
			params[0] = (GLboolean) (g->buffer.logicOp != 0);
			break;
		case GL_COLOR_MATERIAL:
			params[0] = (GLboolean) (GL_FALSE != 0);
			break;
		case GL_COLOR_MATERIAL_FACE:
			params[0] = (GLboolean) (g->lighting.colorMaterialFace != 0);
			break;
		case GL_COLOR_MATERIAL_PARAMETER:
			params[0] = (GLboolean) (g->lighting.colorMaterialMode != 0);
			break;
		case GL_COLOR_MATRIX:
			params[0] = (GLboolean) (g->transform.colorStack.top->m00 != (GLdefault) 0.0);
			params[1] = (GLboolean) (g->transform.colorStack.top->m01 != (GLdefault) 0.0);
			params[2] = (GLboolean) (g->transform.colorStack.top->m02 != (GLdefault) 0.0);
			params[3] = (GLboolean) (g->transform.colorStack.top->m03 != (GLdefault) 0.0);
			params[4] = (GLboolean) (g->transform.colorStack.top->m10 != (GLdefault) 0.0);
			params[5] = (GLboolean) (g->transform.colorStack.top->m11 != (GLdefault) 0.0);
			params[6] = (GLboolean) (g->transform.colorStack.top->m12 != (GLdefault) 0.0);
			params[7] = (GLboolean) (g->transform.colorStack.top->m13 != (GLdefault) 0.0);
			params[8] = (GLboolean) (g->transform.colorStack.top->m20 != (GLdefault) 0.0);
			params[9] = (GLboolean) (g->transform.colorStack.top->m21 != (GLdefault) 0.0);
			params[10] = (GLboolean) (g->transform.colorStack.top->m22 != (GLdefault) 0.0);
			params[11] = (GLboolean) (g->transform.colorStack.top->m23 != (GLdefault) 0.0);
			params[12] = (GLboolean) (g->transform.colorStack.top->m30 != (GLdefault) 0.0);
			params[13] = (GLboolean) (g->transform.colorStack.top->m31 != (GLdefault) 0.0);
			params[14] = (GLboolean) (g->transform.colorStack.top->m32 != (GLdefault) 0.0);
			params[15] = (GLboolean) (g->transform.colorStack.top->m33 != (GLdefault) 0.0);
			break;
		case GL_COLOR_MATRIX_STACK_DEPTH:
			params[0] = (GLboolean) (g->transform.colorStack.depth+1 != 0);
			break;
		case GL_COLOR_WRITEMASK:
			params[0] = (GLboolean) (g->buffer.colorWriteMask.r != 0);
			params[1] = (GLboolean) (g->buffer.colorWriteMask.g != 0);
			params[2] = (GLboolean) (g->buffer.colorWriteMask.b != 0);
			params[3] = (GLboolean) (g->buffer.colorWriteMask.a != 0);
			break;
		case GL_CULL_FACE:
			params[0] = (GLboolean) (g->polygon.cullFace != 0);
			break;
		case GL_CULL_FACE_MODE:
			params[0] = (GLboolean) (g->polygon.cullFaceMode != 0);
			break;
		case GL_CURRENT_COLOR:
			params[0] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_COLOR0][0] != 0.0f);
			params[1] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_COLOR0][1] != 0.0f);
			params[2] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_COLOR0][2] != 0.0f);
			params[3] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_COLOR0][3] != 0.0f);
			break;
		case GL_CURRENT_INDEX:
			params[0] = (GLboolean) (g->current.colorIndex != 0.0f);
			break;
		case GL_CURRENT_NORMAL:
			params[0] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_NORMAL][0] != 0.0f);
			params[1] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_NORMAL][1] != 0.0f);
			params[2] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_NORMAL][2] != 0.0f);
			break;
		case GL_CURRENT_RASTER_COLOR:
			params[0] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_COLOR0][0] != 0.0f);
			params[1] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_COLOR0][1] != 0.0f);
			params[2] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_COLOR0][2] != 0.0f);
			params[3] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_COLOR0][3] != 0.0f);
			break;
		case GL_CURRENT_RASTER_DISTANCE:
			params[0] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_FOG][0] != 0.0f);
			break;
		case GL_CURRENT_RASTER_INDEX:
			params[0] = (GLboolean) (g->current.rasterIndex != 0.0);
			break;
		case GL_CURRENT_RASTER_POSITION:
			params[0] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_POS][0] != 0.0f);
			params[1] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_POS][1] != 0.0f);
			params[2] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_POS][2] != 0.0f);
			params[3] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_POS][3] != 0.0f);
			break;
		case GL_CURRENT_RASTER_POSITION_VALID:
			params[0] = (GLboolean) (g->current.rasterValid != 0);
			break;
		case GL_CURRENT_RASTER_TEXTURE_COORDS:
			params[0] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_TEX0][0] != 0.0f);
			params[1] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_TEX0][1] != 0.0f);
			params[2] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_TEX0][2] != 0.0f);
			params[3] = (GLboolean) (g->current.rasterAttrib[VERT_ATTRIB_TEX0][3] != 0.0f);
			break;
		case GL_CURRENT_TEXTURE_COORDS:
			params[0] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][0] != 0.0f);
			params[1] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][1] != 0.0f);
			params[2] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][2] != 0.0f);
			params[3] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][3] != 0.0f);
			break;
		case GL_DEPTH_BIAS:
			params[0] = (GLboolean) (g->pixel.depthBias != 0.0f);
			break;
		case GL_DEPTH_BITS:
			params[0] = (GLboolean) (g->limits.depthBits != 0);
			break;
		case GL_DEPTH_CLEAR_VALUE:
			params[0] = (GLboolean) (g->buffer.depthClearValue != 0.0);
			break;
		case GL_DEPTH_FUNC:
			params[0] = (GLboolean) (g->buffer.depthFunc != 0);
			break;
		case GL_DEPTH_RANGE:
			params[0] = (GLboolean) (g->viewport.nearClip != 0.0);
			params[1] = (GLboolean) (g->viewport.farClip != 0.0);
			break;
		case GL_DEPTH_SCALE:
			params[0] = (GLboolean) (g->pixel.depthScale != 0.0f);
			break;
		case GL_DEPTH_TEST:
			params[0] = (GLboolean) (g->buffer.depthTest != 0);
			break;
		case GL_DEPTH_WRITEMASK:
			params[0] = (GLboolean) (g->buffer.depthMask != 0);
			break;
		case GL_DITHER:
			params[0] = (GLboolean) (g->buffer.dither != 0);
			break;
		case GL_DOUBLEBUFFER:
			params[0] = (GLboolean) (g->limits.doubleBuffer != 0);
			break;
		case GL_DRAW_BUFFER:
			params[0] = (GLboolean) (__getDrawBuffer(g) != 0);
			break;
		case GL_EDGE_FLAG:
			params[0] = (GLboolean) (g->current.edgeFlag != 0);
			break;
		case GL_EDGE_FLAG_ARRAY:
			params[0] = (GLboolean) (g->client.array.e.enabled != 0);
			break;
		case GL_EDGE_FLAG_ARRAY_STRIDE:
			params[0] = (GLboolean) (g->client.array.e.stride != 0);
			break;
		case GL_FEEDBACK_BUFFER_SIZE:
			params[0] = (GLboolean) (g->feedback.bufferSize != 0);
			break;
		case GL_FEEDBACK_BUFFER_TYPE:
			params[0] = (GLboolean) (g->feedback.type != 0);
			break;
		case GL_FOG:
			params[0] = (GLboolean) (g->fog.enable != 0);
			break;
		case GL_FOG_COLOR:
			params[0] = (GLboolean) (g->fog.color.r != 0.0f);
			params[1] = (GLboolean) (g->fog.color.g != 0.0f);
			params[2] = (GLboolean) (g->fog.color.b != 0.0f);
			params[3] = (GLboolean) (g->fog.color.a != 0.0f);
			break;
		case GL_FOG_DENSITY:
			params[0] = (GLboolean) (g->fog.density != 0.0f);
			break;
		case GL_FOG_END:
			params[0] = (GLboolean) (g->fog.end != 0.0f);
			break;
		case GL_FOG_HINT:
			params[0] = (GLboolean) (g->hint.fog != 0);
			break;
		case GL_FOG_INDEX:
			params[0] = (GLboolean) (g->fog.index != 0);
			break;
		case GL_FOG_MODE:
			params[0] = (GLboolean) (g->fog.mode != 0);
			break;
		case GL_FOG_START:
			params[0] = (GLboolean) (g->fog.start != 0.0f);
			break;
		case GL_FRAMEBUFFER_BINDING_EXT:
			params[0] = (GLboolean) ((g->framebufferobject.drawFB?g->framebufferobject.drawFB->id:0) != 0);
			break;
		case GL_FRONT_FACE:
			params[0] = (GLboolean) (g->polygon.frontFace != 0);
			break;
		case GL_GREEN_BIAS:
			params[0] = (GLboolean) (g->pixel.bias.g != 0.0f);
			break;
		case GL_GREEN_BITS:
			params[0] = (GLboolean) (g->limits.greenBits != 0);
			break;
		case GL_GREEN_SCALE:
			params[0] = (GLboolean) (g->pixel.scale.g != 0.0f);
			break;
		case GL_INDEX_ARRAY:
			params[0] = (GLboolean) (g->client.array.i.enabled != 0);
			break;
		case GL_INDEX_ARRAY_STRIDE:
			params[0] = (GLboolean) (g->client.array.i.stride != 0);
			break;
		case GL_INDEX_ARRAY_TYPE:
			params[0] = (GLboolean) (g->client.array.i.type != 0);
			break;
		case GL_INDEX_BITS:
			params[0] = (GLboolean) (g->limits.indexBits != 0);
			break;
		case GL_INDEX_CLEAR_VALUE:
			params[0] = (GLboolean) (g->buffer.indexClearValue != 0.0f);
			break;
		case GL_INDEX_LOGIC_OP:
			params[0] = (GLboolean) (g->buffer.indexLogicOp != 0);
			break;
		case GL_INDEX_MODE:
			params[0] = (GLboolean) ((!g->limits.rgbaMode) != 0);
			break;
		case GL_INDEX_OFFSET:
			params[0] = (GLboolean) (g->pixel.indexOffset != 0);
			break;
		case GL_INDEX_SHIFT:
			params[0] = (GLboolean) (g->pixel.indexShift != 0);
			break;
		case GL_INDEX_WRITEMASK:
			params[0] = (GLboolean) (g->buffer.indexWriteMask != 0);
			break;
		case GL_LIGHT0:
			params[0] = (GLboolean) (g->lighting.light[0].enable != 0);
			break;
		case GL_LIGHT1:
			params[0] = (GLboolean) (g->lighting.light[1].enable != 0);
			break;
		case GL_LIGHT2:
			params[0] = (GLboolean) (g->lighting.light[2].enable != 0);
			break;
		case GL_LIGHT3:
			params[0] = (GLboolean) (g->lighting.light[3].enable != 0);
			break;
		case GL_LIGHT4:
			params[0] = (GLboolean) (g->lighting.light[4].enable != 0);
			break;
		case GL_LIGHT5:
			params[0] = (GLboolean) (g->lighting.light[5].enable != 0);
			break;
		case GL_LIGHT6:
			params[0] = (GLboolean) (g->lighting.light[6].enable != 0);
			break;
		case GL_LIGHT7:
			params[0] = (GLboolean) (g->lighting.light[7].enable != 0);
			break;
		case GL_LIGHTING:
			params[0] = (GLboolean) (g->lighting.lighting != 0);
			break;
		case GL_LIGHT_MODEL_AMBIENT:
			params[0] = (GLboolean) (g->lighting.lightModelAmbient.r != 0.0f);
			params[1] = (GLboolean) (g->lighting.lightModelAmbient.g != 0.0f);
			params[2] = (GLboolean) (g->lighting.lightModelAmbient.b != 0.0f);
			params[3] = (GLboolean) (g->lighting.lightModelAmbient.a != 0.0f);
			break;
		case GL_LIGHT_MODEL_LOCAL_VIEWER:
			params[0] = (GLboolean) (g->lighting.lightModelLocalViewer != 0);
			break;
		case GL_LIGHT_MODEL_TWO_SIDE:
			params[0] = (GLboolean) (g->lighting.lightModelTwoSide != 0);
			break;
		case GL_LINE_SMOOTH:
			params[0] = (GLboolean) (g->line.lineSmooth != 0);
			break;
		case GL_LINE_SMOOTH_HINT:
			params[0] = (GLboolean) (g->hint.lineSmooth != 0);
			break;
		case GL_LINE_STIPPLE:
			params[0] = (GLboolean) (g->line.lineStipple != 0);
			break;
		case GL_LINE_STIPPLE_PATTERN:
			params[0] = (GLboolean) (g->line.pattern != 0);
			break;
		case GL_LINE_STIPPLE_REPEAT:
			params[0] = (GLboolean) (g->line.repeat != 0);
			break;
		case GL_LINE_WIDTH:
			params[0] = (GLboolean) (g->line.width != 0.0f);
			break;
		case GL_LIST_BASE:
			params[0] = (GLboolean) (g->lists.base != 0);
			break;
		case GL_LIST_INDEX:
			params[0] = (GLboolean) (g->lists.currentIndex != 0);
			break;
		case GL_LIST_MODE:
			params[0] = (GLboolean) (g->lists.mode != 0);
			break;
		case GL_LOGIC_OP_MODE:
			params[0] = (GLboolean) (g->buffer.logicOpMode != 0);
			break;
		case GL_MAP1_COLOR_4:
			params[0] = (GLboolean) (g->eval.enable1D[pname-GL_MAP1_COLOR_4] != 0);
			break;
		case GL_MAP1_GRID_DOMAIN:
			params[0] = (GLboolean) (g->eval.u11D != 0.0);
			params[1] = (GLboolean) (g->eval.u21D != 0.0);
			break;
		case GL_MAP1_GRID_SEGMENTS:
			params[0] = (GLboolean) (g->eval.un1D != 0);
			break;
		case GL_MAP1_INDEX:
			params[0] = (GLboolean) (g->eval.enable1D[pname-GL_MAP1_COLOR_4] != 0);
			break;
		case GL_MAP1_NORMAL:
			params[0] = (GLboolean) (g->eval.enable1D[pname-GL_MAP1_COLOR_4] != 0);
			break;
		case GL_MAP1_TEXTURE_COORD_1:
			params[0] = (GLboolean) (g->eval.enable1D[pname-GL_MAP1_COLOR_4] != 0);
			break;
		case GL_MAP1_TEXTURE_COORD_2:
			params[0] = (GLboolean) (g->eval.enable1D[pname-GL_MAP1_COLOR_4] != 0);
			break;
		case GL_MAP1_TEXTURE_COORD_3:
			params[0] = (GLboolean) (g->eval.enable1D[pname-GL_MAP1_COLOR_4] != 0);
			break;
		case GL_MAP1_TEXTURE_COORD_4:
			params[0] = (GLboolean) (g->eval.enable1D[pname-GL_MAP1_COLOR_4] != 0);
			break;
		case GL_MAP1_VERTEX_3:
			params[0] = (GLboolean) (g->eval.enable1D[pname-GL_MAP1_COLOR_4] != 0);
			break;
		case GL_MAP1_VERTEX_4:
			params[0] = (GLboolean) (g->eval.enable1D[pname-GL_MAP1_COLOR_4] != 0);
			break;
		case GL_MAP2_COLOR_4:
			params[0] = (GLboolean) (g->eval.enable2D[pname-GL_MAP2_COLOR_4] != 0);
			break;
		case GL_MAP2_GRID_DOMAIN:
			params[0] = (GLboolean) (g->eval.u12D != 0.0);
			params[1] = (GLboolean) (g->eval.u22D != 0.0);
			params[2] = (GLboolean) (g->eval.v12D != 0.0);
			params[3] = (GLboolean) (g->eval.v22D != 0.0);
			break;
		case GL_MAP2_GRID_SEGMENTS:
			params[0] = (GLboolean) (g->eval.un2D != 0);
			params[1] = (GLboolean) (g->eval.vn2D != 0);
			break;
		case GL_MAP2_INDEX:
			params[0] = (GLboolean) (g->eval.enable2D[pname-GL_MAP2_COLOR_4] != 0);
			break;
		case GL_MAP2_NORMAL:
			params[0] = (GLboolean) (g->eval.enable2D[pname-GL_MAP2_COLOR_4] != 0);
			break;
		case GL_MAP2_TEXTURE_COORD_1:
			params[0] = (GLboolean) (g->eval.enable2D[pname-GL_MAP2_COLOR_4] != 0);
			break;
		case GL_MAP2_TEXTURE_COORD_2:
			params[0] = (GLboolean) (g->eval.enable2D[pname-GL_MAP2_COLOR_4] != 0);
			break;
		case GL_MAP2_TEXTURE_COORD_3:
			params[0] = (GLboolean) (g->eval.enable2D[pname-GL_MAP2_COLOR_4] != 0);
			break;
		case GL_MAP2_TEXTURE_COORD_4:
			params[0] = (GLboolean) (g->eval.enable2D[pname-GL_MAP2_COLOR_4] != 0);
			break;
		case GL_MAP2_VERTEX_3:
			params[0] = (GLboolean) (g->eval.enable2D[pname-GL_MAP2_COLOR_4] != 0);
			break;
		case GL_MAP2_VERTEX_4:
			params[0] = (GLboolean) (g->eval.enable2D[pname-GL_MAP2_COLOR_4] != 0);
			break;
		case GL_MAP_COLOR:
			params[0] = (GLboolean) (g->pixel.mapColor != 0);
			break;
		case GL_MAP_STENCIL:
			params[0] = (GLboolean) (g->pixel.mapStencil != 0);
			break;
		case GL_MATRIX_MODE:
			params[0] = (GLboolean) (g->transform.matrixMode != 0);
			break;
		case GL_MAX_3D_TEXTURE_SIZE:
			params[0] = (GLboolean) (g->limits.max3DTextureSize != 0);
			break;
		case GL_MAX_ATTRIB_STACK_DEPTH:
			params[0] = (GLboolean) (g->limits.maxAttribStackDepth != 0);
			break;
		case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
			params[0] = (GLboolean) (g->limits.maxClientAttribStackDepth != 0);
			break;
		case GL_MAX_CLIP_PLANES:
			params[0] = (GLboolean) (g->limits.maxClipPlanes != 0);
			break;
		case GL_MAX_COLOR_MATRIX_STACK_DEPTH:
			params[0] = (GLboolean) (g->limits.maxColorStackDepth != 0);
			break;
		case GL_MAX_ELEMENTS_INDICES:
			params[0] = (GLboolean) (g->limits.maxElementsIndices != 0);
			break;
		case GL_MAX_ELEMENTS_VERTICES:
			params[0] = (GLboolean) (g->limits.maxElementsVertices != 0);
			break;
		case GL_MAX_EVAL_ORDER:
			params[0] = (GLboolean) (g->limits.maxEvalOrder != 0);
			break;
		case GL_MAX_LIGHTS:
			params[0] = (GLboolean) (g->limits.maxLights != 0);
			break;
		case GL_MAX_LIST_NESTING:
			params[0] = (GLboolean) (g->limits.maxListNesting != 0);
			break;
		case GL_MAX_MODELVIEW_STACK_DEPTH:
			params[0] = (GLboolean) (g->limits.maxModelviewStackDepth != 0);
			break;
		case GL_MAX_NAME_STACK_DEPTH:
			params[0] = (GLboolean) (g->limits.maxNameStackDepth != 0);
			break;
		case GL_MAX_PIXEL_MAP_TABLE:
			params[0] = (GLboolean) (g->limits.maxPixelMapTable != 0);
			break;
		case GL_MAX_PROJECTION_STACK_DEPTH:
			params[0] = (GLboolean) (g->limits.maxProjectionStackDepth != 0);
			break;
		case GL_MAX_TEXTURE_SIZE:
			params[0] = (GLboolean) (g->limits.maxTextureSize != 0);
			break;
		case GL_MAX_TEXTURE_STACK_DEPTH:
			params[0] = (GLboolean) (g->limits.maxTextureStackDepth != 0);
			break;
		case GL_MAX_TEXTURE_UNITS_ARB:
			params[0] = (GLboolean) (g->limits.maxTextureUnits != 0);
			break;
		case GL_MAX_VERTEX_ATTRIBS_ARB:
			params[0] = (GLboolean) (g->limits.maxVertexProgramAttribs != 0);
			break;
		case GL_MAX_VIEWPORT_DIMS:
			params[0] = (GLboolean) (g->limits.maxViewportDims[0] != 0);
			params[1] = (GLboolean) (g->limits.maxViewportDims[1] != 0);
			break;
		case GL_MODELVIEW_MATRIX:
			params[0] = (GLboolean) (g->transform.modelViewStack.top->m00 != (GLdefault) 0.0);
			params[1] = (GLboolean) (g->transform.modelViewStack.top->m01 != (GLdefault) 0.0);
			params[2] = (GLboolean) (g->transform.modelViewStack.top->m02 != (GLdefault) 0.0);
			params[3] = (GLboolean) (g->transform.modelViewStack.top->m03 != (GLdefault) 0.0);
			params[4] = (GLboolean) (g->transform.modelViewStack.top->m10 != (GLdefault) 0.0);
			params[5] = (GLboolean) (g->transform.modelViewStack.top->m11 != (GLdefault) 0.0);
			params[6] = (GLboolean) (g->transform.modelViewStack.top->m12 != (GLdefault) 0.0);
			params[7] = (GLboolean) (g->transform.modelViewStack.top->m13 != (GLdefault) 0.0);
			params[8] = (GLboolean) (g->transform.modelViewStack.top->m20 != (GLdefault) 0.0);
			params[9] = (GLboolean) (g->transform.modelViewStack.top->m21 != (GLdefault) 0.0);
			params[10] = (GLboolean) (g->transform.modelViewStack.top->m22 != (GLdefault) 0.0);
			params[11] = (GLboolean) (g->transform.modelViewStack.top->m23 != (GLdefault) 0.0);
			params[12] = (GLboolean) (g->transform.modelViewStack.top->m30 != (GLdefault) 0.0);
			params[13] = (GLboolean) (g->transform.modelViewStack.top->m31 != (GLdefault) 0.0);
			params[14] = (GLboolean) (g->transform.modelViewStack.top->m32 != (GLdefault) 0.0);
			params[15] = (GLboolean) (g->transform.modelViewStack.top->m33 != (GLdefault) 0.0);
			break;
		case GL_MODELVIEW_STACK_DEPTH:
			params[0] = (GLboolean) (g->transform.modelViewStack.depth+1 != 0);
			break;
		case GL_NAME_STACK_DEPTH:
			params[0] = (GLboolean) (0 != 0);
			break;
		case GL_NORMALIZE:
			params[0] = (GLboolean) (g->transform.normalize != 0);
			break;
		case GL_NORMAL_ARRAY:
			params[0] = (GLboolean) (g->client.array.n.enabled != 0);
			break;
		case GL_NORMAL_ARRAY_STRIDE:
			params[0] = (GLboolean) (g->client.array.n.stride != 0);
			break;
		case GL_NORMAL_ARRAY_TYPE:
			params[0] = (GLboolean) (g->client.array.n.type != 0);
			break;
		case GL_PACK_ALIGNMENT:
			params[0] = (GLboolean) (g->client.pack.alignment != 0);
			break;
		case GL_PACK_IMAGE_HEIGHT:
			params[0] = (GLboolean) (g->client.pack.imageHeight != 0);
			break;
		case GL_PACK_LSB_FIRST:
			params[0] = (GLboolean) (g->client.pack.psLSBFirst != 0);
			break;
		case GL_PACK_ROW_LENGTH:
			params[0] = (GLboolean) (g->client.pack.rowLength != 0);
			break;
		case GL_PACK_SKIP_IMAGES:
			params[0] = (GLboolean) (g->client.pack.skipImages != 0);
			break;
		case GL_PACK_SKIP_PIXELS:
			params[0] = (GLboolean) (g->client.pack.skipPixels != 0);
			break;
		case GL_PACK_SKIP_ROWS:
			params[0] = (GLboolean) (g->client.pack.skipRows != 0);
			break;
		case GL_PACK_SWAP_BYTES:
			params[0] = (GLboolean) (g->client.pack.swapBytes != 0);
			break;
		case GL_PERSPECTIVE_CORRECTION_HINT:
			params[0] = (GLboolean) (g->hint.perspectiveCorrection != 0);
			break;
		case GL_PIXEL_MAP_A_TO_A_SIZE:
			params[0] = (GLboolean) (g->pixel.mapAtoAsize != 0);
			break;
		case GL_PIXEL_MAP_B_TO_B_SIZE:
			params[0] = (GLboolean) (g->pixel.mapBtoBsize != 0);
			break;
		case GL_PIXEL_MAP_G_TO_G_SIZE:
			params[0] = (GLboolean) (g->pixel.mapGtoGsize != 0);
			break;
		case GL_PIXEL_MAP_I_TO_A_SIZE:
			params[0] = (GLboolean) (g->pixel.mapItoAsize != 0);
			break;
		case GL_PIXEL_MAP_I_TO_B_SIZE:
			params[0] = (GLboolean) (g->pixel.mapItoBsize != 0);
			break;
		case GL_PIXEL_MAP_I_TO_G_SIZE:
			params[0] = (GLboolean) (g->pixel.mapItoGsize != 0);
			break;
		case GL_PIXEL_MAP_I_TO_I_SIZE:
			params[0] = (GLboolean) (g->pixel.mapItoIsize != 0);
			break;
		case GL_PIXEL_MAP_I_TO_R_SIZE:
			params[0] = (GLboolean) (g->pixel.mapItoRsize != 0);
			break;
		case GL_PIXEL_MAP_R_TO_R_SIZE:
			params[0] = (GLboolean) (g->pixel.mapRtoRsize != 0);
			break;
		case GL_PIXEL_MAP_S_TO_S_SIZE:
			params[0] = (GLboolean) (g->pixel.mapStoSsize != 0);
			break;
		case GL_POINT_DISTANCE_ATTENUATION_ARB:
			params[0] = (GLboolean) (g->point.distanceAttenuation[0] != 0.0f);
			params[1] = (GLboolean) (g->point.distanceAttenuation[1] != 0.0f);
			params[2] = (GLboolean) (g->point.distanceAttenuation[2] != 0.0f);
			break;
		case GL_POINT_FADE_THRESHOLD_SIZE_ARB:
			params[0] = (GLboolean) (g->point.fadeThresholdSize != 0.0f);
			break;
		case GL_POINT_SIZE:
			params[0] = (GLboolean) (g->point.pointSize != 0.0f);
			break;
		case GL_POINT_SIZE_MAX_ARB:
			params[0] = (GLboolean) (g->point.maxSize != 0.0f);
			break;
		case GL_POINT_SIZE_MIN_ARB:
			params[0] = (GLboolean) (g->point.minSize != 0.0f);
			break;
		case GL_POINT_SMOOTH:
			params[0] = (GLboolean) (g->point.pointSmooth != 0);
			break;
		case GL_POINT_SMOOTH_HINT:
			params[0] = (GLboolean) (g->hint.pointSmooth != 0);
			break;
		case GL_POINT_SPRITE_COORD_ORIGIN:
			params[0] = (GLboolean) (g->point.spriteCoordOrigin != 0.0f);
			break;
		case GL_POLYGON_MODE:
			params[0] = (GLboolean) (g->polygon.frontMode != 0);
			params[1] = (GLboolean) (g->polygon.backMode != 0);
			break;
		case GL_POLYGON_OFFSET_FACTOR:
			params[0] = (GLboolean) (g->polygon.offsetFactor != 0.0f);
			break;
		case GL_POLYGON_OFFSET_FILL:
			params[0] = (GLboolean) (g->polygon.polygonOffsetFill != 0);
			break;
		case GL_POLYGON_OFFSET_LINE:
			params[0] = (GLboolean) (g->polygon.polygonOffsetLine != 0);
			break;
		case GL_POLYGON_OFFSET_POINT:
			params[0] = (GLboolean) (g->polygon.polygonOffsetPoint != 0);
			break;
		case GL_POLYGON_OFFSET_UNITS:
			params[0] = (GLboolean) (g->polygon.offsetUnits != 0.0f);
			break;
		case GL_POLYGON_SMOOTH:
			params[0] = (GLboolean) (g->polygon.polygonSmooth != 0);
			break;
		case GL_POLYGON_SMOOTH_HINT:
			params[0] = (GLboolean) (g->hint.polygonSmooth != 0);
			break;
		case GL_POLYGON_STIPPLE:
			params[0] = (GLboolean) (g->polygon.polygonStipple != 0);
			break;
		case GL_PROJECTION_MATRIX:
			params[0] = (GLboolean) (g->transform.projectionStack.top->m00 != (GLdefault) 0.0);
			params[1] = (GLboolean) (g->transform.projectionStack.top->m01 != (GLdefault) 0.0);
			params[2] = (GLboolean) (g->transform.projectionStack.top->m02 != (GLdefault) 0.0);
			params[3] = (GLboolean) (g->transform.projectionStack.top->m03 != (GLdefault) 0.0);
			params[4] = (GLboolean) (g->transform.projectionStack.top->m10 != (GLdefault) 0.0);
			params[5] = (GLboolean) (g->transform.projectionStack.top->m11 != (GLdefault) 0.0);
			params[6] = (GLboolean) (g->transform.projectionStack.top->m12 != (GLdefault) 0.0);
			params[7] = (GLboolean) (g->transform.projectionStack.top->m13 != (GLdefault) 0.0);
			params[8] = (GLboolean) (g->transform.projectionStack.top->m20 != (GLdefault) 0.0);
			params[9] = (GLboolean) (g->transform.projectionStack.top->m21 != (GLdefault) 0.0);
			params[10] = (GLboolean) (g->transform.projectionStack.top->m22 != (GLdefault) 0.0);
			params[11] = (GLboolean) (g->transform.projectionStack.top->m23 != (GLdefault) 0.0);
			params[12] = (GLboolean) (g->transform.projectionStack.top->m30 != (GLdefault) 0.0);
			params[13] = (GLboolean) (g->transform.projectionStack.top->m31 != (GLdefault) 0.0);
			params[14] = (GLboolean) (g->transform.projectionStack.top->m32 != (GLdefault) 0.0);
			params[15] = (GLboolean) (g->transform.projectionStack.top->m33 != (GLdefault) 0.0);
			break;
		case GL_PROJECTION_STACK_DEPTH:
			params[0] = (GLboolean) (g->transform.projectionStack.depth+1 != 0);
			break;
		case GL_READ_BUFFER:
			params[0] = (GLboolean) (__getReadBuffer(g) != 0);
			break;
		case GL_READ_FRAMEBUFFER_BINDING:
			params[0] = (GLboolean) ((g->framebufferobject.readFB?g->framebufferobject.readFB->id:0) != 0);
			break;
		case GL_RED_BIAS:
			params[0] = (GLboolean) (g->pixel.bias.r != 0.0f);
			break;
		case GL_RED_BITS:
			params[0] = (GLboolean) (g->limits.redBits != 0);
			break;
		case GL_RED_SCALE:
			params[0] = (GLboolean) (g->pixel.scale.r != 0.0f);
			break;
		case GL_RENDERBUFFER_BINDING_EXT:
			params[0] = (GLboolean) ((g->framebufferobject.renderbuffer?g->framebufferobject.renderbuffer->id:0) != 0);
			break;
		case GL_RENDER_MODE:
			params[0] = (GLboolean) (g->renderMode != 0);
			break;
		case GL_RGBA_MODE:
			params[0] = (GLboolean) (g->limits.rgbaMode != 0);
			break;
		case GL_SCISSOR_BOX:
			params[0] = (GLboolean) (g->viewport.scissorX != 0);
			params[1] = (GLboolean) (g->viewport.scissorY != 0);
			params[2] = (GLboolean) (g->viewport.scissorW != 0);
			params[3] = (GLboolean) (g->viewport.scissorH != 0);
			break;
		case GL_SCISSOR_TEST:
			params[0] = (GLboolean) (g->viewport.scissorTest != 0);
			break;
		case GL_SELECTION_BUFFER_SIZE:
			params[0] = (GLboolean) (g->selection.bufferSize != 0);
			break;
		case GL_SHADE_MODEL:
			params[0] = (GLboolean) (g->lighting.shadeModel != 0);
			break;
		case GL_SMOOTH_LINE_WIDTH_GRANULARITY:
			params[0] = (GLboolean) (g->limits.lineWidthGranularity != 0.0f);
			break;
		case GL_SMOOTH_LINE_WIDTH_RANGE:
			params[0] = (GLboolean) (g->limits.smoothLineWidthRange[0] != 0.0f);
			params[1] = (GLboolean) (g->limits.smoothLineWidthRange[1] != 0.0f);
			break;
		case GL_SMOOTH_POINT_SIZE_GRANULARITY:
			params[0] = (GLboolean) (g->limits.pointSizeGranularity != 0.0f);
			break;
		case GL_SMOOTH_POINT_SIZE_RANGE:
			params[0] = (GLboolean) (g->limits.smoothPointSizeRange[0] != 0.0f);
			params[1] = (GLboolean) (g->limits.smoothPointSizeRange[1] != 0.0f);
			break;
		case GL_STENCIL_BACK_FAIL:
			params[0] = (GLboolean) (g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].fail != 0);
			break;
		case GL_STENCIL_BACK_FUNC:
			params[0] = (GLboolean) (g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].func != 0);
			break;
		case GL_STENCIL_BACK_PASS_DEPTH_FAIL:
			params[0] = (GLboolean) (g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthFail != 0);
			break;
		case GL_STENCIL_BACK_PASS_DEPTH_PASS:
			params[0] = (GLboolean) (g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthPass != 0);
			break;
		case GL_STENCIL_BACK_REF:
			params[0] = (GLboolean) (g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].ref != 0);
			break;
		case GL_STENCIL_BACK_VALUE_MASK:
			params[0] = (GLboolean) (g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].mask != 0);
			break;
		case GL_STENCIL_BITS:
			params[0] = (GLboolean) (g->limits.stencilBits != 0);
			break;
		case GL_STENCIL_CLEAR_VALUE:
			params[0] = (GLboolean) (g->stencil.clearValue != 0);
			break;
		case GL_STENCIL_FAIL:
			params[0] = (GLboolean) (g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].fail != 0);
			break;
		case GL_STENCIL_FUNC:
			params[0] = (GLboolean) (g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].func != 0);
			break;
		case GL_STENCIL_PASS_DEPTH_FAIL:
			params[0] = (GLboolean) (g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthFail != 0);
			break;
		case GL_STENCIL_PASS_DEPTH_PASS:
			params[0] = (GLboolean) (g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthPass != 0);
			break;
		case GL_STENCIL_REF:
			params[0] = (GLboolean) (g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].ref != 0);
			break;
		case GL_STENCIL_TEST:
			params[0] = (GLboolean) (g->stencil.stencilTest != 0);
			break;
		case GL_STENCIL_VALUE_MASK:
			params[0] = (GLboolean) (g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].mask != 0);
			break;
		case GL_STENCIL_WRITEMASK:
			params[0] = (GLboolean) (g->stencil.writeMask != 0);
			break;
		case GL_STEREO:
			params[0] = (GLboolean) (g->limits.stereo != 0);
			break;
		case GL_SUBPIXEL_BITS:
			params[0] = (GLboolean) (g->limits.subpixelBits != 0);
			break;
		case GL_TEXTURE_1D:
			params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].enabled1D != 0);
			break;
		case GL_TEXTURE_2D:
			params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].enabled2D != 0);
			break;
		case GL_TEXTURE_3D:
			params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].enabled3D != 0);
			break;
		case GL_TEXTURE_BINDING_1D:
			params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].currentTexture1D->id != 0);
			break;
		case GL_TEXTURE_BINDING_2D:
			params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].currentTexture2D->id != 0);
			break;
		case GL_TEXTURE_BINDING_3D:
			params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].currentTexture3D->id != 0);
			break;
		case GL_TEXTURE_COORD_ARRAY:
			params[0] = (GLboolean) (g->client.array.t[g->client.curClientTextureUnit].enabled != 0);
			break;
		case GL_TEXTURE_COORD_ARRAY_SIZE:
			params[0] = (GLboolean) (g->client.array.t[g->client.curClientTextureUnit].size != 0);
			break;
		case GL_TEXTURE_COORD_ARRAY_STRIDE:
			params[0] = (GLboolean) (g->client.array.t[g->client.curClientTextureUnit].stride != 0);
			break;
		case GL_TEXTURE_COORD_ARRAY_TYPE:
			params[0] = (GLboolean) (g->client.array.t[g->client.curClientTextureUnit].type != 0);
			break;
		case GL_TEXTURE_ENV_MODE:
			params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].envMode != 0);
			break;
		case GL_TEXTURE_GEN_Q:
			params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].textureGen.q != 0);
			break;
		case GL_TEXTURE_GEN_R:
			params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].textureGen.r != 0);
			break;
		case GL_TEXTURE_GEN_S:
			params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].textureGen.s != 0);
			break;
		case GL_TEXTURE_GEN_T:
			params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].textureGen.t != 0);
			break;
		case GL_TEXTURE_MATRIX:
			params[0] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m00 != (GLdefault) 0.0);
			params[1] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m01 != (GLdefault) 0.0);
			params[2] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m02 != (GLdefault) 0.0);
			params[3] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m03 != (GLdefault) 0.0);
			params[4] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m10 != (GLdefault) 0.0);
			params[5] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m11 != (GLdefault) 0.0);
			params[6] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m12 != (GLdefault) 0.0);
			params[7] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m13 != (GLdefault) 0.0);
			params[8] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m20 != (GLdefault) 0.0);
			params[9] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m21 != (GLdefault) 0.0);
			params[10] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m22 != (GLdefault) 0.0);
			params[11] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m23 != (GLdefault) 0.0);
			params[12] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m30 != (GLdefault) 0.0);
			params[13] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m31 != (GLdefault) 0.0);
			params[14] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m32 != (GLdefault) 0.0);
			params[15] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m33 != (GLdefault) 0.0);
			break;
		case GL_TEXTURE_STACK_DEPTH:
			params[0] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].depth+1 != 0);
			break;
		case GL_UNPACK_ALIGNMENT:
			params[0] = (GLboolean) (g->client.unpack.alignment != 0);
			break;
		case GL_UNPACK_IMAGE_HEIGHT:
			params[0] = (GLboolean) (g->client.unpack.imageHeight != 0);
			break;
		case GL_UNPACK_LSB_FIRST:
			params[0] = (GLboolean) (g->client.unpack.psLSBFirst != 0);
			break;
		case GL_UNPACK_ROW_LENGTH:
			params[0] = (GLboolean) (g->client.unpack.rowLength != 0);
			break;
		case GL_UNPACK_SKIP_IMAGES:
			params[0] = (GLboolean) (g->client.unpack.skipImages != 0);
			break;
		case GL_UNPACK_SKIP_PIXELS:
			params[0] = (GLboolean) (g->client.unpack.skipPixels != 0);
			break;
		case GL_UNPACK_SKIP_ROWS:
			params[0] = (GLboolean) (g->client.unpack.skipRows != 0);
			break;
		case GL_UNPACK_SWAP_BYTES:
			params[0] = (GLboolean) (g->client.unpack.swapBytes != 0);
			break;
		case GL_VERTEX_ARRAY:
			params[0] = (GLboolean) (g->client.array.v.enabled != 0);
			break;
		case GL_VERTEX_ARRAY_SIZE:
			params[0] = (GLboolean) (g->client.array.v.size != 0);
			break;
		case GL_VERTEX_ARRAY_STRIDE:
			params[0] = (GLboolean) (g->client.array.v.stride != 0);
			break;
		case GL_VERTEX_ARRAY_TYPE:
			params[0] = (GLboolean) (g->client.array.v.type != 0);
			break;
		case GL_VIEWPORT:
			params[0] = (GLboolean) (g->viewport.viewportX != 0);
			params[1] = (GLboolean) (g->viewport.viewportY != 0);
			params[2] = (GLboolean) (g->viewport.viewportW != 0);
			params[3] = (GLboolean) (g->viewport.viewportH != 0);
			break;
		case GL_ZOOM_X:
			params[0] = (GLboolean) (g->pixel.xZoom != 0.0f);
			break;
		case GL_ZOOM_Y:
			params[0] = (GLboolean) (g->pixel.yZoom != 0.0f);
			break;
#ifdef CR_ARB_vertex_buffer_object
		case GL_ARRAY_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_vertex_buffer_object) {
				params[0] = (GLboolean) (g->bufferobject.arrayBuffer->id != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_EXT_blend_color
		case GL_BLEND_COLOR_EXT:
			if (g->extensions.EXT_blend_color) {
				params[0] = (GLboolean) (g->buffer.blendColor.r != 0.0f);
				params[1] = (GLboolean) (g->buffer.blendColor.g != 0.0f);
				params[2] = (GLboolean) (g->buffer.blendColor.b != 0.0f);
				params[3] = (GLboolean) (g->buffer.blendColor.a != 0.0f);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_blend_color */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_DST_ALPHA_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLboolean) (g->buffer.blendDstA != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_DST_RGB_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLboolean) (g->buffer.blendDstRGB != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_minmax
		case GL_BLEND_EQUATION_EXT:
			if (g->extensions.EXT_blend_minmax) {
				params[0] = (GLboolean) (g->buffer.blendEquation != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_blend_minmax */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_SRC_ALPHA_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLboolean) (g->buffer.blendSrcA != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_SRC_RGB_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLboolean) (g->buffer.blendSrcRGB != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_NV_register_combiners
		case GL_COLOR_SUM_CLAMP_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLboolean) (g->regcombiner.colorSumClamp != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_EXT_secondary_color
		case GL_COLOR_SUM_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLboolean) (g->lighting.colorSumEXT != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_ARB_texture_compression
		case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
			if (g->extensions.ARB_texture_compression) {
				params[0] = (GLboolean) (g->limits.compressedFormats[0] != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_texture_compression */
#ifdef CR_NV_register_combiners
		case GL_CONSTANT_COLOR0_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLboolean) (g->regcombiner.constantColor0.r != 0.0f);
				params[1] = (GLboolean) (g->regcombiner.constantColor0.g != 0.0f);
				params[2] = (GLboolean) (g->regcombiner.constantColor0.b != 0.0f);
				params[3] = (GLboolean) (g->regcombiner.constantColor0.a != 0.0f);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
		case GL_CONSTANT_COLOR1_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLboolean) (g->regcombiner.constantColor1.r != 0.0f);
				params[1] = (GLboolean) (g->regcombiner.constantColor1.g != 0.0f);
				params[2] = (GLboolean) (g->regcombiner.constantColor1.b != 0.0f);
				params[3] = (GLboolean) (g->regcombiner.constantColor1.a != 0.0f);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_EXT_fog_coord
		case GL_CURRENT_FOG_COORDINATE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_FOG][0] != 0.0f);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_secondary_color
		case GL_CURRENT_SECONDARY_COLOR_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_COLOR1][0] != 0.0f);
				params[1] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_COLOR1][1] != 0.0f);
				params[2] = (GLboolean) (g->current.vertexAttrib[VERT_ATTRIB_COLOR1][2] != 0.0f);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_ARB_vertex_buffer_object
		case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_vertex_buffer_object) {
				params[0] = (GLboolean) (g->bufferobject.elementsBuffer->id != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_ARRAY_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLboolean) (g->client.array.f.enabled != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLboolean) (g->client.array.f.stride != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLboolean) (g->client.array.f.type != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_SOURCE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLboolean) (g->fog.fogCoordinateSource != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_NV_fog_distance
		case GL_FOG_DISTANCE_MODE_NV:
			if (g->extensions.NV_fog_distance) {
				params[0] = (GLboolean) (g->fog.fogDistanceMode != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_fog_distance */
#ifdef CR_ARB_fragment_program
		case GL_FRAGMENT_PROGRAM_ARB:
			if (g->extensions.ARB_fragment_program) {
				params[0] = (GLboolean) (g->program.fpEnabledARB != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_fragment_program */
#ifdef CR_NV_fragment_program
		case GL_FRAGMENT_PROGRAM_BINDING_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLboolean) (g->program.fpProgramBinding != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_fragment_program
		case GL_FRAGMENT_PROGRAM_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLboolean) (g->program.fpEnabled != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_SGIS_generate_mipmap
		case GL_GENERATE_MIPMAP_HINT:
			if (g->extensions.SGIS_generate_mipmap) {
				params[0] = (GLboolean) (g->hint.generateMipmap != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_SGIS_generate_mipmap */
#ifdef CR_OPENGL_VERSION_1_2
		case GL_LIGHT_MODEL_COLOR_CONTROL:
			params[0] = (GLboolean) (g->lighting.lightModelColorControlEXT != 0);
			break;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_EXT_separate_specular_color
		case GL_LIGHT_MODEL_COLOR_CONTROL_EXT:
			if (g->extensions.EXT_separate_specular_color) {
				params[0] = (GLboolean) (g->lighting.lightModelColorControlEXT != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_separate_specular_color */
#ifdef CR_ARB_texture_cube_map
		case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
			if (g->extensions.ARB_texture_cube_map) {
				params[0] = (GLboolean) (g->limits.maxCubeMapTextureSize != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_fragment_program
		case GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLboolean) (g->limits.maxFragmentProgramLocalParams != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_register_combiners
		case GL_MAX_GENERAL_COMBINERS_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLboolean) (g->limits.maxGeneralCombiners != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_texture_rectangle
		case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
			if (g->extensions.NV_texture_rectangle) {
				params[0] = (GLboolean) (g->limits.maxRectTextureSize != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_NV_fragment_program
		case GL_MAX_TEXTURE_COORDS_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLboolean) (g->limits.maxTextureCoords != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_fragment_program
		case GL_MAX_TEXTURE_IMAGE_UNITS_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLboolean) (g->limits.maxTextureImageUnits != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_EXT_texture_lod_bias
		case GL_MAX_TEXTURE_LOD_BIAS_EXT:
			if (g->extensions.EXT_texture_lod_bias) {
				params[0] = (GLboolean) (g->limits.maxTextureLodBias != 0.0f);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_texture_lod_bias */
#ifdef CR_EXT_texture_filter_anisotropic
		case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
			if (g->extensions.EXT_texture_filter_anisotropic) {
				params[0] = (GLboolean) (g->limits.maxTextureAnisotropy != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_texture_filter_anisotropic */
#ifdef CR_ARB_multisample
		case GL_MULTISAMPLE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLboolean) (g->multisample.enabled != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_texture_compression
		case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
			if (g->extensions.ARB_texture_compression) {
				params[0] = (GLboolean) (g->limits.numCompressedFormats != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_texture_compression */
#ifdef CR_NV_register_combiners
		case GL_NUM_GENERAL_COMBINERS_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLboolean) (g->regcombiner.numGeneralCombiners != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners2
		case GL_PER_STAGE_CONSTANTS_NV:
			if (g->extensions.NV_register_combiners2) {
				params[0] = (GLboolean) (g->regcombiner.enabledPerStageConstants != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_register_combiners2 */
#ifdef CR_ARB_pixel_buffer_object
		case GL_PIXEL_PACK_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_pixel_buffer_object) {
				params[0] = (GLboolean) (g->bufferobject.packBuffer->id != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_pixel_buffer_object */
#ifdef CR_ARB_pixel_buffer_object
		case GL_PIXEL_UNPACK_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_pixel_buffer_object) {
				params[0] = (GLboolean) (g->bufferobject.unpackBuffer->id != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_pixel_buffer_object */
#ifdef CR_ARB_point_sprite
		case GL_POINT_SPRITE_ARB:
			if (g->extensions.ARB_point_sprite) {
				params[0] = (GLboolean) (g->point.pointSprite != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_point_sprite */
#ifdef CR_any_program
		case GL_PROGRAM_ERROR_POSITION_NV:
			if (g->extensions.any_program) {
				params[0] = (GLboolean) (g->program.errorPos != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_any_program */
#ifdef CR_NV_register_combiners
		case GL_REGISTER_COMBINERS_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLboolean) (g->regcombiner.enabledRegCombiners != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_OPENGL_VERSION_1_2
		case GL_RESCALE_NORMAL:
			params[0] = (GLboolean) (g->transform.rescaleNormals != 0);
			break;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_ARB_multisample
		case GL_SAMPLES_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLboolean) (g->limits.samples != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLboolean) (g->multisample.sampleAlphaToCoverage != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_ALPHA_TO_ONE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLboolean) (g->multisample.sampleAlphaToOne != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_BUFFERS_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLboolean) (g->limits.sampleBuffers != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_COVERAGE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLboolean) (g->multisample.sampleCoverage != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_COVERAGE_INVERT_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLboolean) (g->multisample.sampleCoverageInvert != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_COVERAGE_VALUE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLboolean) (g->multisample.sampleCoverageValue != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLboolean) (g->client.array.s.enabled != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLboolean) (g->client.array.s.size != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLboolean) (g->client.array.s.stride != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLboolean) (g->client.array.s.type != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_ARB_texture_cube_map
		case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
			if (g->extensions.ARB_texture_cube_map) {
				params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].currentTextureCubeMap->id != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_texture_rectangle
		case GL_TEXTURE_BINDING_RECTANGLE_NV:
			if (g->extensions.NV_texture_rectangle) {
				params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].currentTextureRect->id != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_ARB_texture_compression
		case GL_TEXTURE_COMPRESSION_HINT_ARB:
			if (g->extensions.ARB_texture_compression) {
				params[0] = (GLboolean) (g->hint.textureCompression != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_texture_compression */
#ifdef CR_ARB_texture_cube_map
		case GL_TEXTURE_CUBE_MAP_ARB:
			if (g->extensions.ARB_texture_cube_map) {
				params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].enabledCubeMap != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_texture_rectangle
		case GL_TEXTURE_RECTANGLE_NV:
			if (g->extensions.NV_texture_rectangle) {
				params[0] = (GLboolean) (g->texture.unit[g->texture.curTextureUnit].enabledRect != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_ARB_transpose_matrix
		case GL_TRANSPOSE_MODELVIEW_MATRIX:
			if (g->extensions.ARB_transpose_matrix) {
				params[0] = (GLboolean) (g->transform.modelViewStack.top->m00 != (GLdefault) 0.0);
				params[1] = (GLboolean) (g->transform.modelViewStack.top->m10 != (GLdefault) 0.0);
				params[2] = (GLboolean) (g->transform.modelViewStack.top->m20 != (GLdefault) 0.0);
				params[3] = (GLboolean) (g->transform.modelViewStack.top->m30 != (GLdefault) 0.0);
				params[4] = (GLboolean) (g->transform.modelViewStack.top->m01 != (GLdefault) 0.0);
				params[5] = (GLboolean) (g->transform.modelViewStack.top->m11 != (GLdefault) 0.0);
				params[6] = (GLboolean) (g->transform.modelViewStack.top->m21 != (GLdefault) 0.0);
				params[7] = (GLboolean) (g->transform.modelViewStack.top->m31 != (GLdefault) 0.0);
				params[8] = (GLboolean) (g->transform.modelViewStack.top->m02 != (GLdefault) 0.0);
				params[9] = (GLboolean) (g->transform.modelViewStack.top->m12 != (GLdefault) 0.0);
				params[10] = (GLboolean) (g->transform.modelViewStack.top->m22 != (GLdefault) 0.0);
				params[11] = (GLboolean) (g->transform.modelViewStack.top->m32 != (GLdefault) 0.0);
				params[12] = (GLboolean) (g->transform.modelViewStack.top->m03 != (GLdefault) 0.0);
				params[13] = (GLboolean) (g->transform.modelViewStack.top->m13 != (GLdefault) 0.0);
				params[14] = (GLboolean) (g->transform.modelViewStack.top->m23 != (GLdefault) 0.0);
				params[15] = (GLboolean) (g->transform.modelViewStack.top->m33 != (GLdefault) 0.0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_ARB_transpose_matrix
		case GL_TRANSPOSE_PROJECTION_MATRIX:
			if (g->extensions.ARB_transpose_matrix) {
				params[0] = (GLboolean) (g->transform.projectionStack.top->m00 != (GLdefault) 0.0);
				params[1] = (GLboolean) (g->transform.projectionStack.top->m10 != (GLdefault) 0.0);
				params[2] = (GLboolean) (g->transform.projectionStack.top->m20 != (GLdefault) 0.0);
				params[3] = (GLboolean) (g->transform.projectionStack.top->m30 != (GLdefault) 0.0);
				params[4] = (GLboolean) (g->transform.projectionStack.top->m01 != (GLdefault) 0.0);
				params[5] = (GLboolean) (g->transform.projectionStack.top->m11 != (GLdefault) 0.0);
				params[6] = (GLboolean) (g->transform.projectionStack.top->m21 != (GLdefault) 0.0);
				params[7] = (GLboolean) (g->transform.projectionStack.top->m31 != (GLdefault) 0.0);
				params[8] = (GLboolean) (g->transform.projectionStack.top->m02 != (GLdefault) 0.0);
				params[9] = (GLboolean) (g->transform.projectionStack.top->m12 != (GLdefault) 0.0);
				params[10] = (GLboolean) (g->transform.projectionStack.top->m22 != (GLdefault) 0.0);
				params[11] = (GLboolean) (g->transform.projectionStack.top->m32 != (GLdefault) 0.0);
				params[12] = (GLboolean) (g->transform.projectionStack.top->m03 != (GLdefault) 0.0);
				params[13] = (GLboolean) (g->transform.projectionStack.top->m13 != (GLdefault) 0.0);
				params[14] = (GLboolean) (g->transform.projectionStack.top->m23 != (GLdefault) 0.0);
				params[15] = (GLboolean) (g->transform.projectionStack.top->m33 != (GLdefault) 0.0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_ARB_transpose_matrix
		case GL_TRANSPOSE_TEXTURE_MATRIX:
			if (g->extensions.ARB_transpose_matrix) {
				params[0] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m00 != (GLdefault) 0.0);
				params[1] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m10 != (GLdefault) 0.0);
				params[2] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m20 != (GLdefault) 0.0);
				params[3] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m30 != (GLdefault) 0.0);
				params[4] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m01 != (GLdefault) 0.0);
				params[5] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m11 != (GLdefault) 0.0);
				params[6] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m21 != (GLdefault) 0.0);
				params[7] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m31 != (GLdefault) 0.0);
				params[8] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m02 != (GLdefault) 0.0);
				params[9] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m12 != (GLdefault) 0.0);
				params[10] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m22 != (GLdefault) 0.0);
				params[11] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m32 != (GLdefault) 0.0);
				params[12] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m03 != (GLdefault) 0.0);
				params[13] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m13 != (GLdefault) 0.0);
				params[14] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m23 != (GLdefault) 0.0);
				params[15] = (GLboolean) (g->transform.textureStack[g->texture.curTextureUnit].top->m33 != (GLdefault) 0.0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_NV_vertex_program
		case GL_VERTEX_PROGRAM_BINDING_NV:
			if (g->extensions.NV_vertex_program) {
				params[0] = (GLboolean) (g->program.vpProgramBinding != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_NV_vertex_program */
#ifdef CR_any_vertex_program
		case GL_VERTEX_PROGRAM_NV:
			if (g->extensions.any_vertex_program) {
				params[0] = (GLboolean) (g->program.vpEnabled != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
		case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
			if (g->extensions.any_vertex_program) {
				params[0] = (GLboolean) (g->program.vpPointSize != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
		case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
			if (g->extensions.any_vertex_program) {
				params[0] = (GLboolean) (g->program.vpTwoSide != 0);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetBooleanv");
			}
			break;
#endif /* CR_any_vertex_program */
		default:
			crStateError(__LINE__, __FILE__, GL_INVALID_ENUM, "glGet: Unknown enum: 0x%x", pname);
			return;
	}
}

void STATE_APIENTRY crStateGetDoublev( GLenum pname, GLdouble *params )

{
	CRContext *g = GetCurrentContext();

	if (g->current.inBeginEnd)
	{
		crStateError(__LINE__, __FILE__, GL_INVALID_OPERATION,
			"glGet called in Begin/End");
		return;
	}

	if (pname == GL_CURRENT_INDEX || pname == GL_CURRENT_COLOR ||
		pname == GL_CURRENT_SECONDARY_COLOR_EXT ||
		pname == GL_CURRENT_FOG_COORDINATE_EXT ||
		pname == GL_CURRENT_NORMAL || pname == GL_EDGE_FLAG ||
		pname == GL_CURRENT_TEXTURE_COORDS )
	{
#if 0
		crStateError(__LINE__,__FILE__, GL_INVALID_OPERATION,
			"Unimplemented glGet of a 'current' value" );
#else
		crStateCurrentRecover();/* &g->current, &sb->current, g->bitID );*/
		
#endif
	}

	switch (pname) {

		case GL_ACCUM_ALPHA_BITS:
			params[0] = (GLdouble) g->limits.accumAlphaBits;
			break;
		case GL_ACCUM_BLUE_BITS:
			params[0] = (GLdouble) g->limits.accumBlueBits;
			break;
		case GL_ACCUM_CLEAR_VALUE:
			params[0] = (GLdouble) g->buffer.accumClearValue.r;
			params[1] = (GLdouble) g->buffer.accumClearValue.g;
			params[2] = (GLdouble) g->buffer.accumClearValue.b;
			params[3] = (GLdouble) g->buffer.accumClearValue.a;
			break;
		case GL_ACCUM_GREEN_BITS:
			params[0] = (GLdouble) g->limits.accumGreenBits;
			break;
		case GL_ACCUM_RED_BITS:
			params[0] = (GLdouble) g->limits.accumRedBits;
			break;
		case GL_ACTIVE_STENCIL_FACE_EXT:
			params[0] = (GLdouble) g->stencil.activeStencilFace;
			break;
		case GL_ACTIVE_TEXTURE_ARB:
			params[0] = (GLdouble) g->texture.curTextureUnit+GL_TEXTURE0_ARB;
			break;
		case GL_ALIASED_LINE_WIDTH_RANGE:
			params[0] = (GLdouble) g->limits.aliasedLineWidthRange[0];
			params[1] = (GLdouble) g->limits.aliasedLineWidthRange[1];
			break;
		case GL_ALIASED_POINT_SIZE_RANGE:
			params[0] = (GLdouble) g->limits.aliasedPointSizeRange[0];
			params[1] = (GLdouble) g->limits.aliasedPointSizeRange[1];
			break;
		case GL_ALPHA_BIAS:
			params[0] = (GLdouble) g->pixel.bias.a;
			break;
		case GL_ALPHA_BITS:
			params[0] = (GLdouble) g->limits.alphaBits;
			break;
		case GL_ALPHA_SCALE:
			params[0] = (GLdouble) g->pixel.scale.a;
			break;
		case GL_ALPHA_TEST:
			params[0] = (GLdouble) g->buffer.alphaTest;
			break;
		case GL_ALPHA_TEST_FUNC:
			params[0] = (GLdouble) g->buffer.alphaTestFunc;
			break;
		case GL_ALPHA_TEST_REF:
			params[0] = (GLdouble) g->buffer.alphaTestRef;
			break;
		case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
			params[0] = (GLdouble) g->client.array.lockCount;
			break;
		case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
			params[0] = (GLdouble) g->client.array.lockFirst;
			break;
		case GL_ATTRIB_STACK_DEPTH:
			params[0] = (GLdouble) g->attrib.attribStackDepth;
			break;
		case GL_AUTO_NORMAL:
			params[0] = (GLdouble) g->eval.autoNormal;
			break;
		case GL_AUX_BUFFERS:
			params[0] = (GLdouble) g->limits.auxBuffers;
			break;
		case GL_BLEND:
			params[0] = (GLdouble) g->buffer.blend;
			break;
		case GL_BLEND_DST:
			params[0] = (GLdouble) g->buffer.blendDstRGB;
			break;
		case GL_BLEND_SRC:
			params[0] = (GLdouble) g->buffer.blendSrcRGB;
			break;
		case GL_BLUE_BIAS:
			params[0] = (GLdouble) g->pixel.bias.b;
			break;
		case GL_BLUE_BITS:
			params[0] = (GLdouble) g->limits.blueBits;
			break;
		case GL_BLUE_SCALE:
			params[0] = (GLdouble) g->pixel.scale.b;
			break;
		case GL_CLIENT_ACTIVE_TEXTURE_ARB:
			params[0] = (GLdouble) g->client.curClientTextureUnit+GL_TEXTURE0_ARB;
			break;
		case GL_CLIP_PLANE0:
			params[0] = (GLdouble) g->transform.clip[0];
			break;
		case GL_CLIP_PLANE1:
			params[0] = (GLdouble) g->transform.clip[1];
			break;
		case GL_CLIP_PLANE2:
			params[0] = (GLdouble) g->transform.clip[2];
			break;
		case GL_CLIP_PLANE3:
			params[0] = (GLdouble) g->transform.clip[3];
			break;
		case GL_CLIP_PLANE4:
			params[0] = (GLdouble) g->transform.clip[4];
			break;
		case GL_CLIP_PLANE5:
			params[0] = (GLdouble) g->transform.clip[5];
			break;
		case GL_COLOR_ARRAY:
			params[0] = (GLdouble) g->client.array.c.enabled;
			break;
		case GL_COLOR_ARRAY_SIZE:
			params[0] = (GLdouble) g->client.array.c.size;
			break;
		case GL_COLOR_ARRAY_STRIDE:
			params[0] = (GLdouble) g->client.array.c.stride;
			break;
		case GL_COLOR_ARRAY_TYPE:
			params[0] = (GLdouble) g->client.array.c.type;
			break;
		case GL_COLOR_CLEAR_VALUE:
			params[0] = (GLdouble) g->buffer.colorClearValue.r;
			params[1] = (GLdouble) g->buffer.colorClearValue.g;
			params[2] = (GLdouble) g->buffer.colorClearValue.b;
			params[3] = (GLdouble) g->buffer.colorClearValue.a;
			break;
		case GL_COLOR_LOGIC_OP:
			params[0] = (GLdouble) g->buffer.logicOp;
			break;
		case GL_COLOR_MATERIAL:
			params[0] = (GLdouble) GL_FALSE;
			break;
		case GL_COLOR_MATERIAL_FACE:
			params[0] = (GLdouble) g->lighting.colorMaterialFace;
			break;
		case GL_COLOR_MATERIAL_PARAMETER:
			params[0] = (GLdouble) g->lighting.colorMaterialMode;
			break;
		case GL_COLOR_MATRIX:
			params[0] = (GLdouble) g->transform.colorStack.top->m00;
			params[1] = (GLdouble) g->transform.colorStack.top->m01;
			params[2] = (GLdouble) g->transform.colorStack.top->m02;
			params[3] = (GLdouble) g->transform.colorStack.top->m03;
			params[4] = (GLdouble) g->transform.colorStack.top->m10;
			params[5] = (GLdouble) g->transform.colorStack.top->m11;
			params[6] = (GLdouble) g->transform.colorStack.top->m12;
			params[7] = (GLdouble) g->transform.colorStack.top->m13;
			params[8] = (GLdouble) g->transform.colorStack.top->m20;
			params[9] = (GLdouble) g->transform.colorStack.top->m21;
			params[10] = (GLdouble) g->transform.colorStack.top->m22;
			params[11] = (GLdouble) g->transform.colorStack.top->m23;
			params[12] = (GLdouble) g->transform.colorStack.top->m30;
			params[13] = (GLdouble) g->transform.colorStack.top->m31;
			params[14] = (GLdouble) g->transform.colorStack.top->m32;
			params[15] = (GLdouble) g->transform.colorStack.top->m33;
			break;
		case GL_COLOR_MATRIX_STACK_DEPTH:
			params[0] = (GLdouble) g->transform.colorStack.depth+1;
			break;
		case GL_COLOR_WRITEMASK:
			params[0] = (GLdouble) g->buffer.colorWriteMask.r;
			params[1] = (GLdouble) g->buffer.colorWriteMask.g;
			params[2] = (GLdouble) g->buffer.colorWriteMask.b;
			params[3] = (GLdouble) g->buffer.colorWriteMask.a;
			break;
		case GL_CULL_FACE:
			params[0] = (GLdouble) g->polygon.cullFace;
			break;
		case GL_CULL_FACE_MODE:
			params[0] = (GLdouble) g->polygon.cullFaceMode;
			break;
		case GL_CURRENT_COLOR:
			params[0] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_COLOR0][0];
			params[1] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_COLOR0][1];
			params[2] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_COLOR0][2];
			params[3] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_COLOR0][3];
			break;
		case GL_CURRENT_INDEX:
			params[0] = (GLdouble) g->current.colorIndex;
			break;
		case GL_CURRENT_NORMAL:
			params[0] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_NORMAL][0];
			params[1] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_NORMAL][1];
			params[2] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_NORMAL][2];
			break;
		case GL_CURRENT_RASTER_COLOR:
			params[0] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_COLOR0][0];
			params[1] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_COLOR0][1];
			params[2] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_COLOR0][2];
			params[3] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_COLOR0][3];
			break;
		case GL_CURRENT_RASTER_DISTANCE:
			params[0] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_FOG][0];
			break;
		case GL_CURRENT_RASTER_INDEX:
			params[0] = g->current.rasterIndex;
			break;
		case GL_CURRENT_RASTER_POSITION:
			params[0] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_POS][0];
			params[1] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_POS][1];
			params[2] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_POS][2];
			params[3] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_POS][3];
			break;
		case GL_CURRENT_RASTER_POSITION_VALID:
			params[0] = (GLdouble) g->current.rasterValid;
			break;
		case GL_CURRENT_RASTER_TEXTURE_COORDS:
			params[0] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_TEX0][0];
			params[1] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_TEX0][1];
			params[2] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_TEX0][2];
			params[3] = (GLdouble) g->current.rasterAttrib[VERT_ATTRIB_TEX0][3];
			break;
		case GL_CURRENT_TEXTURE_COORDS:
			params[0] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][0];
			params[1] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][1];
			params[2] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][2];
			params[3] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][3];
			break;
		case GL_DEPTH_BIAS:
			params[0] = (GLdouble) g->pixel.depthBias;
			break;
		case GL_DEPTH_BITS:
			params[0] = (GLdouble) g->limits.depthBits;
			break;
		case GL_DEPTH_CLEAR_VALUE:
			params[0] = g->buffer.depthClearValue;
			break;
		case GL_DEPTH_FUNC:
			params[0] = (GLdouble) g->buffer.depthFunc;
			break;
		case GL_DEPTH_RANGE:
			params[0] = g->viewport.nearClip;
			params[1] = g->viewport.farClip;
			break;
		case GL_DEPTH_SCALE:
			params[0] = (GLdouble) g->pixel.depthScale;
			break;
		case GL_DEPTH_TEST:
			params[0] = (GLdouble) g->buffer.depthTest;
			break;
		case GL_DEPTH_WRITEMASK:
			params[0] = (GLdouble) g->buffer.depthMask;
			break;
		case GL_DITHER:
			params[0] = (GLdouble) g->buffer.dither;
			break;
		case GL_DOUBLEBUFFER:
			params[0] = (GLdouble) g->limits.doubleBuffer;
			break;
		case GL_DRAW_BUFFER:
			params[0] = (GLdouble) __getDrawBuffer(g);
			break;
		case GL_EDGE_FLAG:
			params[0] = (GLdouble) g->current.edgeFlag;
			break;
		case GL_EDGE_FLAG_ARRAY:
			params[0] = (GLdouble) g->client.array.e.enabled;
			break;
		case GL_EDGE_FLAG_ARRAY_STRIDE:
			params[0] = (GLdouble) g->client.array.e.stride;
			break;
		case GL_FEEDBACK_BUFFER_SIZE:
			params[0] = (GLdouble) g->feedback.bufferSize;
			break;
		case GL_FEEDBACK_BUFFER_TYPE:
			params[0] = (GLdouble) g->feedback.type;
			break;
		case GL_FOG:
			params[0] = (GLdouble) g->fog.enable;
			break;
		case GL_FOG_COLOR:
			params[0] = (GLdouble) g->fog.color.r;
			params[1] = (GLdouble) g->fog.color.g;
			params[2] = (GLdouble) g->fog.color.b;
			params[3] = (GLdouble) g->fog.color.a;
			break;
		case GL_FOG_DENSITY:
			params[0] = (GLdouble) g->fog.density;
			break;
		case GL_FOG_END:
			params[0] = (GLdouble) g->fog.end;
			break;
		case GL_FOG_HINT:
			params[0] = (GLdouble) g->hint.fog;
			break;
		case GL_FOG_INDEX:
			params[0] = (GLdouble) g->fog.index;
			break;
		case GL_FOG_MODE:
			params[0] = (GLdouble) g->fog.mode;
			break;
		case GL_FOG_START:
			params[0] = (GLdouble) g->fog.start;
			break;
		case GL_FRAMEBUFFER_BINDING_EXT:
			params[0] = (GLdouble) (g->framebufferobject.drawFB?g->framebufferobject.drawFB->id:0);
			break;
		case GL_FRONT_FACE:
			params[0] = (GLdouble) g->polygon.frontFace;
			break;
		case GL_GREEN_BIAS:
			params[0] = (GLdouble) g->pixel.bias.g;
			break;
		case GL_GREEN_BITS:
			params[0] = (GLdouble) g->limits.greenBits;
			break;
		case GL_GREEN_SCALE:
			params[0] = (GLdouble) g->pixel.scale.g;
			break;
		case GL_INDEX_ARRAY:
			params[0] = (GLdouble) g->client.array.i.enabled;
			break;
		case GL_INDEX_ARRAY_STRIDE:
			params[0] = (GLdouble) g->client.array.i.stride;
			break;
		case GL_INDEX_ARRAY_TYPE:
			params[0] = (GLdouble) g->client.array.i.type;
			break;
		case GL_INDEX_BITS:
			params[0] = (GLdouble) g->limits.indexBits;
			break;
		case GL_INDEX_CLEAR_VALUE:
			params[0] = (GLdouble) g->buffer.indexClearValue;
			break;
		case GL_INDEX_LOGIC_OP:
			params[0] = (GLdouble) g->buffer.indexLogicOp;
			break;
		case GL_INDEX_MODE:
			params[0] = (GLdouble) (!g->limits.rgbaMode);
			break;
		case GL_INDEX_OFFSET:
			params[0] = (GLdouble) g->pixel.indexOffset;
			break;
		case GL_INDEX_SHIFT:
			params[0] = (GLdouble) g->pixel.indexShift;
			break;
		case GL_INDEX_WRITEMASK:
			params[0] = (GLdouble) g->buffer.indexWriteMask;
			break;
		case GL_LIGHT0:
			params[0] = (GLdouble) g->lighting.light[0].enable;
			break;
		case GL_LIGHT1:
			params[0] = (GLdouble) g->lighting.light[1].enable;
			break;
		case GL_LIGHT2:
			params[0] = (GLdouble) g->lighting.light[2].enable;
			break;
		case GL_LIGHT3:
			params[0] = (GLdouble) g->lighting.light[3].enable;
			break;
		case GL_LIGHT4:
			params[0] = (GLdouble) g->lighting.light[4].enable;
			break;
		case GL_LIGHT5:
			params[0] = (GLdouble) g->lighting.light[5].enable;
			break;
		case GL_LIGHT6:
			params[0] = (GLdouble) g->lighting.light[6].enable;
			break;
		case GL_LIGHT7:
			params[0] = (GLdouble) g->lighting.light[7].enable;
			break;
		case GL_LIGHTING:
			params[0] = (GLdouble) g->lighting.lighting;
			break;
		case GL_LIGHT_MODEL_AMBIENT:
			params[0] = (GLdouble) g->lighting.lightModelAmbient.r;
			params[1] = (GLdouble) g->lighting.lightModelAmbient.g;
			params[2] = (GLdouble) g->lighting.lightModelAmbient.b;
			params[3] = (GLdouble) g->lighting.lightModelAmbient.a;
			break;
		case GL_LIGHT_MODEL_LOCAL_VIEWER:
			params[0] = (GLdouble) g->lighting.lightModelLocalViewer;
			break;
		case GL_LIGHT_MODEL_TWO_SIDE:
			params[0] = (GLdouble) g->lighting.lightModelTwoSide;
			break;
		case GL_LINE_SMOOTH:
			params[0] = (GLdouble) g->line.lineSmooth;
			break;
		case GL_LINE_SMOOTH_HINT:
			params[0] = (GLdouble) g->hint.lineSmooth;
			break;
		case GL_LINE_STIPPLE:
			params[0] = (GLdouble) g->line.lineStipple;
			break;
		case GL_LINE_STIPPLE_PATTERN:
			params[0] = (GLdouble) g->line.pattern;
			break;
		case GL_LINE_STIPPLE_REPEAT:
			params[0] = (GLdouble) g->line.repeat;
			break;
		case GL_LINE_WIDTH:
			params[0] = (GLdouble) g->line.width;
			break;
		case GL_LIST_BASE:
			params[0] = (GLdouble) g->lists.base;
			break;
		case GL_LIST_INDEX:
			params[0] = (GLdouble) g->lists.currentIndex;
			break;
		case GL_LIST_MODE:
			params[0] = (GLdouble) g->lists.mode;
			break;
		case GL_LOGIC_OP_MODE:
			params[0] = (GLdouble) g->buffer.logicOpMode;
			break;
		case GL_MAP1_COLOR_4:
			params[0] = (GLdouble) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_GRID_DOMAIN:
			params[0] = g->eval.u11D;
			params[1] = g->eval.u21D;
			break;
		case GL_MAP1_GRID_SEGMENTS:
			params[0] = (GLdouble) g->eval.un1D;
			break;
		case GL_MAP1_INDEX:
			params[0] = (GLdouble) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_NORMAL:
			params[0] = (GLdouble) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_TEXTURE_COORD_1:
			params[0] = (GLdouble) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_TEXTURE_COORD_2:
			params[0] = (GLdouble) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_TEXTURE_COORD_3:
			params[0] = (GLdouble) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_TEXTURE_COORD_4:
			params[0] = (GLdouble) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_VERTEX_3:
			params[0] = (GLdouble) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_VERTEX_4:
			params[0] = (GLdouble) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP2_COLOR_4:
			params[0] = (GLdouble) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_GRID_DOMAIN:
			params[0] = g->eval.u12D;
			params[1] = g->eval.u22D;
			params[2] = g->eval.v12D;
			params[3] = g->eval.v22D;
			break;
		case GL_MAP2_GRID_SEGMENTS:
			params[0] = (GLdouble) g->eval.un2D;
			params[1] = (GLdouble) g->eval.vn2D;
			break;
		case GL_MAP2_INDEX:
			params[0] = (GLdouble) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_NORMAL:
			params[0] = (GLdouble) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_TEXTURE_COORD_1:
			params[0] = (GLdouble) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_TEXTURE_COORD_2:
			params[0] = (GLdouble) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_TEXTURE_COORD_3:
			params[0] = (GLdouble) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_TEXTURE_COORD_4:
			params[0] = (GLdouble) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_VERTEX_3:
			params[0] = (GLdouble) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_VERTEX_4:
			params[0] = (GLdouble) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP_COLOR:
			params[0] = (GLdouble) g->pixel.mapColor;
			break;
		case GL_MAP_STENCIL:
			params[0] = (GLdouble) g->pixel.mapStencil;
			break;
		case GL_MATRIX_MODE:
			params[0] = (GLdouble) g->transform.matrixMode;
			break;
		case GL_MAX_3D_TEXTURE_SIZE:
			params[0] = (GLdouble) g->limits.max3DTextureSize;
			break;
		case GL_MAX_ATTRIB_STACK_DEPTH:
			params[0] = (GLdouble) g->limits.maxAttribStackDepth;
			break;
		case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
			params[0] = (GLdouble) g->limits.maxClientAttribStackDepth;
			break;
		case GL_MAX_CLIP_PLANES:
			params[0] = (GLdouble) g->limits.maxClipPlanes;
			break;
		case GL_MAX_COLOR_MATRIX_STACK_DEPTH:
			params[0] = (GLdouble) g->limits.maxColorStackDepth;
			break;
		case GL_MAX_ELEMENTS_INDICES:
			params[0] = (GLdouble) g->limits.maxElementsIndices;
			break;
		case GL_MAX_ELEMENTS_VERTICES:
			params[0] = (GLdouble) g->limits.maxElementsVertices;
			break;
		case GL_MAX_EVAL_ORDER:
			params[0] = (GLdouble) g->limits.maxEvalOrder;
			break;
		case GL_MAX_LIGHTS:
			params[0] = (GLdouble) g->limits.maxLights;
			break;
		case GL_MAX_LIST_NESTING:
			params[0] = (GLdouble) g->limits.maxListNesting;
			break;
		case GL_MAX_MODELVIEW_STACK_DEPTH:
			params[0] = (GLdouble) g->limits.maxModelviewStackDepth;
			break;
		case GL_MAX_NAME_STACK_DEPTH:
			params[0] = (GLdouble) g->limits.maxNameStackDepth;
			break;
		case GL_MAX_PIXEL_MAP_TABLE:
			params[0] = (GLdouble) g->limits.maxPixelMapTable;
			break;
		case GL_MAX_PROJECTION_STACK_DEPTH:
			params[0] = (GLdouble) g->limits.maxProjectionStackDepth;
			break;
		case GL_MAX_TEXTURE_SIZE:
			params[0] = (GLdouble) g->limits.maxTextureSize;
			break;
		case GL_MAX_TEXTURE_STACK_DEPTH:
			params[0] = (GLdouble) g->limits.maxTextureStackDepth;
			break;
		case GL_MAX_TEXTURE_UNITS_ARB:
			params[0] = (GLdouble) g->limits.maxTextureUnits;
			break;
		case GL_MAX_VERTEX_ATTRIBS_ARB:
			params[0] = (GLdouble) g->limits.maxVertexProgramAttribs;
			break;
		case GL_MAX_VIEWPORT_DIMS:
			params[0] = (GLdouble) g->limits.maxViewportDims[0];
			params[1] = (GLdouble) g->limits.maxViewportDims[1];
			break;
		case GL_MODELVIEW_MATRIX:
			params[0] = (GLdouble) g->transform.modelViewStack.top->m00;
			params[1] = (GLdouble) g->transform.modelViewStack.top->m01;
			params[2] = (GLdouble) g->transform.modelViewStack.top->m02;
			params[3] = (GLdouble) g->transform.modelViewStack.top->m03;
			params[4] = (GLdouble) g->transform.modelViewStack.top->m10;
			params[5] = (GLdouble) g->transform.modelViewStack.top->m11;
			params[6] = (GLdouble) g->transform.modelViewStack.top->m12;
			params[7] = (GLdouble) g->transform.modelViewStack.top->m13;
			params[8] = (GLdouble) g->transform.modelViewStack.top->m20;
			params[9] = (GLdouble) g->transform.modelViewStack.top->m21;
			params[10] = (GLdouble) g->transform.modelViewStack.top->m22;
			params[11] = (GLdouble) g->transform.modelViewStack.top->m23;
			params[12] = (GLdouble) g->transform.modelViewStack.top->m30;
			params[13] = (GLdouble) g->transform.modelViewStack.top->m31;
			params[14] = (GLdouble) g->transform.modelViewStack.top->m32;
			params[15] = (GLdouble) g->transform.modelViewStack.top->m33;
			break;
		case GL_MODELVIEW_STACK_DEPTH:
			params[0] = (GLdouble) g->transform.modelViewStack.depth+1;
			break;
		case GL_NAME_STACK_DEPTH:
			params[0] = (GLdouble) 0;
			break;
		case GL_NORMALIZE:
			params[0] = (GLdouble) g->transform.normalize;
			break;
		case GL_NORMAL_ARRAY:
			params[0] = (GLdouble) g->client.array.n.enabled;
			break;
		case GL_NORMAL_ARRAY_STRIDE:
			params[0] = (GLdouble) g->client.array.n.stride;
			break;
		case GL_NORMAL_ARRAY_TYPE:
			params[0] = (GLdouble) g->client.array.n.type;
			break;
		case GL_PACK_ALIGNMENT:
			params[0] = (GLdouble) g->client.pack.alignment;
			break;
		case GL_PACK_IMAGE_HEIGHT:
			params[0] = (GLdouble) g->client.pack.imageHeight;
			break;
		case GL_PACK_LSB_FIRST:
			params[0] = (GLdouble) g->client.pack.psLSBFirst;
			break;
		case GL_PACK_ROW_LENGTH:
			params[0] = (GLdouble) g->client.pack.rowLength;
			break;
		case GL_PACK_SKIP_IMAGES:
			params[0] = (GLdouble) g->client.pack.skipImages;
			break;
		case GL_PACK_SKIP_PIXELS:
			params[0] = (GLdouble) g->client.pack.skipPixels;
			break;
		case GL_PACK_SKIP_ROWS:
			params[0] = (GLdouble) g->client.pack.skipRows;
			break;
		case GL_PACK_SWAP_BYTES:
			params[0] = (GLdouble) g->client.pack.swapBytes;
			break;
		case GL_PERSPECTIVE_CORRECTION_HINT:
			params[0] = (GLdouble) g->hint.perspectiveCorrection;
			break;
		case GL_PIXEL_MAP_A_TO_A_SIZE:
			params[0] = (GLdouble) g->pixel.mapAtoAsize;
			break;
		case GL_PIXEL_MAP_B_TO_B_SIZE:
			params[0] = (GLdouble) g->pixel.mapBtoBsize;
			break;
		case GL_PIXEL_MAP_G_TO_G_SIZE:
			params[0] = (GLdouble) g->pixel.mapGtoGsize;
			break;
		case GL_PIXEL_MAP_I_TO_A_SIZE:
			params[0] = (GLdouble) g->pixel.mapItoAsize;
			break;
		case GL_PIXEL_MAP_I_TO_B_SIZE:
			params[0] = (GLdouble) g->pixel.mapItoBsize;
			break;
		case GL_PIXEL_MAP_I_TO_G_SIZE:
			params[0] = (GLdouble) g->pixel.mapItoGsize;
			break;
		case GL_PIXEL_MAP_I_TO_I_SIZE:
			params[0] = (GLdouble) g->pixel.mapItoIsize;
			break;
		case GL_PIXEL_MAP_I_TO_R_SIZE:
			params[0] = (GLdouble) g->pixel.mapItoRsize;
			break;
		case GL_PIXEL_MAP_R_TO_R_SIZE:
			params[0] = (GLdouble) g->pixel.mapRtoRsize;
			break;
		case GL_PIXEL_MAP_S_TO_S_SIZE:
			params[0] = (GLdouble) g->pixel.mapStoSsize;
			break;
		case GL_POINT_DISTANCE_ATTENUATION_ARB:
			params[0] = (GLdouble) g->point.distanceAttenuation[0];
			params[1] = (GLdouble) g->point.distanceAttenuation[1];
			params[2] = (GLdouble) g->point.distanceAttenuation[2];
			break;
		case GL_POINT_FADE_THRESHOLD_SIZE_ARB:
			params[0] = (GLdouble) g->point.fadeThresholdSize;
			break;
		case GL_POINT_SIZE:
			params[0] = (GLdouble) g->point.pointSize;
			break;
		case GL_POINT_SIZE_MAX_ARB:
			params[0] = (GLdouble) g->point.maxSize;
			break;
		case GL_POINT_SIZE_MIN_ARB:
			params[0] = (GLdouble) g->point.minSize;
			break;
		case GL_POINT_SMOOTH:
			params[0] = (GLdouble) g->point.pointSmooth;
			break;
		case GL_POINT_SMOOTH_HINT:
			params[0] = (GLdouble) g->hint.pointSmooth;
			break;
		case GL_POINT_SPRITE_COORD_ORIGIN:
			params[0] = (GLdouble) g->point.spriteCoordOrigin;
			break;
		case GL_POLYGON_MODE:
			params[0] = (GLdouble) g->polygon.frontMode;
			params[1] = (GLdouble) g->polygon.backMode;
			break;
		case GL_POLYGON_OFFSET_FACTOR:
			params[0] = (GLdouble) g->polygon.offsetFactor;
			break;
		case GL_POLYGON_OFFSET_FILL:
			params[0] = (GLdouble) g->polygon.polygonOffsetFill;
			break;
		case GL_POLYGON_OFFSET_LINE:
			params[0] = (GLdouble) g->polygon.polygonOffsetLine;
			break;
		case GL_POLYGON_OFFSET_POINT:
			params[0] = (GLdouble) g->polygon.polygonOffsetPoint;
			break;
		case GL_POLYGON_OFFSET_UNITS:
			params[0] = (GLdouble) g->polygon.offsetUnits;
			break;
		case GL_POLYGON_SMOOTH:
			params[0] = (GLdouble) g->polygon.polygonSmooth;
			break;
		case GL_POLYGON_SMOOTH_HINT:
			params[0] = (GLdouble) g->hint.polygonSmooth;
			break;
		case GL_POLYGON_STIPPLE:
			params[0] = (GLdouble) g->polygon.polygonStipple;
			break;
		case GL_PROJECTION_MATRIX:
			params[0] = (GLdouble) g->transform.projectionStack.top->m00;
			params[1] = (GLdouble) g->transform.projectionStack.top->m01;
			params[2] = (GLdouble) g->transform.projectionStack.top->m02;
			params[3] = (GLdouble) g->transform.projectionStack.top->m03;
			params[4] = (GLdouble) g->transform.projectionStack.top->m10;
			params[5] = (GLdouble) g->transform.projectionStack.top->m11;
			params[6] = (GLdouble) g->transform.projectionStack.top->m12;
			params[7] = (GLdouble) g->transform.projectionStack.top->m13;
			params[8] = (GLdouble) g->transform.projectionStack.top->m20;
			params[9] = (GLdouble) g->transform.projectionStack.top->m21;
			params[10] = (GLdouble) g->transform.projectionStack.top->m22;
			params[11] = (GLdouble) g->transform.projectionStack.top->m23;
			params[12] = (GLdouble) g->transform.projectionStack.top->m30;
			params[13] = (GLdouble) g->transform.projectionStack.top->m31;
			params[14] = (GLdouble) g->transform.projectionStack.top->m32;
			params[15] = (GLdouble) g->transform.projectionStack.top->m33;
			break;
		case GL_PROJECTION_STACK_DEPTH:
			params[0] = (GLdouble) g->transform.projectionStack.depth+1;
			break;
		case GL_READ_BUFFER:
			params[0] = (GLdouble) __getReadBuffer(g);
			break;
		case GL_READ_FRAMEBUFFER_BINDING:
			params[0] = (GLdouble) (g->framebufferobject.readFB?g->framebufferobject.readFB->id:0);
			break;
		case GL_RED_BIAS:
			params[0] = (GLdouble) g->pixel.bias.r;
			break;
		case GL_RED_BITS:
			params[0] = (GLdouble) g->limits.redBits;
			break;
		case GL_RED_SCALE:
			params[0] = (GLdouble) g->pixel.scale.r;
			break;
		case GL_RENDERBUFFER_BINDING_EXT:
			params[0] = (GLdouble) (g->framebufferobject.renderbuffer?g->framebufferobject.renderbuffer->id:0);
			break;
		case GL_RENDER_MODE:
			params[0] = (GLdouble) g->renderMode;
			break;
		case GL_RGBA_MODE:
			params[0] = (GLdouble) g->limits.rgbaMode;
			break;
		case GL_SCISSOR_BOX:
			params[0] = (GLdouble) g->viewport.scissorX;
			params[1] = (GLdouble) g->viewport.scissorY;
			params[2] = (GLdouble) g->viewport.scissorW;
			params[3] = (GLdouble) g->viewport.scissorH;
			break;
		case GL_SCISSOR_TEST:
			params[0] = (GLdouble) g->viewport.scissorTest;
			break;
		case GL_SELECTION_BUFFER_SIZE:
			params[0] = (GLdouble) g->selection.bufferSize;
			break;
		case GL_SHADE_MODEL:
			params[0] = (GLdouble) g->lighting.shadeModel;
			break;
		case GL_SMOOTH_LINE_WIDTH_GRANULARITY:
			params[0] = (GLdouble) g->limits.lineWidthGranularity;
			break;
		case GL_SMOOTH_LINE_WIDTH_RANGE:
			params[0] = (GLdouble) g->limits.smoothLineWidthRange[0];
			params[1] = (GLdouble) g->limits.smoothLineWidthRange[1];
			break;
		case GL_SMOOTH_POINT_SIZE_GRANULARITY:
			params[0] = (GLdouble) g->limits.pointSizeGranularity;
			break;
		case GL_SMOOTH_POINT_SIZE_RANGE:
			params[0] = (GLdouble) g->limits.smoothPointSizeRange[0];
			params[1] = (GLdouble) g->limits.smoothPointSizeRange[1];
			break;
		case GL_STENCIL_BACK_FAIL:
			params[0] = (GLdouble) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].fail;
			break;
		case GL_STENCIL_BACK_FUNC:
			params[0] = (GLdouble) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].func;
			break;
		case GL_STENCIL_BACK_PASS_DEPTH_FAIL:
			params[0] = (GLdouble) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthFail;
			break;
		case GL_STENCIL_BACK_PASS_DEPTH_PASS:
			params[0] = (GLdouble) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthPass;
			break;
		case GL_STENCIL_BACK_REF:
			params[0] = (GLdouble) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].ref;
			break;
		case GL_STENCIL_BACK_VALUE_MASK:
			params[0] = (GLdouble) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].mask;
			break;
		case GL_STENCIL_BITS:
			params[0] = (GLdouble) g->limits.stencilBits;
			break;
		case GL_STENCIL_CLEAR_VALUE:
			params[0] = (GLdouble) g->stencil.clearValue;
			break;
		case GL_STENCIL_FAIL:
			params[0] = (GLdouble) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].fail;
			break;
		case GL_STENCIL_FUNC:
			params[0] = (GLdouble) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].func;
			break;
		case GL_STENCIL_PASS_DEPTH_FAIL:
			params[0] = (GLdouble) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthFail;
			break;
		case GL_STENCIL_PASS_DEPTH_PASS:
			params[0] = (GLdouble) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthPass;
			break;
		case GL_STENCIL_REF:
			params[0] = (GLdouble) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].ref;
			break;
		case GL_STENCIL_TEST:
			params[0] = (GLdouble) g->stencil.stencilTest;
			break;
		case GL_STENCIL_VALUE_MASK:
			params[0] = (GLdouble) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].mask;
			break;
		case GL_STENCIL_WRITEMASK:
			params[0] = (GLdouble) g->stencil.writeMask;
			break;
		case GL_STEREO:
			params[0] = (GLdouble) g->limits.stereo;
			break;
		case GL_SUBPIXEL_BITS:
			params[0] = (GLdouble) g->limits.subpixelBits;
			break;
		case GL_TEXTURE_1D:
			params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].enabled1D;
			break;
		case GL_TEXTURE_2D:
			params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].enabled2D;
			break;
		case GL_TEXTURE_3D:
			params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].enabled3D;
			break;
		case GL_TEXTURE_BINDING_1D:
			params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].currentTexture1D->id;
			break;
		case GL_TEXTURE_BINDING_2D:
			params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].currentTexture2D->id;
			break;
		case GL_TEXTURE_BINDING_3D:
			params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].currentTexture3D->id;
			break;
		case GL_TEXTURE_COORD_ARRAY:
			params[0] = (GLdouble) g->client.array.t[g->client.curClientTextureUnit].enabled;
			break;
		case GL_TEXTURE_COORD_ARRAY_SIZE:
			params[0] = (GLdouble) g->client.array.t[g->client.curClientTextureUnit].size;
			break;
		case GL_TEXTURE_COORD_ARRAY_STRIDE:
			params[0] = (GLdouble) g->client.array.t[g->client.curClientTextureUnit].stride;
			break;
		case GL_TEXTURE_COORD_ARRAY_TYPE:
			params[0] = (GLdouble) g->client.array.t[g->client.curClientTextureUnit].type;
			break;
		case GL_TEXTURE_ENV_MODE:
			params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].envMode;
			break;
		case GL_TEXTURE_GEN_Q:
			params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].textureGen.q;
			break;
		case GL_TEXTURE_GEN_R:
			params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].textureGen.r;
			break;
		case GL_TEXTURE_GEN_S:
			params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].textureGen.s;
			break;
		case GL_TEXTURE_GEN_T:
			params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].textureGen.t;
			break;
		case GL_TEXTURE_MATRIX:
			params[0] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m00;
			params[1] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m01;
			params[2] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m02;
			params[3] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m03;
			params[4] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m10;
			params[5] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m11;
			params[6] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m12;
			params[7] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m13;
			params[8] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m20;
			params[9] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m21;
			params[10] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m22;
			params[11] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m23;
			params[12] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m30;
			params[13] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m31;
			params[14] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m32;
			params[15] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m33;
			break;
		case GL_TEXTURE_STACK_DEPTH:
			params[0] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].depth+1;
			break;
		case GL_UNPACK_ALIGNMENT:
			params[0] = (GLdouble) g->client.unpack.alignment;
			break;
		case GL_UNPACK_IMAGE_HEIGHT:
			params[0] = (GLdouble) g->client.unpack.imageHeight;
			break;
		case GL_UNPACK_LSB_FIRST:
			params[0] = (GLdouble) g->client.unpack.psLSBFirst;
			break;
		case GL_UNPACK_ROW_LENGTH:
			params[0] = (GLdouble) g->client.unpack.rowLength;
			break;
		case GL_UNPACK_SKIP_IMAGES:
			params[0] = (GLdouble) g->client.unpack.skipImages;
			break;
		case GL_UNPACK_SKIP_PIXELS:
			params[0] = (GLdouble) g->client.unpack.skipPixels;
			break;
		case GL_UNPACK_SKIP_ROWS:
			params[0] = (GLdouble) g->client.unpack.skipRows;
			break;
		case GL_UNPACK_SWAP_BYTES:
			params[0] = (GLdouble) g->client.unpack.swapBytes;
			break;
		case GL_VERTEX_ARRAY:
			params[0] = (GLdouble) g->client.array.v.enabled;
			break;
		case GL_VERTEX_ARRAY_SIZE:
			params[0] = (GLdouble) g->client.array.v.size;
			break;
		case GL_VERTEX_ARRAY_STRIDE:
			params[0] = (GLdouble) g->client.array.v.stride;
			break;
		case GL_VERTEX_ARRAY_TYPE:
			params[0] = (GLdouble) g->client.array.v.type;
			break;
		case GL_VIEWPORT:
			params[0] = (GLdouble) g->viewport.viewportX;
			params[1] = (GLdouble) g->viewport.viewportY;
			params[2] = (GLdouble) g->viewport.viewportW;
			params[3] = (GLdouble) g->viewport.viewportH;
			break;
		case GL_ZOOM_X:
			params[0] = (GLdouble) g->pixel.xZoom;
			break;
		case GL_ZOOM_Y:
			params[0] = (GLdouble) g->pixel.yZoom;
			break;
#ifdef CR_ARB_vertex_buffer_object
		case GL_ARRAY_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_vertex_buffer_object) {
				params[0] = (GLdouble) g->bufferobject.arrayBuffer->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_EXT_blend_color
		case GL_BLEND_COLOR_EXT:
			if (g->extensions.EXT_blend_color) {
				params[0] = (GLdouble) g->buffer.blendColor.r;
				params[1] = (GLdouble) g->buffer.blendColor.g;
				params[2] = (GLdouble) g->buffer.blendColor.b;
				params[3] = (GLdouble) g->buffer.blendColor.a;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_blend_color */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_DST_ALPHA_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLdouble) g->buffer.blendDstA;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_DST_RGB_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLdouble) g->buffer.blendDstRGB;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_minmax
		case GL_BLEND_EQUATION_EXT:
			if (g->extensions.EXT_blend_minmax) {
				params[0] = (GLdouble) g->buffer.blendEquation;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_blend_minmax */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_SRC_ALPHA_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLdouble) g->buffer.blendSrcA;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_SRC_RGB_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLdouble) g->buffer.blendSrcRGB;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_NV_register_combiners
		case GL_COLOR_SUM_CLAMP_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLdouble) g->regcombiner.colorSumClamp;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_EXT_secondary_color
		case GL_COLOR_SUM_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLdouble) g->lighting.colorSumEXT;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_ARB_texture_compression
		case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
			if (g->extensions.ARB_texture_compression) {
				params[0] = (GLdouble) g->limits.compressedFormats[0];
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_texture_compression */
#ifdef CR_NV_register_combiners
		case GL_CONSTANT_COLOR0_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLdouble) g->regcombiner.constantColor0.r;
				params[1] = (GLdouble) g->regcombiner.constantColor0.g;
				params[2] = (GLdouble) g->regcombiner.constantColor0.b;
				params[3] = (GLdouble) g->regcombiner.constantColor0.a;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
		case GL_CONSTANT_COLOR1_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLdouble) g->regcombiner.constantColor1.r;
				params[1] = (GLdouble) g->regcombiner.constantColor1.g;
				params[2] = (GLdouble) g->regcombiner.constantColor1.b;
				params[3] = (GLdouble) g->regcombiner.constantColor1.a;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_EXT_fog_coord
		case GL_CURRENT_FOG_COORDINATE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_FOG][0];
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_secondary_color
		case GL_CURRENT_SECONDARY_COLOR_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_COLOR1][0];
				params[1] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_COLOR1][1];
				params[2] = (GLdouble) g->current.vertexAttrib[VERT_ATTRIB_COLOR1][2];
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_ARB_vertex_buffer_object
		case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_vertex_buffer_object) {
				params[0] = (GLdouble) g->bufferobject.elementsBuffer->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_ARRAY_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLdouble) g->client.array.f.enabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLdouble) g->client.array.f.stride;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLdouble) g->client.array.f.type;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_SOURCE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLdouble) g->fog.fogCoordinateSource;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_NV_fog_distance
		case GL_FOG_DISTANCE_MODE_NV:
			if (g->extensions.NV_fog_distance) {
				params[0] = (GLdouble) g->fog.fogDistanceMode;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_fog_distance */
#ifdef CR_ARB_fragment_program
		case GL_FRAGMENT_PROGRAM_ARB:
			if (g->extensions.ARB_fragment_program) {
				params[0] = (GLdouble) g->program.fpEnabledARB;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_fragment_program */
#ifdef CR_NV_fragment_program
		case GL_FRAGMENT_PROGRAM_BINDING_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLdouble) g->program.fpProgramBinding;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_fragment_program
		case GL_FRAGMENT_PROGRAM_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLdouble) g->program.fpEnabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_SGIS_generate_mipmap
		case GL_GENERATE_MIPMAP_HINT:
			if (g->extensions.SGIS_generate_mipmap) {
				params[0] = (GLdouble) g->hint.generateMipmap;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_SGIS_generate_mipmap */
#ifdef CR_OPENGL_VERSION_1_2
		case GL_LIGHT_MODEL_COLOR_CONTROL:
			params[0] = (GLdouble) g->lighting.lightModelColorControlEXT;
			break;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_EXT_separate_specular_color
		case GL_LIGHT_MODEL_COLOR_CONTROL_EXT:
			if (g->extensions.EXT_separate_specular_color) {
				params[0] = (GLdouble) g->lighting.lightModelColorControlEXT;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_separate_specular_color */
#ifdef CR_ARB_texture_cube_map
		case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
			if (g->extensions.ARB_texture_cube_map) {
				params[0] = (GLdouble) g->limits.maxCubeMapTextureSize;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_fragment_program
		case GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLdouble) g->limits.maxFragmentProgramLocalParams;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_register_combiners
		case GL_MAX_GENERAL_COMBINERS_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLdouble) g->limits.maxGeneralCombiners;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_texture_rectangle
		case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
			if (g->extensions.NV_texture_rectangle) {
				params[0] = (GLdouble) g->limits.maxRectTextureSize;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_NV_fragment_program
		case GL_MAX_TEXTURE_COORDS_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLdouble) g->limits.maxTextureCoords;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_fragment_program
		case GL_MAX_TEXTURE_IMAGE_UNITS_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLdouble) g->limits.maxTextureImageUnits;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_EXT_texture_lod_bias
		case GL_MAX_TEXTURE_LOD_BIAS_EXT:
			if (g->extensions.EXT_texture_lod_bias) {
				params[0] = (GLdouble) g->limits.maxTextureLodBias;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_texture_lod_bias */
#ifdef CR_EXT_texture_filter_anisotropic
		case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
			if (g->extensions.EXT_texture_filter_anisotropic) {
				params[0] = (GLdouble) g->limits.maxTextureAnisotropy;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_texture_filter_anisotropic */
#ifdef CR_ARB_multisample
		case GL_MULTISAMPLE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLdouble) g->multisample.enabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_texture_compression
		case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
			if (g->extensions.ARB_texture_compression) {
				params[0] = (GLdouble) g->limits.numCompressedFormats;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_texture_compression */
#ifdef CR_NV_register_combiners
		case GL_NUM_GENERAL_COMBINERS_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLdouble) g->regcombiner.numGeneralCombiners;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners2
		case GL_PER_STAGE_CONSTANTS_NV:
			if (g->extensions.NV_register_combiners2) {
				params[0] = (GLdouble) g->regcombiner.enabledPerStageConstants;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_register_combiners2 */
#ifdef CR_ARB_pixel_buffer_object
		case GL_PIXEL_PACK_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_pixel_buffer_object) {
				params[0] = (GLdouble) g->bufferobject.packBuffer->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_pixel_buffer_object */
#ifdef CR_ARB_pixel_buffer_object
		case GL_PIXEL_UNPACK_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_pixel_buffer_object) {
				params[0] = (GLdouble) g->bufferobject.unpackBuffer->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_pixel_buffer_object */
#ifdef CR_ARB_point_sprite
		case GL_POINT_SPRITE_ARB:
			if (g->extensions.ARB_point_sprite) {
				params[0] = (GLdouble) g->point.pointSprite;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_point_sprite */
#ifdef CR_any_program
		case GL_PROGRAM_ERROR_POSITION_NV:
			if (g->extensions.any_program) {
				params[0] = (GLdouble) g->program.errorPos;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_any_program */
#ifdef CR_NV_register_combiners
		case GL_REGISTER_COMBINERS_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLdouble) g->regcombiner.enabledRegCombiners;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_OPENGL_VERSION_1_2
		case GL_RESCALE_NORMAL:
			params[0] = (GLdouble) g->transform.rescaleNormals;
			break;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_ARB_multisample
		case GL_SAMPLES_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLdouble) g->limits.samples;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLdouble) g->multisample.sampleAlphaToCoverage;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_ALPHA_TO_ONE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLdouble) g->multisample.sampleAlphaToOne;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_BUFFERS_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLdouble) g->limits.sampleBuffers;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_COVERAGE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLdouble) g->multisample.sampleCoverage;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_COVERAGE_INVERT_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLdouble) g->multisample.sampleCoverageInvert;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_COVERAGE_VALUE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLdouble) g->multisample.sampleCoverageValue;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLdouble) g->client.array.s.enabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLdouble) g->client.array.s.size;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLdouble) g->client.array.s.stride;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLdouble) g->client.array.s.type;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_ARB_texture_cube_map
		case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
			if (g->extensions.ARB_texture_cube_map) {
				params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].currentTextureCubeMap->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_texture_rectangle
		case GL_TEXTURE_BINDING_RECTANGLE_NV:
			if (g->extensions.NV_texture_rectangle) {
				params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].currentTextureRect->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_ARB_texture_compression
		case GL_TEXTURE_COMPRESSION_HINT_ARB:
			if (g->extensions.ARB_texture_compression) {
				params[0] = (GLdouble) g->hint.textureCompression;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_texture_compression */
#ifdef CR_ARB_texture_cube_map
		case GL_TEXTURE_CUBE_MAP_ARB:
			if (g->extensions.ARB_texture_cube_map) {
				params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].enabledCubeMap;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_texture_rectangle
		case GL_TEXTURE_RECTANGLE_NV:
			if (g->extensions.NV_texture_rectangle) {
				params[0] = (GLdouble) g->texture.unit[g->texture.curTextureUnit].enabledRect;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_ARB_transpose_matrix
		case GL_TRANSPOSE_MODELVIEW_MATRIX:
			if (g->extensions.ARB_transpose_matrix) {
				params[0] = (GLdouble) g->transform.modelViewStack.top->m00;
				params[1] = (GLdouble) g->transform.modelViewStack.top->m10;
				params[2] = (GLdouble) g->transform.modelViewStack.top->m20;
				params[3] = (GLdouble) g->transform.modelViewStack.top->m30;
				params[4] = (GLdouble) g->transform.modelViewStack.top->m01;
				params[5] = (GLdouble) g->transform.modelViewStack.top->m11;
				params[6] = (GLdouble) g->transform.modelViewStack.top->m21;
				params[7] = (GLdouble) g->transform.modelViewStack.top->m31;
				params[8] = (GLdouble) g->transform.modelViewStack.top->m02;
				params[9] = (GLdouble) g->transform.modelViewStack.top->m12;
				params[10] = (GLdouble) g->transform.modelViewStack.top->m22;
				params[11] = (GLdouble) g->transform.modelViewStack.top->m32;
				params[12] = (GLdouble) g->transform.modelViewStack.top->m03;
				params[13] = (GLdouble) g->transform.modelViewStack.top->m13;
				params[14] = (GLdouble) g->transform.modelViewStack.top->m23;
				params[15] = (GLdouble) g->transform.modelViewStack.top->m33;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_ARB_transpose_matrix
		case GL_TRANSPOSE_PROJECTION_MATRIX:
			if (g->extensions.ARB_transpose_matrix) {
				params[0] = (GLdouble) g->transform.projectionStack.top->m00;
				params[1] = (GLdouble) g->transform.projectionStack.top->m10;
				params[2] = (GLdouble) g->transform.projectionStack.top->m20;
				params[3] = (GLdouble) g->transform.projectionStack.top->m30;
				params[4] = (GLdouble) g->transform.projectionStack.top->m01;
				params[5] = (GLdouble) g->transform.projectionStack.top->m11;
				params[6] = (GLdouble) g->transform.projectionStack.top->m21;
				params[7] = (GLdouble) g->transform.projectionStack.top->m31;
				params[8] = (GLdouble) g->transform.projectionStack.top->m02;
				params[9] = (GLdouble) g->transform.projectionStack.top->m12;
				params[10] = (GLdouble) g->transform.projectionStack.top->m22;
				params[11] = (GLdouble) g->transform.projectionStack.top->m32;
				params[12] = (GLdouble) g->transform.projectionStack.top->m03;
				params[13] = (GLdouble) g->transform.projectionStack.top->m13;
				params[14] = (GLdouble) g->transform.projectionStack.top->m23;
				params[15] = (GLdouble) g->transform.projectionStack.top->m33;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_ARB_transpose_matrix
		case GL_TRANSPOSE_TEXTURE_MATRIX:
			if (g->extensions.ARB_transpose_matrix) {
				params[0] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m00;
				params[1] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m10;
				params[2] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m20;
				params[3] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m30;
				params[4] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m01;
				params[5] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m11;
				params[6] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m21;
				params[7] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m31;
				params[8] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m02;
				params[9] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m12;
				params[10] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m22;
				params[11] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m32;
				params[12] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m03;
				params[13] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m13;
				params[14] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m23;
				params[15] = (GLdouble) g->transform.textureStack[g->texture.curTextureUnit].top->m33;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_NV_vertex_program
		case GL_VERTEX_PROGRAM_BINDING_NV:
			if (g->extensions.NV_vertex_program) {
				params[0] = (GLdouble) g->program.vpProgramBinding;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_NV_vertex_program */
#ifdef CR_any_vertex_program
		case GL_VERTEX_PROGRAM_NV:
			if (g->extensions.any_vertex_program) {
				params[0] = (GLdouble) g->program.vpEnabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
		case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
			if (g->extensions.any_vertex_program) {
				params[0] = (GLdouble) g->program.vpPointSize;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
		case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
			if (g->extensions.any_vertex_program) {
				params[0] = (GLdouble) g->program.vpTwoSide;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetDoublev");
			}
			break;
#endif /* CR_any_vertex_program */
		default:
			crStateError(__LINE__, __FILE__, GL_INVALID_ENUM, "glGet: Unknown enum: 0x%x", pname);
			return;
	}
}

void STATE_APIENTRY crStateGetFloatv( GLenum pname, GLfloat *params )

{
	CRContext *g = GetCurrentContext();

	if (g->current.inBeginEnd)
	{
		crStateError(__LINE__, __FILE__, GL_INVALID_OPERATION,
			"glGet called in Begin/End");
		return;
	}

	if (pname == GL_CURRENT_INDEX || pname == GL_CURRENT_COLOR ||
		pname == GL_CURRENT_SECONDARY_COLOR_EXT ||
		pname == GL_CURRENT_FOG_COORDINATE_EXT ||
		pname == GL_CURRENT_NORMAL || pname == GL_EDGE_FLAG ||
		pname == GL_CURRENT_TEXTURE_COORDS )
	{
#if 0
		crStateError(__LINE__,__FILE__, GL_INVALID_OPERATION,
			"Unimplemented glGet of a 'current' value" );
#else
		crStateCurrentRecover();/* &g->current, &sb->current, g->bitID );*/
		
#endif
	}

	switch (pname) {

		case GL_ACCUM_ALPHA_BITS:
			params[0] = (GLfloat) g->limits.accumAlphaBits;
			break;
		case GL_ACCUM_BLUE_BITS:
			params[0] = (GLfloat) g->limits.accumBlueBits;
			break;
		case GL_ACCUM_CLEAR_VALUE:
			params[0] = g->buffer.accumClearValue.r;
			params[1] = g->buffer.accumClearValue.g;
			params[2] = g->buffer.accumClearValue.b;
			params[3] = g->buffer.accumClearValue.a;
			break;
		case GL_ACCUM_GREEN_BITS:
			params[0] = (GLfloat) g->limits.accumGreenBits;
			break;
		case GL_ACCUM_RED_BITS:
			params[0] = (GLfloat) g->limits.accumRedBits;
			break;
		case GL_ACTIVE_STENCIL_FACE_EXT:
			params[0] = (GLfloat) g->stencil.activeStencilFace;
			break;
		case GL_ACTIVE_TEXTURE_ARB:
			params[0] = (GLfloat) g->texture.curTextureUnit+GL_TEXTURE0_ARB;
			break;
		case GL_ALIASED_LINE_WIDTH_RANGE:
			params[0] = g->limits.aliasedLineWidthRange[0];
			params[1] = g->limits.aliasedLineWidthRange[1];
			break;
		case GL_ALIASED_POINT_SIZE_RANGE:
			params[0] = g->limits.aliasedPointSizeRange[0];
			params[1] = g->limits.aliasedPointSizeRange[1];
			break;
		case GL_ALPHA_BIAS:
			params[0] = g->pixel.bias.a;
			break;
		case GL_ALPHA_BITS:
			params[0] = (GLfloat) g->limits.alphaBits;
			break;
		case GL_ALPHA_SCALE:
			params[0] = g->pixel.scale.a;
			break;
		case GL_ALPHA_TEST:
			params[0] = (GLfloat) g->buffer.alphaTest;
			break;
		case GL_ALPHA_TEST_FUNC:
			params[0] = (GLfloat) g->buffer.alphaTestFunc;
			break;
		case GL_ALPHA_TEST_REF:
			params[0] = (GLfloat) g->buffer.alphaTestRef;
			break;
		case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
			params[0] = (GLfloat) g->client.array.lockCount;
			break;
		case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
			params[0] = (GLfloat) g->client.array.lockFirst;
			break;
		case GL_ATTRIB_STACK_DEPTH:
			params[0] = (GLfloat) g->attrib.attribStackDepth;
			break;
		case GL_AUTO_NORMAL:
			params[0] = (GLfloat) g->eval.autoNormal;
			break;
		case GL_AUX_BUFFERS:
			params[0] = (GLfloat) g->limits.auxBuffers;
			break;
		case GL_BLEND:
			params[0] = (GLfloat) g->buffer.blend;
			break;
		case GL_BLEND_DST:
			params[0] = (GLfloat) g->buffer.blendDstRGB;
			break;
		case GL_BLEND_SRC:
			params[0] = (GLfloat) g->buffer.blendSrcRGB;
			break;
		case GL_BLUE_BIAS:
			params[0] = g->pixel.bias.b;
			break;
		case GL_BLUE_BITS:
			params[0] = (GLfloat) g->limits.blueBits;
			break;
		case GL_BLUE_SCALE:
			params[0] = g->pixel.scale.b;
			break;
		case GL_CLIENT_ACTIVE_TEXTURE_ARB:
			params[0] = (GLfloat) g->client.curClientTextureUnit+GL_TEXTURE0_ARB;
			break;
		case GL_CLIP_PLANE0:
			params[0] = (GLfloat) g->transform.clip[0];
			break;
		case GL_CLIP_PLANE1:
			params[0] = (GLfloat) g->transform.clip[1];
			break;
		case GL_CLIP_PLANE2:
			params[0] = (GLfloat) g->transform.clip[2];
			break;
		case GL_CLIP_PLANE3:
			params[0] = (GLfloat) g->transform.clip[3];
			break;
		case GL_CLIP_PLANE4:
			params[0] = (GLfloat) g->transform.clip[4];
			break;
		case GL_CLIP_PLANE5:
			params[0] = (GLfloat) g->transform.clip[5];
			break;
		case GL_COLOR_ARRAY:
			params[0] = (GLfloat) g->client.array.c.enabled;
			break;
		case GL_COLOR_ARRAY_SIZE:
			params[0] = (GLfloat) g->client.array.c.size;
			break;
		case GL_COLOR_ARRAY_STRIDE:
			params[0] = (GLfloat) g->client.array.c.stride;
			break;
		case GL_COLOR_ARRAY_TYPE:
			params[0] = (GLfloat) g->client.array.c.type;
			break;
		case GL_COLOR_CLEAR_VALUE:
			params[0] = g->buffer.colorClearValue.r;
			params[1] = g->buffer.colorClearValue.g;
			params[2] = g->buffer.colorClearValue.b;
			params[3] = g->buffer.colorClearValue.a;
			break;
		case GL_COLOR_LOGIC_OP:
			params[0] = (GLfloat) g->buffer.logicOp;
			break;
		case GL_COLOR_MATERIAL:
			params[0] = (GLfloat) GL_FALSE;
			break;
		case GL_COLOR_MATERIAL_FACE:
			params[0] = (GLfloat) g->lighting.colorMaterialFace;
			break;
		case GL_COLOR_MATERIAL_PARAMETER:
			params[0] = (GLfloat) g->lighting.colorMaterialMode;
			break;
		case GL_COLOR_MATRIX:
			params[0] = (GLfloat) g->transform.colorStack.top->m00;
			params[1] = (GLfloat) g->transform.colorStack.top->m01;
			params[2] = (GLfloat) g->transform.colorStack.top->m02;
			params[3] = (GLfloat) g->transform.colorStack.top->m03;
			params[4] = (GLfloat) g->transform.colorStack.top->m10;
			params[5] = (GLfloat) g->transform.colorStack.top->m11;
			params[6] = (GLfloat) g->transform.colorStack.top->m12;
			params[7] = (GLfloat) g->transform.colorStack.top->m13;
			params[8] = (GLfloat) g->transform.colorStack.top->m20;
			params[9] = (GLfloat) g->transform.colorStack.top->m21;
			params[10] = (GLfloat) g->transform.colorStack.top->m22;
			params[11] = (GLfloat) g->transform.colorStack.top->m23;
			params[12] = (GLfloat) g->transform.colorStack.top->m30;
			params[13] = (GLfloat) g->transform.colorStack.top->m31;
			params[14] = (GLfloat) g->transform.colorStack.top->m32;
			params[15] = (GLfloat) g->transform.colorStack.top->m33;
			break;
		case GL_COLOR_MATRIX_STACK_DEPTH:
			params[0] = (GLfloat) g->transform.colorStack.depth+1;
			break;
		case GL_COLOR_WRITEMASK:
			params[0] = (GLfloat) g->buffer.colorWriteMask.r;
			params[1] = (GLfloat) g->buffer.colorWriteMask.g;
			params[2] = (GLfloat) g->buffer.colorWriteMask.b;
			params[3] = (GLfloat) g->buffer.colorWriteMask.a;
			break;
		case GL_CULL_FACE:
			params[0] = (GLfloat) g->polygon.cullFace;
			break;
		case GL_CULL_FACE_MODE:
			params[0] = (GLfloat) g->polygon.cullFaceMode;
			break;
		case GL_CURRENT_COLOR:
			params[0] = g->current.vertexAttrib[VERT_ATTRIB_COLOR0][0];
			params[1] = g->current.vertexAttrib[VERT_ATTRIB_COLOR0][1];
			params[2] = g->current.vertexAttrib[VERT_ATTRIB_COLOR0][2];
			params[3] = g->current.vertexAttrib[VERT_ATTRIB_COLOR0][3];
			break;
		case GL_CURRENT_INDEX:
			params[0] = g->current.colorIndex;
			break;
		case GL_CURRENT_NORMAL:
			params[0] = g->current.vertexAttrib[VERT_ATTRIB_NORMAL][0];
			params[1] = g->current.vertexAttrib[VERT_ATTRIB_NORMAL][1];
			params[2] = g->current.vertexAttrib[VERT_ATTRIB_NORMAL][2];
			break;
		case GL_CURRENT_RASTER_COLOR:
			params[0] = g->current.rasterAttrib[VERT_ATTRIB_COLOR0][0];
			params[1] = g->current.rasterAttrib[VERT_ATTRIB_COLOR0][1];
			params[2] = g->current.rasterAttrib[VERT_ATTRIB_COLOR0][2];
			params[3] = g->current.rasterAttrib[VERT_ATTRIB_COLOR0][3];
			break;
		case GL_CURRENT_RASTER_DISTANCE:
			params[0] = g->current.rasterAttrib[VERT_ATTRIB_FOG][0];
			break;
		case GL_CURRENT_RASTER_INDEX:
			params[0] = (GLfloat) g->current.rasterIndex;
			break;
		case GL_CURRENT_RASTER_POSITION:
			params[0] = g->current.rasterAttrib[VERT_ATTRIB_POS][0];
			params[1] = g->current.rasterAttrib[VERT_ATTRIB_POS][1];
			params[2] = g->current.rasterAttrib[VERT_ATTRIB_POS][2];
			params[3] = g->current.rasterAttrib[VERT_ATTRIB_POS][3];
			break;
		case GL_CURRENT_RASTER_POSITION_VALID:
			params[0] = (GLfloat) g->current.rasterValid;
			break;
		case GL_CURRENT_RASTER_TEXTURE_COORDS:
			params[0] = g->current.rasterAttrib[VERT_ATTRIB_TEX0][0];
			params[1] = g->current.rasterAttrib[VERT_ATTRIB_TEX0][1];
			params[2] = g->current.rasterAttrib[VERT_ATTRIB_TEX0][2];
			params[3] = g->current.rasterAttrib[VERT_ATTRIB_TEX0][3];
			break;
		case GL_CURRENT_TEXTURE_COORDS:
			params[0] = g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][0];
			params[1] = g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][1];
			params[2] = g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][2];
			params[3] = g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][3];
			break;
		case GL_DEPTH_BIAS:
			params[0] = g->pixel.depthBias;
			break;
		case GL_DEPTH_BITS:
			params[0] = (GLfloat) g->limits.depthBits;
			break;
		case GL_DEPTH_CLEAR_VALUE:
			params[0] = (GLfloat) g->buffer.depthClearValue;
			break;
		case GL_DEPTH_FUNC:
			params[0] = (GLfloat) g->buffer.depthFunc;
			break;
		case GL_DEPTH_RANGE:
			params[0] = (GLfloat) g->viewport.nearClip;
			params[1] = (GLfloat) g->viewport.farClip;
			break;
		case GL_DEPTH_SCALE:
			params[0] = g->pixel.depthScale;
			break;
		case GL_DEPTH_TEST:
			params[0] = (GLfloat) g->buffer.depthTest;
			break;
		case GL_DEPTH_WRITEMASK:
			params[0] = (GLfloat) g->buffer.depthMask;
			break;
		case GL_DITHER:
			params[0] = (GLfloat) g->buffer.dither;
			break;
		case GL_DOUBLEBUFFER:
			params[0] = (GLfloat) g->limits.doubleBuffer;
			break;
		case GL_DRAW_BUFFER:
			params[0] = (GLfloat) __getDrawBuffer(g);
			break;
		case GL_EDGE_FLAG:
			params[0] = (GLfloat) g->current.edgeFlag;
			break;
		case GL_EDGE_FLAG_ARRAY:
			params[0] = (GLfloat) g->client.array.e.enabled;
			break;
		case GL_EDGE_FLAG_ARRAY_STRIDE:
			params[0] = (GLfloat) g->client.array.e.stride;
			break;
		case GL_FEEDBACK_BUFFER_SIZE:
			params[0] = (GLfloat) g->feedback.bufferSize;
			break;
		case GL_FEEDBACK_BUFFER_TYPE:
			params[0] = (GLfloat) g->feedback.type;
			break;
		case GL_FOG:
			params[0] = (GLfloat) g->fog.enable;
			break;
		case GL_FOG_COLOR:
			params[0] = g->fog.color.r;
			params[1] = g->fog.color.g;
			params[2] = g->fog.color.b;
			params[3] = g->fog.color.a;
			break;
		case GL_FOG_DENSITY:
			params[0] = g->fog.density;
			break;
		case GL_FOG_END:
			params[0] = g->fog.end;
			break;
		case GL_FOG_HINT:
			params[0] = (GLfloat) g->hint.fog;
			break;
		case GL_FOG_INDEX:
			params[0] = (GLfloat) g->fog.index;
			break;
		case GL_FOG_MODE:
			params[0] = (GLfloat) g->fog.mode;
			break;
		case GL_FOG_START:
			params[0] = g->fog.start;
			break;
		case GL_FRAMEBUFFER_BINDING_EXT:
			params[0] = (GLfloat) (g->framebufferobject.drawFB?g->framebufferobject.drawFB->id:0);
			break;
		case GL_FRONT_FACE:
			params[0] = (GLfloat) g->polygon.frontFace;
			break;
		case GL_GREEN_BIAS:
			params[0] = g->pixel.bias.g;
			break;
		case GL_GREEN_BITS:
			params[0] = (GLfloat) g->limits.greenBits;
			break;
		case GL_GREEN_SCALE:
			params[0] = g->pixel.scale.g;
			break;
		case GL_INDEX_ARRAY:
			params[0] = (GLfloat) g->client.array.i.enabled;
			break;
		case GL_INDEX_ARRAY_STRIDE:
			params[0] = (GLfloat) g->client.array.i.stride;
			break;
		case GL_INDEX_ARRAY_TYPE:
			params[0] = (GLfloat) g->client.array.i.type;
			break;
		case GL_INDEX_BITS:
			params[0] = (GLfloat) g->limits.indexBits;
			break;
		case GL_INDEX_CLEAR_VALUE:
			params[0] = g->buffer.indexClearValue;
			break;
		case GL_INDEX_LOGIC_OP:
			params[0] = (GLfloat) g->buffer.indexLogicOp;
			break;
		case GL_INDEX_MODE:
			params[0] = (GLfloat) (!g->limits.rgbaMode);
			break;
		case GL_INDEX_OFFSET:
			params[0] = (GLfloat) g->pixel.indexOffset;
			break;
		case GL_INDEX_SHIFT:
			params[0] = (GLfloat) g->pixel.indexShift;
			break;
		case GL_INDEX_WRITEMASK:
			params[0] = (GLfloat) g->buffer.indexWriteMask;
			break;
		case GL_LIGHT0:
			params[0] = (GLfloat) g->lighting.light[0].enable;
			break;
		case GL_LIGHT1:
			params[0] = (GLfloat) g->lighting.light[1].enable;
			break;
		case GL_LIGHT2:
			params[0] = (GLfloat) g->lighting.light[2].enable;
			break;
		case GL_LIGHT3:
			params[0] = (GLfloat) g->lighting.light[3].enable;
			break;
		case GL_LIGHT4:
			params[0] = (GLfloat) g->lighting.light[4].enable;
			break;
		case GL_LIGHT5:
			params[0] = (GLfloat) g->lighting.light[5].enable;
			break;
		case GL_LIGHT6:
			params[0] = (GLfloat) g->lighting.light[6].enable;
			break;
		case GL_LIGHT7:
			params[0] = (GLfloat) g->lighting.light[7].enable;
			break;
		case GL_LIGHTING:
			params[0] = (GLfloat) g->lighting.lighting;
			break;
		case GL_LIGHT_MODEL_AMBIENT:
			params[0] = g->lighting.lightModelAmbient.r;
			params[1] = g->lighting.lightModelAmbient.g;
			params[2] = g->lighting.lightModelAmbient.b;
			params[3] = g->lighting.lightModelAmbient.a;
			break;
		case GL_LIGHT_MODEL_LOCAL_VIEWER:
			params[0] = (GLfloat) g->lighting.lightModelLocalViewer;
			break;
		case GL_LIGHT_MODEL_TWO_SIDE:
			params[0] = (GLfloat) g->lighting.lightModelTwoSide;
			break;
		case GL_LINE_SMOOTH:
			params[0] = (GLfloat) g->line.lineSmooth;
			break;
		case GL_LINE_SMOOTH_HINT:
			params[0] = (GLfloat) g->hint.lineSmooth;
			break;
		case GL_LINE_STIPPLE:
			params[0] = (GLfloat) g->line.lineStipple;
			break;
		case GL_LINE_STIPPLE_PATTERN:
			params[0] = (GLfloat) g->line.pattern;
			break;
		case GL_LINE_STIPPLE_REPEAT:
			params[0] = (GLfloat) g->line.repeat;
			break;
		case GL_LINE_WIDTH:
			params[0] = g->line.width;
			break;
		case GL_LIST_BASE:
			params[0] = (GLfloat) g->lists.base;
			break;
		case GL_LIST_INDEX:
			params[0] = (GLfloat) g->lists.currentIndex;
			break;
		case GL_LIST_MODE:
			params[0] = (GLfloat) g->lists.mode;
			break;
		case GL_LOGIC_OP_MODE:
			params[0] = (GLfloat) g->buffer.logicOpMode;
			break;
		case GL_MAP1_COLOR_4:
			params[0] = (GLfloat) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_GRID_DOMAIN:
			params[0] = (GLfloat) g->eval.u11D;
			params[1] = (GLfloat) g->eval.u21D;
			break;
		case GL_MAP1_GRID_SEGMENTS:
			params[0] = (GLfloat) g->eval.un1D;
			break;
		case GL_MAP1_INDEX:
			params[0] = (GLfloat) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_NORMAL:
			params[0] = (GLfloat) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_TEXTURE_COORD_1:
			params[0] = (GLfloat) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_TEXTURE_COORD_2:
			params[0] = (GLfloat) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_TEXTURE_COORD_3:
			params[0] = (GLfloat) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_TEXTURE_COORD_4:
			params[0] = (GLfloat) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_VERTEX_3:
			params[0] = (GLfloat) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_VERTEX_4:
			params[0] = (GLfloat) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP2_COLOR_4:
			params[0] = (GLfloat) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_GRID_DOMAIN:
			params[0] = (GLfloat) g->eval.u12D;
			params[1] = (GLfloat) g->eval.u22D;
			params[2] = (GLfloat) g->eval.v12D;
			params[3] = (GLfloat) g->eval.v22D;
			break;
		case GL_MAP2_GRID_SEGMENTS:
			params[0] = (GLfloat) g->eval.un2D;
			params[1] = (GLfloat) g->eval.vn2D;
			break;
		case GL_MAP2_INDEX:
			params[0] = (GLfloat) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_NORMAL:
			params[0] = (GLfloat) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_TEXTURE_COORD_1:
			params[0] = (GLfloat) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_TEXTURE_COORD_2:
			params[0] = (GLfloat) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_TEXTURE_COORD_3:
			params[0] = (GLfloat) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_TEXTURE_COORD_4:
			params[0] = (GLfloat) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_VERTEX_3:
			params[0] = (GLfloat) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_VERTEX_4:
			params[0] = (GLfloat) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP_COLOR:
			params[0] = (GLfloat) g->pixel.mapColor;
			break;
		case GL_MAP_STENCIL:
			params[0] = (GLfloat) g->pixel.mapStencil;
			break;
		case GL_MATRIX_MODE:
			params[0] = (GLfloat) g->transform.matrixMode;
			break;
		case GL_MAX_3D_TEXTURE_SIZE:
			params[0] = (GLfloat) g->limits.max3DTextureSize;
			break;
		case GL_MAX_ATTRIB_STACK_DEPTH:
			params[0] = (GLfloat) g->limits.maxAttribStackDepth;
			break;
		case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
			params[0] = (GLfloat) g->limits.maxClientAttribStackDepth;
			break;
		case GL_MAX_CLIP_PLANES:
			params[0] = (GLfloat) g->limits.maxClipPlanes;
			break;
		case GL_MAX_COLOR_MATRIX_STACK_DEPTH:
			params[0] = (GLfloat) g->limits.maxColorStackDepth;
			break;
		case GL_MAX_ELEMENTS_INDICES:
			params[0] = (GLfloat) g->limits.maxElementsIndices;
			break;
		case GL_MAX_ELEMENTS_VERTICES:
			params[0] = (GLfloat) g->limits.maxElementsVertices;
			break;
		case GL_MAX_EVAL_ORDER:
			params[0] = (GLfloat) g->limits.maxEvalOrder;
			break;
		case GL_MAX_LIGHTS:
			params[0] = (GLfloat) g->limits.maxLights;
			break;
		case GL_MAX_LIST_NESTING:
			params[0] = (GLfloat) g->limits.maxListNesting;
			break;
		case GL_MAX_MODELVIEW_STACK_DEPTH:
			params[0] = (GLfloat) g->limits.maxModelviewStackDepth;
			break;
		case GL_MAX_NAME_STACK_DEPTH:
			params[0] = (GLfloat) g->limits.maxNameStackDepth;
			break;
		case GL_MAX_PIXEL_MAP_TABLE:
			params[0] = (GLfloat) g->limits.maxPixelMapTable;
			break;
		case GL_MAX_PROJECTION_STACK_DEPTH:
			params[0] = (GLfloat) g->limits.maxProjectionStackDepth;
			break;
		case GL_MAX_TEXTURE_SIZE:
			params[0] = (GLfloat) g->limits.maxTextureSize;
			break;
		case GL_MAX_TEXTURE_STACK_DEPTH:
			params[0] = (GLfloat) g->limits.maxTextureStackDepth;
			break;
		case GL_MAX_TEXTURE_UNITS_ARB:
			params[0] = (GLfloat) g->limits.maxTextureUnits;
			break;
		case GL_MAX_VERTEX_ATTRIBS_ARB:
			params[0] = (GLfloat) g->limits.maxVertexProgramAttribs;
			break;
		case GL_MAX_VIEWPORT_DIMS:
			params[0] = (GLfloat) g->limits.maxViewportDims[0];
			params[1] = (GLfloat) g->limits.maxViewportDims[1];
			break;
		case GL_MODELVIEW_MATRIX:
			params[0] = (GLfloat) g->transform.modelViewStack.top->m00;
			params[1] = (GLfloat) g->transform.modelViewStack.top->m01;
			params[2] = (GLfloat) g->transform.modelViewStack.top->m02;
			params[3] = (GLfloat) g->transform.modelViewStack.top->m03;
			params[4] = (GLfloat) g->transform.modelViewStack.top->m10;
			params[5] = (GLfloat) g->transform.modelViewStack.top->m11;
			params[6] = (GLfloat) g->transform.modelViewStack.top->m12;
			params[7] = (GLfloat) g->transform.modelViewStack.top->m13;
			params[8] = (GLfloat) g->transform.modelViewStack.top->m20;
			params[9] = (GLfloat) g->transform.modelViewStack.top->m21;
			params[10] = (GLfloat) g->transform.modelViewStack.top->m22;
			params[11] = (GLfloat) g->transform.modelViewStack.top->m23;
			params[12] = (GLfloat) g->transform.modelViewStack.top->m30;
			params[13] = (GLfloat) g->transform.modelViewStack.top->m31;
			params[14] = (GLfloat) g->transform.modelViewStack.top->m32;
			params[15] = (GLfloat) g->transform.modelViewStack.top->m33;
			break;
		case GL_MODELVIEW_STACK_DEPTH:
			params[0] = (GLfloat) g->transform.modelViewStack.depth+1;
			break;
		case GL_NAME_STACK_DEPTH:
			params[0] = (GLfloat) 0;
			break;
		case GL_NORMALIZE:
			params[0] = (GLfloat) g->transform.normalize;
			break;
		case GL_NORMAL_ARRAY:
			params[0] = (GLfloat) g->client.array.n.enabled;
			break;
		case GL_NORMAL_ARRAY_STRIDE:
			params[0] = (GLfloat) g->client.array.n.stride;
			break;
		case GL_NORMAL_ARRAY_TYPE:
			params[0] = (GLfloat) g->client.array.n.type;
			break;
		case GL_PACK_ALIGNMENT:
			params[0] = (GLfloat) g->client.pack.alignment;
			break;
		case GL_PACK_IMAGE_HEIGHT:
			params[0] = (GLfloat) g->client.pack.imageHeight;
			break;
		case GL_PACK_LSB_FIRST:
			params[0] = (GLfloat) g->client.pack.psLSBFirst;
			break;
		case GL_PACK_ROW_LENGTH:
			params[0] = (GLfloat) g->client.pack.rowLength;
			break;
		case GL_PACK_SKIP_IMAGES:
			params[0] = (GLfloat) g->client.pack.skipImages;
			break;
		case GL_PACK_SKIP_PIXELS:
			params[0] = (GLfloat) g->client.pack.skipPixels;
			break;
		case GL_PACK_SKIP_ROWS:
			params[0] = (GLfloat) g->client.pack.skipRows;
			break;
		case GL_PACK_SWAP_BYTES:
			params[0] = (GLfloat) g->client.pack.swapBytes;
			break;
		case GL_PERSPECTIVE_CORRECTION_HINT:
			params[0] = (GLfloat) g->hint.perspectiveCorrection;
			break;
		case GL_PIXEL_MAP_A_TO_A_SIZE:
			params[0] = (GLfloat) g->pixel.mapAtoAsize;
			break;
		case GL_PIXEL_MAP_B_TO_B_SIZE:
			params[0] = (GLfloat) g->pixel.mapBtoBsize;
			break;
		case GL_PIXEL_MAP_G_TO_G_SIZE:
			params[0] = (GLfloat) g->pixel.mapGtoGsize;
			break;
		case GL_PIXEL_MAP_I_TO_A_SIZE:
			params[0] = (GLfloat) g->pixel.mapItoAsize;
			break;
		case GL_PIXEL_MAP_I_TO_B_SIZE:
			params[0] = (GLfloat) g->pixel.mapItoBsize;
			break;
		case GL_PIXEL_MAP_I_TO_G_SIZE:
			params[0] = (GLfloat) g->pixel.mapItoGsize;
			break;
		case GL_PIXEL_MAP_I_TO_I_SIZE:
			params[0] = (GLfloat) g->pixel.mapItoIsize;
			break;
		case GL_PIXEL_MAP_I_TO_R_SIZE:
			params[0] = (GLfloat) g->pixel.mapItoRsize;
			break;
		case GL_PIXEL_MAP_R_TO_R_SIZE:
			params[0] = (GLfloat) g->pixel.mapRtoRsize;
			break;
		case GL_PIXEL_MAP_S_TO_S_SIZE:
			params[0] = (GLfloat) g->pixel.mapStoSsize;
			break;
		case GL_POINT_DISTANCE_ATTENUATION_ARB:
			params[0] = g->point.distanceAttenuation[0];
			params[1] = g->point.distanceAttenuation[1];
			params[2] = g->point.distanceAttenuation[2];
			break;
		case GL_POINT_FADE_THRESHOLD_SIZE_ARB:
			params[0] = g->point.fadeThresholdSize;
			break;
		case GL_POINT_SIZE:
			params[0] = g->point.pointSize;
			break;
		case GL_POINT_SIZE_MAX_ARB:
			params[0] = g->point.maxSize;
			break;
		case GL_POINT_SIZE_MIN_ARB:
			params[0] = g->point.minSize;
			break;
		case GL_POINT_SMOOTH:
			params[0] = (GLfloat) g->point.pointSmooth;
			break;
		case GL_POINT_SMOOTH_HINT:
			params[0] = (GLfloat) g->hint.pointSmooth;
			break;
		case GL_POINT_SPRITE_COORD_ORIGIN:
			params[0] = g->point.spriteCoordOrigin;
			break;
		case GL_POLYGON_MODE:
			params[0] = (GLfloat) g->polygon.frontMode;
			params[1] = (GLfloat) g->polygon.backMode;
			break;
		case GL_POLYGON_OFFSET_FACTOR:
			params[0] = g->polygon.offsetFactor;
			break;
		case GL_POLYGON_OFFSET_FILL:
			params[0] = (GLfloat) g->polygon.polygonOffsetFill;
			break;
		case GL_POLYGON_OFFSET_LINE:
			params[0] = (GLfloat) g->polygon.polygonOffsetLine;
			break;
		case GL_POLYGON_OFFSET_POINT:
			params[0] = (GLfloat) g->polygon.polygonOffsetPoint;
			break;
		case GL_POLYGON_OFFSET_UNITS:
			params[0] = g->polygon.offsetUnits;
			break;
		case GL_POLYGON_SMOOTH:
			params[0] = (GLfloat) g->polygon.polygonSmooth;
			break;
		case GL_POLYGON_SMOOTH_HINT:
			params[0] = (GLfloat) g->hint.polygonSmooth;
			break;
		case GL_POLYGON_STIPPLE:
			params[0] = (GLfloat) g->polygon.polygonStipple;
			break;
		case GL_PROJECTION_MATRIX:
			params[0] = (GLfloat) g->transform.projectionStack.top->m00;
			params[1] = (GLfloat) g->transform.projectionStack.top->m01;
			params[2] = (GLfloat) g->transform.projectionStack.top->m02;
			params[3] = (GLfloat) g->transform.projectionStack.top->m03;
			params[4] = (GLfloat) g->transform.projectionStack.top->m10;
			params[5] = (GLfloat) g->transform.projectionStack.top->m11;
			params[6] = (GLfloat) g->transform.projectionStack.top->m12;
			params[7] = (GLfloat) g->transform.projectionStack.top->m13;
			params[8] = (GLfloat) g->transform.projectionStack.top->m20;
			params[9] = (GLfloat) g->transform.projectionStack.top->m21;
			params[10] = (GLfloat) g->transform.projectionStack.top->m22;
			params[11] = (GLfloat) g->transform.projectionStack.top->m23;
			params[12] = (GLfloat) g->transform.projectionStack.top->m30;
			params[13] = (GLfloat) g->transform.projectionStack.top->m31;
			params[14] = (GLfloat) g->transform.projectionStack.top->m32;
			params[15] = (GLfloat) g->transform.projectionStack.top->m33;
			break;
		case GL_PROJECTION_STACK_DEPTH:
			params[0] = (GLfloat) g->transform.projectionStack.depth+1;
			break;
		case GL_READ_BUFFER:
			params[0] = (GLfloat) __getReadBuffer(g);
			break;
		case GL_READ_FRAMEBUFFER_BINDING:
			params[0] = (GLfloat) (g->framebufferobject.readFB?g->framebufferobject.readFB->id:0);
			break;
		case GL_RED_BIAS:
			params[0] = g->pixel.bias.r;
			break;
		case GL_RED_BITS:
			params[0] = (GLfloat) g->limits.redBits;
			break;
		case GL_RED_SCALE:
			params[0] = g->pixel.scale.r;
			break;
		case GL_RENDERBUFFER_BINDING_EXT:
			params[0] = (GLfloat) (g->framebufferobject.renderbuffer?g->framebufferobject.renderbuffer->id:0);
			break;
		case GL_RENDER_MODE:
			params[0] = (GLfloat) g->renderMode;
			break;
		case GL_RGBA_MODE:
			params[0] = (GLfloat) g->limits.rgbaMode;
			break;
		case GL_SCISSOR_BOX:
			params[0] = (GLfloat) g->viewport.scissorX;
			params[1] = (GLfloat) g->viewport.scissorY;
			params[2] = (GLfloat) g->viewport.scissorW;
			params[3] = (GLfloat) g->viewport.scissorH;
			break;
		case GL_SCISSOR_TEST:
			params[0] = (GLfloat) g->viewport.scissorTest;
			break;
		case GL_SELECTION_BUFFER_SIZE:
			params[0] = (GLfloat) g->selection.bufferSize;
			break;
		case GL_SHADE_MODEL:
			params[0] = (GLfloat) g->lighting.shadeModel;
			break;
		case GL_SMOOTH_LINE_WIDTH_GRANULARITY:
			params[0] = g->limits.lineWidthGranularity;
			break;
		case GL_SMOOTH_LINE_WIDTH_RANGE:
			params[0] = g->limits.smoothLineWidthRange[0];
			params[1] = g->limits.smoothLineWidthRange[1];
			break;
		case GL_SMOOTH_POINT_SIZE_GRANULARITY:
			params[0] = g->limits.pointSizeGranularity;
			break;
		case GL_SMOOTH_POINT_SIZE_RANGE:
			params[0] = g->limits.smoothPointSizeRange[0];
			params[1] = g->limits.smoothPointSizeRange[1];
			break;
		case GL_STENCIL_BACK_FAIL:
			params[0] = (GLfloat) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].fail;
			break;
		case GL_STENCIL_BACK_FUNC:
			params[0] = (GLfloat) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].func;
			break;
		case GL_STENCIL_BACK_PASS_DEPTH_FAIL:
			params[0] = (GLfloat) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthFail;
			break;
		case GL_STENCIL_BACK_PASS_DEPTH_PASS:
			params[0] = (GLfloat) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthPass;
			break;
		case GL_STENCIL_BACK_REF:
			params[0] = (GLfloat) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].ref;
			break;
		case GL_STENCIL_BACK_VALUE_MASK:
			params[0] = (GLfloat) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].mask;
			break;
		case GL_STENCIL_BITS:
			params[0] = (GLfloat) g->limits.stencilBits;
			break;
		case GL_STENCIL_CLEAR_VALUE:
			params[0] = (GLfloat) g->stencil.clearValue;
			break;
		case GL_STENCIL_FAIL:
			params[0] = (GLfloat) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].fail;
			break;
		case GL_STENCIL_FUNC:
			params[0] = (GLfloat) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].func;
			break;
		case GL_STENCIL_PASS_DEPTH_FAIL:
			params[0] = (GLfloat) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthFail;
			break;
		case GL_STENCIL_PASS_DEPTH_PASS:
			params[0] = (GLfloat) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthPass;
			break;
		case GL_STENCIL_REF:
			params[0] = (GLfloat) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].ref;
			break;
		case GL_STENCIL_TEST:
			params[0] = (GLfloat) g->stencil.stencilTest;
			break;
		case GL_STENCIL_VALUE_MASK:
			params[0] = (GLfloat) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].mask;
			break;
		case GL_STENCIL_WRITEMASK:
			params[0] = (GLfloat) g->stencil.writeMask;
			break;
		case GL_STEREO:
			params[0] = (GLfloat) g->limits.stereo;
			break;
		case GL_SUBPIXEL_BITS:
			params[0] = (GLfloat) g->limits.subpixelBits;
			break;
		case GL_TEXTURE_1D:
			params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].enabled1D;
			break;
		case GL_TEXTURE_2D:
			params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].enabled2D;
			break;
		case GL_TEXTURE_3D:
			params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].enabled3D;
			break;
		case GL_TEXTURE_BINDING_1D:
			params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].currentTexture1D->id;
			break;
		case GL_TEXTURE_BINDING_2D:
			params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].currentTexture2D->id;
			break;
		case GL_TEXTURE_BINDING_3D:
			params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].currentTexture3D->id;
			break;
		case GL_TEXTURE_COORD_ARRAY:
			params[0] = (GLfloat) g->client.array.t[g->client.curClientTextureUnit].enabled;
			break;
		case GL_TEXTURE_COORD_ARRAY_SIZE:
			params[0] = (GLfloat) g->client.array.t[g->client.curClientTextureUnit].size;
			break;
		case GL_TEXTURE_COORD_ARRAY_STRIDE:
			params[0] = (GLfloat) g->client.array.t[g->client.curClientTextureUnit].stride;
			break;
		case GL_TEXTURE_COORD_ARRAY_TYPE:
			params[0] = (GLfloat) g->client.array.t[g->client.curClientTextureUnit].type;
			break;
		case GL_TEXTURE_ENV_MODE:
			params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].envMode;
			break;
		case GL_TEXTURE_GEN_Q:
			params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].textureGen.q;
			break;
		case GL_TEXTURE_GEN_R:
			params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].textureGen.r;
			break;
		case GL_TEXTURE_GEN_S:
			params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].textureGen.s;
			break;
		case GL_TEXTURE_GEN_T:
			params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].textureGen.t;
			break;
		case GL_TEXTURE_MATRIX:
			params[0] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m00;
			params[1] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m01;
			params[2] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m02;
			params[3] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m03;
			params[4] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m10;
			params[5] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m11;
			params[6] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m12;
			params[7] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m13;
			params[8] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m20;
			params[9] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m21;
			params[10] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m22;
			params[11] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m23;
			params[12] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m30;
			params[13] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m31;
			params[14] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m32;
			params[15] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m33;
			break;
		case GL_TEXTURE_STACK_DEPTH:
			params[0] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].depth+1;
			break;
		case GL_UNPACK_ALIGNMENT:
			params[0] = (GLfloat) g->client.unpack.alignment;
			break;
		case GL_UNPACK_IMAGE_HEIGHT:
			params[0] = (GLfloat) g->client.unpack.imageHeight;
			break;
		case GL_UNPACK_LSB_FIRST:
			params[0] = (GLfloat) g->client.unpack.psLSBFirst;
			break;
		case GL_UNPACK_ROW_LENGTH:
			params[0] = (GLfloat) g->client.unpack.rowLength;
			break;
		case GL_UNPACK_SKIP_IMAGES:
			params[0] = (GLfloat) g->client.unpack.skipImages;
			break;
		case GL_UNPACK_SKIP_PIXELS:
			params[0] = (GLfloat) g->client.unpack.skipPixels;
			break;
		case GL_UNPACK_SKIP_ROWS:
			params[0] = (GLfloat) g->client.unpack.skipRows;
			break;
		case GL_UNPACK_SWAP_BYTES:
			params[0] = (GLfloat) g->client.unpack.swapBytes;
			break;
		case GL_VERTEX_ARRAY:
			params[0] = (GLfloat) g->client.array.v.enabled;
			break;
		case GL_VERTEX_ARRAY_SIZE:
			params[0] = (GLfloat) g->client.array.v.size;
			break;
		case GL_VERTEX_ARRAY_STRIDE:
			params[0] = (GLfloat) g->client.array.v.stride;
			break;
		case GL_VERTEX_ARRAY_TYPE:
			params[0] = (GLfloat) g->client.array.v.type;
			break;
		case GL_VIEWPORT:
			params[0] = (GLfloat) g->viewport.viewportX;
			params[1] = (GLfloat) g->viewport.viewportY;
			params[2] = (GLfloat) g->viewport.viewportW;
			params[3] = (GLfloat) g->viewport.viewportH;
			break;
		case GL_ZOOM_X:
			params[0] = g->pixel.xZoom;
			break;
		case GL_ZOOM_Y:
			params[0] = g->pixel.yZoom;
			break;
#ifdef CR_ARB_vertex_buffer_object
		case GL_ARRAY_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_vertex_buffer_object) {
				params[0] = (GLfloat) g->bufferobject.arrayBuffer->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_EXT_blend_color
		case GL_BLEND_COLOR_EXT:
			if (g->extensions.EXT_blend_color) {
				params[0] = g->buffer.blendColor.r;
				params[1] = g->buffer.blendColor.g;
				params[2] = g->buffer.blendColor.b;
				params[3] = g->buffer.blendColor.a;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_blend_color */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_DST_ALPHA_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLfloat) g->buffer.blendDstA;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_DST_RGB_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLfloat) g->buffer.blendDstRGB;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_minmax
		case GL_BLEND_EQUATION_EXT:
			if (g->extensions.EXT_blend_minmax) {
				params[0] = (GLfloat) g->buffer.blendEquation;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_blend_minmax */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_SRC_ALPHA_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLfloat) g->buffer.blendSrcA;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_SRC_RGB_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLfloat) g->buffer.blendSrcRGB;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_NV_register_combiners
		case GL_COLOR_SUM_CLAMP_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLfloat) g->regcombiner.colorSumClamp;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_EXT_secondary_color
		case GL_COLOR_SUM_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLfloat) g->lighting.colorSumEXT;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_ARB_texture_compression
		case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
			if (g->extensions.ARB_texture_compression) {
				params[0] = (GLfloat) g->limits.compressedFormats[0];
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_texture_compression */
#ifdef CR_NV_register_combiners
		case GL_CONSTANT_COLOR0_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = g->regcombiner.constantColor0.r;
				params[1] = g->regcombiner.constantColor0.g;
				params[2] = g->regcombiner.constantColor0.b;
				params[3] = g->regcombiner.constantColor0.a;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
		case GL_CONSTANT_COLOR1_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = g->regcombiner.constantColor1.r;
				params[1] = g->regcombiner.constantColor1.g;
				params[2] = g->regcombiner.constantColor1.b;
				params[3] = g->regcombiner.constantColor1.a;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_EXT_fog_coord
		case GL_CURRENT_FOG_COORDINATE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = g->current.vertexAttrib[VERT_ATTRIB_FOG][0];
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_secondary_color
		case GL_CURRENT_SECONDARY_COLOR_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = g->current.vertexAttrib[VERT_ATTRIB_COLOR1][0];
				params[1] = g->current.vertexAttrib[VERT_ATTRIB_COLOR1][1];
				params[2] = g->current.vertexAttrib[VERT_ATTRIB_COLOR1][2];
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_ARB_vertex_buffer_object
		case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_vertex_buffer_object) {
				params[0] = (GLfloat) g->bufferobject.elementsBuffer->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_ARRAY_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLfloat) g->client.array.f.enabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLfloat) g->client.array.f.stride;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLfloat) g->client.array.f.type;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_SOURCE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLfloat) g->fog.fogCoordinateSource;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_NV_fog_distance
		case GL_FOG_DISTANCE_MODE_NV:
			if (g->extensions.NV_fog_distance) {
				params[0] = (GLfloat) g->fog.fogDistanceMode;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_fog_distance */
#ifdef CR_ARB_fragment_program
		case GL_FRAGMENT_PROGRAM_ARB:
			if (g->extensions.ARB_fragment_program) {
				params[0] = (GLfloat) g->program.fpEnabledARB;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_fragment_program */
#ifdef CR_NV_fragment_program
		case GL_FRAGMENT_PROGRAM_BINDING_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLfloat) g->program.fpProgramBinding;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_fragment_program
		case GL_FRAGMENT_PROGRAM_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLfloat) g->program.fpEnabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_SGIS_generate_mipmap
		case GL_GENERATE_MIPMAP_HINT:
			if (g->extensions.SGIS_generate_mipmap) {
				params[0] = (GLfloat) g->hint.generateMipmap;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_SGIS_generate_mipmap */
#ifdef CR_OPENGL_VERSION_1_2
		case GL_LIGHT_MODEL_COLOR_CONTROL:
			params[0] = (GLfloat) g->lighting.lightModelColorControlEXT;
			break;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_EXT_separate_specular_color
		case GL_LIGHT_MODEL_COLOR_CONTROL_EXT:
			if (g->extensions.EXT_separate_specular_color) {
				params[0] = (GLfloat) g->lighting.lightModelColorControlEXT;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_separate_specular_color */
#ifdef CR_ARB_texture_cube_map
		case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
			if (g->extensions.ARB_texture_cube_map) {
				params[0] = (GLfloat) g->limits.maxCubeMapTextureSize;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_fragment_program
		case GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLfloat) g->limits.maxFragmentProgramLocalParams;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_register_combiners
		case GL_MAX_GENERAL_COMBINERS_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLfloat) g->limits.maxGeneralCombiners;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_texture_rectangle
		case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
			if (g->extensions.NV_texture_rectangle) {
				params[0] = (GLfloat) g->limits.maxRectTextureSize;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_NV_fragment_program
		case GL_MAX_TEXTURE_COORDS_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLfloat) g->limits.maxTextureCoords;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_fragment_program
		case GL_MAX_TEXTURE_IMAGE_UNITS_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLfloat) g->limits.maxTextureImageUnits;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_EXT_texture_lod_bias
		case GL_MAX_TEXTURE_LOD_BIAS_EXT:
			if (g->extensions.EXT_texture_lod_bias) {
				params[0] = g->limits.maxTextureLodBias;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_texture_lod_bias */
#ifdef CR_EXT_texture_filter_anisotropic
		case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
			if (g->extensions.EXT_texture_filter_anisotropic) {
				params[0] = (GLfloat) g->limits.maxTextureAnisotropy;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_texture_filter_anisotropic */
#ifdef CR_ARB_multisample
		case GL_MULTISAMPLE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLfloat) g->multisample.enabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_texture_compression
		case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
			if (g->extensions.ARB_texture_compression) {
				params[0] = (GLfloat) g->limits.numCompressedFormats;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_texture_compression */
#ifdef CR_NV_register_combiners
		case GL_NUM_GENERAL_COMBINERS_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLfloat) g->regcombiner.numGeneralCombiners;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners2
		case GL_PER_STAGE_CONSTANTS_NV:
			if (g->extensions.NV_register_combiners2) {
				params[0] = (GLfloat) g->regcombiner.enabledPerStageConstants;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_register_combiners2 */
#ifdef CR_ARB_pixel_buffer_object
		case GL_PIXEL_PACK_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_pixel_buffer_object) {
				params[0] = (GLfloat) g->bufferobject.packBuffer->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_pixel_buffer_object */
#ifdef CR_ARB_pixel_buffer_object
		case GL_PIXEL_UNPACK_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_pixel_buffer_object) {
				params[0] = (GLfloat) g->bufferobject.unpackBuffer->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_pixel_buffer_object */
#ifdef CR_ARB_point_sprite
		case GL_POINT_SPRITE_ARB:
			if (g->extensions.ARB_point_sprite) {
				params[0] = (GLfloat) g->point.pointSprite;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_point_sprite */
#ifdef CR_any_program
		case GL_PROGRAM_ERROR_POSITION_NV:
			if (g->extensions.any_program) {
				params[0] = (GLfloat) g->program.errorPos;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_any_program */
#ifdef CR_NV_register_combiners
		case GL_REGISTER_COMBINERS_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLfloat) g->regcombiner.enabledRegCombiners;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_OPENGL_VERSION_1_2
		case GL_RESCALE_NORMAL:
			params[0] = (GLfloat) g->transform.rescaleNormals;
			break;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_ARB_multisample
		case GL_SAMPLES_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLfloat) g->limits.samples;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLfloat) g->multisample.sampleAlphaToCoverage;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_ALPHA_TO_ONE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLfloat) g->multisample.sampleAlphaToOne;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_BUFFERS_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLfloat) g->limits.sampleBuffers;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_COVERAGE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLfloat) g->multisample.sampleCoverage;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_COVERAGE_INVERT_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLfloat) g->multisample.sampleCoverageInvert;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_COVERAGE_VALUE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLfloat) g->multisample.sampleCoverageValue;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLfloat) g->client.array.s.enabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLfloat) g->client.array.s.size;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLfloat) g->client.array.s.stride;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLfloat) g->client.array.s.type;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_ARB_texture_cube_map
		case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
			if (g->extensions.ARB_texture_cube_map) {
				params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].currentTextureCubeMap->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_texture_rectangle
		case GL_TEXTURE_BINDING_RECTANGLE_NV:
			if (g->extensions.NV_texture_rectangle) {
				params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].currentTextureRect->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_ARB_texture_compression
		case GL_TEXTURE_COMPRESSION_HINT_ARB:
			if (g->extensions.ARB_texture_compression) {
				params[0] = (GLfloat) g->hint.textureCompression;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_texture_compression */
#ifdef CR_ARB_texture_cube_map
		case GL_TEXTURE_CUBE_MAP_ARB:
			if (g->extensions.ARB_texture_cube_map) {
				params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].enabledCubeMap;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_texture_rectangle
		case GL_TEXTURE_RECTANGLE_NV:
			if (g->extensions.NV_texture_rectangle) {
				params[0] = (GLfloat) g->texture.unit[g->texture.curTextureUnit].enabledRect;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_ARB_transpose_matrix
		case GL_TRANSPOSE_MODELVIEW_MATRIX:
			if (g->extensions.ARB_transpose_matrix) {
				params[0] = (GLfloat) g->transform.modelViewStack.top->m00;
				params[1] = (GLfloat) g->transform.modelViewStack.top->m10;
				params[2] = (GLfloat) g->transform.modelViewStack.top->m20;
				params[3] = (GLfloat) g->transform.modelViewStack.top->m30;
				params[4] = (GLfloat) g->transform.modelViewStack.top->m01;
				params[5] = (GLfloat) g->transform.modelViewStack.top->m11;
				params[6] = (GLfloat) g->transform.modelViewStack.top->m21;
				params[7] = (GLfloat) g->transform.modelViewStack.top->m31;
				params[8] = (GLfloat) g->transform.modelViewStack.top->m02;
				params[9] = (GLfloat) g->transform.modelViewStack.top->m12;
				params[10] = (GLfloat) g->transform.modelViewStack.top->m22;
				params[11] = (GLfloat) g->transform.modelViewStack.top->m32;
				params[12] = (GLfloat) g->transform.modelViewStack.top->m03;
				params[13] = (GLfloat) g->transform.modelViewStack.top->m13;
				params[14] = (GLfloat) g->transform.modelViewStack.top->m23;
				params[15] = (GLfloat) g->transform.modelViewStack.top->m33;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_ARB_transpose_matrix
		case GL_TRANSPOSE_PROJECTION_MATRIX:
			if (g->extensions.ARB_transpose_matrix) {
				params[0] = (GLfloat) g->transform.projectionStack.top->m00;
				params[1] = (GLfloat) g->transform.projectionStack.top->m10;
				params[2] = (GLfloat) g->transform.projectionStack.top->m20;
				params[3] = (GLfloat) g->transform.projectionStack.top->m30;
				params[4] = (GLfloat) g->transform.projectionStack.top->m01;
				params[5] = (GLfloat) g->transform.projectionStack.top->m11;
				params[6] = (GLfloat) g->transform.projectionStack.top->m21;
				params[7] = (GLfloat) g->transform.projectionStack.top->m31;
				params[8] = (GLfloat) g->transform.projectionStack.top->m02;
				params[9] = (GLfloat) g->transform.projectionStack.top->m12;
				params[10] = (GLfloat) g->transform.projectionStack.top->m22;
				params[11] = (GLfloat) g->transform.projectionStack.top->m32;
				params[12] = (GLfloat) g->transform.projectionStack.top->m03;
				params[13] = (GLfloat) g->transform.projectionStack.top->m13;
				params[14] = (GLfloat) g->transform.projectionStack.top->m23;
				params[15] = (GLfloat) g->transform.projectionStack.top->m33;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_ARB_transpose_matrix
		case GL_TRANSPOSE_TEXTURE_MATRIX:
			if (g->extensions.ARB_transpose_matrix) {
				params[0] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m00;
				params[1] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m10;
				params[2] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m20;
				params[3] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m30;
				params[4] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m01;
				params[5] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m11;
				params[6] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m21;
				params[7] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m31;
				params[8] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m02;
				params[9] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m12;
				params[10] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m22;
				params[11] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m32;
				params[12] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m03;
				params[13] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m13;
				params[14] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m23;
				params[15] = (GLfloat) g->transform.textureStack[g->texture.curTextureUnit].top->m33;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_NV_vertex_program
		case GL_VERTEX_PROGRAM_BINDING_NV:
			if (g->extensions.NV_vertex_program) {
				params[0] = (GLfloat) g->program.vpProgramBinding;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_NV_vertex_program */
#ifdef CR_any_vertex_program
		case GL_VERTEX_PROGRAM_NV:
			if (g->extensions.any_vertex_program) {
				params[0] = (GLfloat) g->program.vpEnabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
		case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
			if (g->extensions.any_vertex_program) {
				params[0] = (GLfloat) g->program.vpPointSize;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
		case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
			if (g->extensions.any_vertex_program) {
				params[0] = (GLfloat) g->program.vpTwoSide;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetFloatv");
			}
			break;
#endif /* CR_any_vertex_program */
		default:
			crStateError(__LINE__, __FILE__, GL_INVALID_ENUM, "glGet: Unknown enum: 0x%x", pname);
			return;
	}
}

void STATE_APIENTRY crStateGetIntegerv( GLenum pname, GLint *params )

{
	CRContext *g = GetCurrentContext();

	if (g->current.inBeginEnd)
	{
		crStateError(__LINE__, __FILE__, GL_INVALID_OPERATION,
			"glGet called in Begin/End");
		return;
	}

	if (pname == GL_CURRENT_INDEX || pname == GL_CURRENT_COLOR ||
		pname == GL_CURRENT_SECONDARY_COLOR_EXT ||
		pname == GL_CURRENT_FOG_COORDINATE_EXT ||
		pname == GL_CURRENT_NORMAL || pname == GL_EDGE_FLAG ||
		pname == GL_CURRENT_TEXTURE_COORDS )
	{
#if 0
		crStateError(__LINE__,__FILE__, GL_INVALID_OPERATION,
			"Unimplemented glGet of a 'current' value" );
#else
		crStateCurrentRecover();/* &g->current, &sb->current, g->bitID );*/
		
#endif
	}

	switch (pname) {

		case GL_ACCUM_ALPHA_BITS:
			params[0] = (GLint) g->limits.accumAlphaBits;
			break;
		case GL_ACCUM_BLUE_BITS:
			params[0] = (GLint) g->limits.accumBlueBits;
			break;
		case GL_ACCUM_CLEAR_VALUE:
			params[0] = (GLint) g->buffer.accumClearValue.r;
			params[1] = (GLint) g->buffer.accumClearValue.g;
			params[2] = (GLint) g->buffer.accumClearValue.b;
			params[3] = (GLint) g->buffer.accumClearValue.a;
			break;
		case GL_ACCUM_GREEN_BITS:
			params[0] = (GLint) g->limits.accumGreenBits;
			break;
		case GL_ACCUM_RED_BITS:
			params[0] = (GLint) g->limits.accumRedBits;
			break;
		case GL_ACTIVE_STENCIL_FACE_EXT:
			params[0] = (GLint) g->stencil.activeStencilFace;
			break;
		case GL_ACTIVE_TEXTURE_ARB:
			params[0] = (GLint) g->texture.curTextureUnit+GL_TEXTURE0_ARB;
			break;
		case GL_ALIASED_LINE_WIDTH_RANGE:
			params[0] = (GLint) g->limits.aliasedLineWidthRange[0];
			params[1] = (GLint) g->limits.aliasedLineWidthRange[1];
			break;
		case GL_ALIASED_POINT_SIZE_RANGE:
			params[0] = (GLint) g->limits.aliasedPointSizeRange[0];
			params[1] = (GLint) g->limits.aliasedPointSizeRange[1];
			break;
		case GL_ALPHA_BIAS:
			params[0] = (GLint) g->pixel.bias.a;
			break;
		case GL_ALPHA_BITS:
			params[0] = (GLint) g->limits.alphaBits;
			break;
		case GL_ALPHA_SCALE:
			params[0] = (GLint) g->pixel.scale.a;
			break;
		case GL_ALPHA_TEST:
			params[0] = (GLint) g->buffer.alphaTest;
			break;
		case GL_ALPHA_TEST_FUNC:
			params[0] = (GLint) g->buffer.alphaTestFunc;
			break;
		case GL_ALPHA_TEST_REF:
			params[0] = (GLint) g->buffer.alphaTestRef;
			break;
		case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
			params[0] = (GLint) g->client.array.lockCount;
			break;
		case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
			params[0] = (GLint) g->client.array.lockFirst;
			break;
		case GL_ATTRIB_STACK_DEPTH:
			params[0] = (GLint) g->attrib.attribStackDepth;
			break;
		case GL_AUTO_NORMAL:
			params[0] = (GLint) g->eval.autoNormal;
			break;
		case GL_AUX_BUFFERS:
			params[0] = (GLint) g->limits.auxBuffers;
			break;
		case GL_BLEND:
			params[0] = (GLint) g->buffer.blend;
			break;
		case GL_BLEND_DST:
			params[0] = (GLint) g->buffer.blendDstRGB;
			break;
		case GL_BLEND_SRC:
			params[0] = (GLint) g->buffer.blendSrcRGB;
			break;
		case GL_BLUE_BIAS:
			params[0] = (GLint) g->pixel.bias.b;
			break;
		case GL_BLUE_BITS:
			params[0] = (GLint) g->limits.blueBits;
			break;
		case GL_BLUE_SCALE:
			params[0] = (GLint) g->pixel.scale.b;
			break;
		case GL_CLIENT_ACTIVE_TEXTURE_ARB:
			params[0] = (GLint) g->client.curClientTextureUnit+GL_TEXTURE0_ARB;
			break;
		case GL_CLIP_PLANE0:
			params[0] = (GLint) g->transform.clip[0];
			break;
		case GL_CLIP_PLANE1:
			params[0] = (GLint) g->transform.clip[1];
			break;
		case GL_CLIP_PLANE2:
			params[0] = (GLint) g->transform.clip[2];
			break;
		case GL_CLIP_PLANE3:
			params[0] = (GLint) g->transform.clip[3];
			break;
		case GL_CLIP_PLANE4:
			params[0] = (GLint) g->transform.clip[4];
			break;
		case GL_CLIP_PLANE5:
			params[0] = (GLint) g->transform.clip[5];
			break;
		case GL_COLOR_ARRAY:
			params[0] = (GLint) g->client.array.c.enabled;
			break;
		case GL_COLOR_ARRAY_SIZE:
			params[0] = (GLint) g->client.array.c.size;
			break;
		case GL_COLOR_ARRAY_STRIDE:
			params[0] = (GLint) g->client.array.c.stride;
			break;
		case GL_COLOR_ARRAY_TYPE:
			params[0] = (GLint) g->client.array.c.type;
			break;
		case GL_COLOR_CLEAR_VALUE:
			params[0] = __clampf_to_int(g->buffer.colorClearValue.r);
			params[1] = __clampf_to_int(g->buffer.colorClearValue.g);
			params[2] = __clampf_to_int(g->buffer.colorClearValue.b);
			params[3] = __clampf_to_int(g->buffer.colorClearValue.a);
			break;
		case GL_COLOR_LOGIC_OP:
			params[0] = (GLint) g->buffer.logicOp;
			break;
		case GL_COLOR_MATERIAL:
			params[0] = (GLint) GL_FALSE;
			break;
		case GL_COLOR_MATERIAL_FACE:
			params[0] = (GLint) g->lighting.colorMaterialFace;
			break;
		case GL_COLOR_MATERIAL_PARAMETER:
			params[0] = (GLint) g->lighting.colorMaterialMode;
			break;
		case GL_COLOR_MATRIX:
			params[0] = (GLint) g->transform.colorStack.top->m00;
			params[1] = (GLint) g->transform.colorStack.top->m01;
			params[2] = (GLint) g->transform.colorStack.top->m02;
			params[3] = (GLint) g->transform.colorStack.top->m03;
			params[4] = (GLint) g->transform.colorStack.top->m10;
			params[5] = (GLint) g->transform.colorStack.top->m11;
			params[6] = (GLint) g->transform.colorStack.top->m12;
			params[7] = (GLint) g->transform.colorStack.top->m13;
			params[8] = (GLint) g->transform.colorStack.top->m20;
			params[9] = (GLint) g->transform.colorStack.top->m21;
			params[10] = (GLint) g->transform.colorStack.top->m22;
			params[11] = (GLint) g->transform.colorStack.top->m23;
			params[12] = (GLint) g->transform.colorStack.top->m30;
			params[13] = (GLint) g->transform.colorStack.top->m31;
			params[14] = (GLint) g->transform.colorStack.top->m32;
			params[15] = (GLint) g->transform.colorStack.top->m33;
			break;
		case GL_COLOR_MATRIX_STACK_DEPTH:
			params[0] = (GLint) g->transform.colorStack.depth+1;
			break;
		case GL_COLOR_WRITEMASK:
			params[0] = (GLint) g->buffer.colorWriteMask.r;
			params[1] = (GLint) g->buffer.colorWriteMask.g;
			params[2] = (GLint) g->buffer.colorWriteMask.b;
			params[3] = (GLint) g->buffer.colorWriteMask.a;
			break;
		case GL_CULL_FACE:
			params[0] = (GLint) g->polygon.cullFace;
			break;
		case GL_CULL_FACE_MODE:
			params[0] = (GLint) g->polygon.cullFaceMode;
			break;
		case GL_CURRENT_COLOR:
			params[0] = __clampf_to_int(g->current.vertexAttrib[VERT_ATTRIB_COLOR0][0]);
			params[1] = __clampf_to_int(g->current.vertexAttrib[VERT_ATTRIB_COLOR0][1]);
			params[2] = __clampf_to_int(g->current.vertexAttrib[VERT_ATTRIB_COLOR0][2]);
			params[3] = __clampf_to_int(g->current.vertexAttrib[VERT_ATTRIB_COLOR0][3]);
			break;
		case GL_CURRENT_INDEX:
			params[0] = (GLint) g->current.colorIndex;
			break;
		case GL_CURRENT_NORMAL:
			params[0] = __clampf_to_int(g->current.vertexAttrib[VERT_ATTRIB_NORMAL][0]);
			params[1] = __clampf_to_int(g->current.vertexAttrib[VERT_ATTRIB_NORMAL][1]);
			params[2] = __clampf_to_int(g->current.vertexAttrib[VERT_ATTRIB_NORMAL][2]);
			break;
		case GL_CURRENT_RASTER_COLOR:
			params[0] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_COLOR0][0];
			params[1] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_COLOR0][1];
			params[2] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_COLOR0][2];
			params[3] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_COLOR0][3];
			break;
		case GL_CURRENT_RASTER_DISTANCE:
			params[0] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_FOG][0];
			break;
		case GL_CURRENT_RASTER_INDEX:
			params[0] = (GLint) g->current.rasterIndex;
			break;
		case GL_CURRENT_RASTER_POSITION:
			params[0] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_POS][0];
			params[1] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_POS][1];
			params[2] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_POS][2];
			params[3] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_POS][3];
			break;
		case GL_CURRENT_RASTER_POSITION_VALID:
			params[0] = (GLint) g->current.rasterValid;
			break;
		case GL_CURRENT_RASTER_TEXTURE_COORDS:
			params[0] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_TEX0][0];
			params[1] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_TEX0][1];
			params[2] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_TEX0][2];
			params[3] = (GLint) g->current.rasterAttrib[VERT_ATTRIB_TEX0][3];
			break;
		case GL_CURRENT_TEXTURE_COORDS:
			params[0] = (GLint) g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][0];
			params[1] = (GLint) g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][1];
			params[2] = (GLint) g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][2];
			params[3] = (GLint) g->current.vertexAttrib[VERT_ATTRIB_TEX0+g->texture.curTextureUnit][3];
			break;
		case GL_DEPTH_BIAS:
			params[0] = (GLint) g->pixel.depthBias;
			break;
		case GL_DEPTH_BITS:
			params[0] = (GLint) g->limits.depthBits;
			break;
		case GL_DEPTH_CLEAR_VALUE:
			params[0] = __clampd_to_int(g->buffer.depthClearValue);
			break;
		case GL_DEPTH_FUNC:
			params[0] = (GLint) g->buffer.depthFunc;
			break;
		case GL_DEPTH_RANGE:
			params[0] = __clampd_to_int(g->viewport.nearClip);
			params[1] = __clampd_to_int(g->viewport.farClip);
			break;
		case GL_DEPTH_SCALE:
			params[0] = (GLint) g->pixel.depthScale;
			break;
		case GL_DEPTH_TEST:
			params[0] = (GLint) g->buffer.depthTest;
			break;
		case GL_DEPTH_WRITEMASK:
			params[0] = (GLint) g->buffer.depthMask;
			break;
		case GL_DITHER:
			params[0] = (GLint) g->buffer.dither;
			break;
		case GL_DOUBLEBUFFER:
			params[0] = (GLint) g->limits.doubleBuffer;
			break;
		case GL_DRAW_BUFFER:
			params[0] = (GLint) __getDrawBuffer(g);
			break;
		case GL_EDGE_FLAG:
			params[0] = (GLint) g->current.edgeFlag;
			break;
		case GL_EDGE_FLAG_ARRAY:
			params[0] = (GLint) g->client.array.e.enabled;
			break;
		case GL_EDGE_FLAG_ARRAY_STRIDE:
			params[0] = (GLint) g->client.array.e.stride;
			break;
		case GL_FEEDBACK_BUFFER_SIZE:
			params[0] = (GLint) g->feedback.bufferSize;
			break;
		case GL_FEEDBACK_BUFFER_TYPE:
			params[0] = (GLint) g->feedback.type;
			break;
		case GL_FOG:
			params[0] = (GLint) g->fog.enable;
			break;
		case GL_FOG_COLOR:
			params[0] = (GLint) g->fog.color.r;
			params[1] = (GLint) g->fog.color.g;
			params[2] = (GLint) g->fog.color.b;
			params[3] = (GLint) g->fog.color.a;
			break;
		case GL_FOG_DENSITY:
			params[0] = (GLint) g->fog.density;
			break;
		case GL_FOG_END:
			params[0] = (GLint) g->fog.end;
			break;
		case GL_FOG_HINT:
			params[0] = (GLint) g->hint.fog;
			break;
		case GL_FOG_INDEX:
			params[0] = (GLint) g->fog.index;
			break;
		case GL_FOG_MODE:
			params[0] = (GLint) g->fog.mode;
			break;
		case GL_FOG_START:
			params[0] = (GLint) g->fog.start;
			break;
		case GL_FRAMEBUFFER_BINDING_EXT:
			params[0] = (GLint) (g->framebufferobject.drawFB?g->framebufferobject.drawFB->id:0);
			break;
		case GL_FRONT_FACE:
			params[0] = (GLint) g->polygon.frontFace;
			break;
		case GL_GREEN_BIAS:
			params[0] = (GLint) g->pixel.bias.g;
			break;
		case GL_GREEN_BITS:
			params[0] = (GLint) g->limits.greenBits;
			break;
		case GL_GREEN_SCALE:
			params[0] = (GLint) g->pixel.scale.g;
			break;
		case GL_INDEX_ARRAY:
			params[0] = (GLint) g->client.array.i.enabled;
			break;
		case GL_INDEX_ARRAY_STRIDE:
			params[0] = (GLint) g->client.array.i.stride;
			break;
		case GL_INDEX_ARRAY_TYPE:
			params[0] = (GLint) g->client.array.i.type;
			break;
		case GL_INDEX_BITS:
			params[0] = (GLint) g->limits.indexBits;
			break;
		case GL_INDEX_CLEAR_VALUE:
			params[0] = __clampf_to_int(g->buffer.indexClearValue);
			break;
		case GL_INDEX_LOGIC_OP:
			params[0] = (GLint) g->buffer.indexLogicOp;
			break;
		case GL_INDEX_MODE:
			params[0] = (GLint) (!g->limits.rgbaMode);
			break;
		case GL_INDEX_OFFSET:
			params[0] = (GLint) g->pixel.indexOffset;
			break;
		case GL_INDEX_SHIFT:
			params[0] = (GLint) g->pixel.indexShift;
			break;
		case GL_INDEX_WRITEMASK:
			params[0] = (GLint) g->buffer.indexWriteMask;
			break;
		case GL_LIGHT0:
			params[0] = (GLint) g->lighting.light[0].enable;
			break;
		case GL_LIGHT1:
			params[0] = (GLint) g->lighting.light[1].enable;
			break;
		case GL_LIGHT2:
			params[0] = (GLint) g->lighting.light[2].enable;
			break;
		case GL_LIGHT3:
			params[0] = (GLint) g->lighting.light[3].enable;
			break;
		case GL_LIGHT4:
			params[0] = (GLint) g->lighting.light[4].enable;
			break;
		case GL_LIGHT5:
			params[0] = (GLint) g->lighting.light[5].enable;
			break;
		case GL_LIGHT6:
			params[0] = (GLint) g->lighting.light[6].enable;
			break;
		case GL_LIGHT7:
			params[0] = (GLint) g->lighting.light[7].enable;
			break;
		case GL_LIGHTING:
			params[0] = (GLint) g->lighting.lighting;
			break;
		case GL_LIGHT_MODEL_AMBIENT:
			params[0] = __clampf_to_int(g->lighting.lightModelAmbient.r);
			params[1] = __clampf_to_int(g->lighting.lightModelAmbient.g);
			params[2] = __clampf_to_int(g->lighting.lightModelAmbient.b);
			params[3] = __clampf_to_int(g->lighting.lightModelAmbient.a);
			break;
		case GL_LIGHT_MODEL_LOCAL_VIEWER:
			params[0] = (GLint) g->lighting.lightModelLocalViewer;
			break;
		case GL_LIGHT_MODEL_TWO_SIDE:
			params[0] = (GLint) g->lighting.lightModelTwoSide;
			break;
		case GL_LINE_SMOOTH:
			params[0] = (GLint) g->line.lineSmooth;
			break;
		case GL_LINE_SMOOTH_HINT:
			params[0] = (GLint) g->hint.lineSmooth;
			break;
		case GL_LINE_STIPPLE:
			params[0] = (GLint) g->line.lineStipple;
			break;
		case GL_LINE_STIPPLE_PATTERN:
			params[0] = (GLint) g->line.pattern;
			break;
		case GL_LINE_STIPPLE_REPEAT:
			params[0] = (GLint) g->line.repeat;
			break;
		case GL_LINE_WIDTH:
			params[0] = (GLint) g->line.width;
			break;
		case GL_LIST_BASE:
			params[0] = (GLint) g->lists.base;
			break;
		case GL_LIST_INDEX:
			params[0] = (GLint) g->lists.currentIndex;
			break;
		case GL_LIST_MODE:
			params[0] = (GLint) g->lists.mode;
			break;
		case GL_LOGIC_OP_MODE:
			params[0] = (GLint) g->buffer.logicOpMode;
			break;
		case GL_MAP1_COLOR_4:
			params[0] = (GLint) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_GRID_DOMAIN:
			params[0] = (GLint) g->eval.u11D;
			params[1] = (GLint) g->eval.u21D;
			break;
		case GL_MAP1_GRID_SEGMENTS:
			params[0] = (GLint) g->eval.un1D;
			break;
		case GL_MAP1_INDEX:
			params[0] = (GLint) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_NORMAL:
			params[0] = (GLint) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_TEXTURE_COORD_1:
			params[0] = (GLint) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_TEXTURE_COORD_2:
			params[0] = (GLint) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_TEXTURE_COORD_3:
			params[0] = (GLint) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_TEXTURE_COORD_4:
			params[0] = (GLint) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_VERTEX_3:
			params[0] = (GLint) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP1_VERTEX_4:
			params[0] = (GLint) g->eval.enable1D[pname-GL_MAP1_COLOR_4];
			break;
		case GL_MAP2_COLOR_4:
			params[0] = (GLint) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_GRID_DOMAIN:
			params[0] = (GLint) g->eval.u12D;
			params[1] = (GLint) g->eval.u22D;
			params[2] = (GLint) g->eval.v12D;
			params[3] = (GLint) g->eval.v22D;
			break;
		case GL_MAP2_GRID_SEGMENTS:
			params[0] = (GLint) g->eval.un2D;
			params[1] = (GLint) g->eval.vn2D;
			break;
		case GL_MAP2_INDEX:
			params[0] = (GLint) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_NORMAL:
			params[0] = (GLint) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_TEXTURE_COORD_1:
			params[0] = (GLint) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_TEXTURE_COORD_2:
			params[0] = (GLint) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_TEXTURE_COORD_3:
			params[0] = (GLint) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_TEXTURE_COORD_4:
			params[0] = (GLint) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_VERTEX_3:
			params[0] = (GLint) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP2_VERTEX_4:
			params[0] = (GLint) g->eval.enable2D[pname-GL_MAP2_COLOR_4];
			break;
		case GL_MAP_COLOR:
			params[0] = (GLint) g->pixel.mapColor;
			break;
		case GL_MAP_STENCIL:
			params[0] = (GLint) g->pixel.mapStencil;
			break;
		case GL_MATRIX_MODE:
			params[0] = (GLint) g->transform.matrixMode;
			break;
		case GL_MAX_3D_TEXTURE_SIZE:
			params[0] = (GLint) g->limits.max3DTextureSize;
			break;
		case GL_MAX_ATTRIB_STACK_DEPTH:
			params[0] = (GLint) g->limits.maxAttribStackDepth;
			break;
		case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
			params[0] = (GLint) g->limits.maxClientAttribStackDepth;
			break;
		case GL_MAX_CLIP_PLANES:
			params[0] = (GLint) g->limits.maxClipPlanes;
			break;
		case GL_MAX_COLOR_MATRIX_STACK_DEPTH:
			params[0] = (GLint) g->limits.maxColorStackDepth;
			break;
		case GL_MAX_ELEMENTS_INDICES:
			params[0] = (GLint) g->limits.maxElementsIndices;
			break;
		case GL_MAX_ELEMENTS_VERTICES:
			params[0] = (GLint) g->limits.maxElementsVertices;
			break;
		case GL_MAX_EVAL_ORDER:
			params[0] = (GLint) g->limits.maxEvalOrder;
			break;
		case GL_MAX_LIGHTS:
			params[0] = (GLint) g->limits.maxLights;
			break;
		case GL_MAX_LIST_NESTING:
			params[0] = (GLint) g->limits.maxListNesting;
			break;
		case GL_MAX_MODELVIEW_STACK_DEPTH:
			params[0] = (GLint) g->limits.maxModelviewStackDepth;
			break;
		case GL_MAX_NAME_STACK_DEPTH:
			params[0] = (GLint) g->limits.maxNameStackDepth;
			break;
		case GL_MAX_PIXEL_MAP_TABLE:
			params[0] = (GLint) g->limits.maxPixelMapTable;
			break;
		case GL_MAX_PROJECTION_STACK_DEPTH:
			params[0] = (GLint) g->limits.maxProjectionStackDepth;
			break;
		case GL_MAX_TEXTURE_SIZE:
			params[0] = (GLint) g->limits.maxTextureSize;
			break;
		case GL_MAX_TEXTURE_STACK_DEPTH:
			params[0] = (GLint) g->limits.maxTextureStackDepth;
			break;
		case GL_MAX_TEXTURE_UNITS_ARB:
			params[0] = (GLint) g->limits.maxTextureUnits;
			break;
		case GL_MAX_VERTEX_ATTRIBS_ARB:
			params[0] = (GLint) g->limits.maxVertexProgramAttribs;
			break;
		case GL_MAX_VIEWPORT_DIMS:
			params[0] = (GLint) g->limits.maxViewportDims[0];
			params[1] = (GLint) g->limits.maxViewportDims[1];
			break;
		case GL_MODELVIEW_MATRIX:
			params[0] = (GLint) g->transform.modelViewStack.top->m00;
			params[1] = (GLint) g->transform.modelViewStack.top->m01;
			params[2] = (GLint) g->transform.modelViewStack.top->m02;
			params[3] = (GLint) g->transform.modelViewStack.top->m03;
			params[4] = (GLint) g->transform.modelViewStack.top->m10;
			params[5] = (GLint) g->transform.modelViewStack.top->m11;
			params[6] = (GLint) g->transform.modelViewStack.top->m12;
			params[7] = (GLint) g->transform.modelViewStack.top->m13;
			params[8] = (GLint) g->transform.modelViewStack.top->m20;
			params[9] = (GLint) g->transform.modelViewStack.top->m21;
			params[10] = (GLint) g->transform.modelViewStack.top->m22;
			params[11] = (GLint) g->transform.modelViewStack.top->m23;
			params[12] = (GLint) g->transform.modelViewStack.top->m30;
			params[13] = (GLint) g->transform.modelViewStack.top->m31;
			params[14] = (GLint) g->transform.modelViewStack.top->m32;
			params[15] = (GLint) g->transform.modelViewStack.top->m33;
			break;
		case GL_MODELVIEW_STACK_DEPTH:
			params[0] = (GLint) g->transform.modelViewStack.depth+1;
			break;
		case GL_NAME_STACK_DEPTH:
			params[0] = (GLint) 0;
			break;
		case GL_NORMALIZE:
			params[0] = (GLint) g->transform.normalize;
			break;
		case GL_NORMAL_ARRAY:
			params[0] = (GLint) g->client.array.n.enabled;
			break;
		case GL_NORMAL_ARRAY_STRIDE:
			params[0] = (GLint) g->client.array.n.stride;
			break;
		case GL_NORMAL_ARRAY_TYPE:
			params[0] = (GLint) g->client.array.n.type;
			break;
		case GL_PACK_ALIGNMENT:
			params[0] = (GLint) g->client.pack.alignment;
			break;
		case GL_PACK_IMAGE_HEIGHT:
			params[0] = (GLint) g->client.pack.imageHeight;
			break;
		case GL_PACK_LSB_FIRST:
			params[0] = (GLint) g->client.pack.psLSBFirst;
			break;
		case GL_PACK_ROW_LENGTH:
			params[0] = (GLint) g->client.pack.rowLength;
			break;
		case GL_PACK_SKIP_IMAGES:
			params[0] = (GLint) g->client.pack.skipImages;
			break;
		case GL_PACK_SKIP_PIXELS:
			params[0] = (GLint) g->client.pack.skipPixels;
			break;
		case GL_PACK_SKIP_ROWS:
			params[0] = (GLint) g->client.pack.skipRows;
			break;
		case GL_PACK_SWAP_BYTES:
			params[0] = (GLint) g->client.pack.swapBytes;
			break;
		case GL_PERSPECTIVE_CORRECTION_HINT:
			params[0] = (GLint) g->hint.perspectiveCorrection;
			break;
		case GL_PIXEL_MAP_A_TO_A_SIZE:
			params[0] = (GLint) g->pixel.mapAtoAsize;
			break;
		case GL_PIXEL_MAP_B_TO_B_SIZE:
			params[0] = (GLint) g->pixel.mapBtoBsize;
			break;
		case GL_PIXEL_MAP_G_TO_G_SIZE:
			params[0] = (GLint) g->pixel.mapGtoGsize;
			break;
		case GL_PIXEL_MAP_I_TO_A_SIZE:
			params[0] = (GLint) g->pixel.mapItoAsize;
			break;
		case GL_PIXEL_MAP_I_TO_B_SIZE:
			params[0] = (GLint) g->pixel.mapItoBsize;
			break;
		case GL_PIXEL_MAP_I_TO_G_SIZE:
			params[0] = (GLint) g->pixel.mapItoGsize;
			break;
		case GL_PIXEL_MAP_I_TO_I_SIZE:
			params[0] = (GLint) g->pixel.mapItoIsize;
			break;
		case GL_PIXEL_MAP_I_TO_R_SIZE:
			params[0] = (GLint) g->pixel.mapItoRsize;
			break;
		case GL_PIXEL_MAP_R_TO_R_SIZE:
			params[0] = (GLint) g->pixel.mapRtoRsize;
			break;
		case GL_PIXEL_MAP_S_TO_S_SIZE:
			params[0] = (GLint) g->pixel.mapStoSsize;
			break;
		case GL_POINT_DISTANCE_ATTENUATION_ARB:
			params[0] = (GLint) g->point.distanceAttenuation[0];
			params[1] = (GLint) g->point.distanceAttenuation[1];
			params[2] = (GLint) g->point.distanceAttenuation[2];
			break;
		case GL_POINT_FADE_THRESHOLD_SIZE_ARB:
			params[0] = (GLint) g->point.fadeThresholdSize;
			break;
		case GL_POINT_SIZE:
			params[0] = (GLint) g->point.pointSize;
			break;
		case GL_POINT_SIZE_MAX_ARB:
			params[0] = (GLint) g->point.maxSize;
			break;
		case GL_POINT_SIZE_MIN_ARB:
			params[0] = (GLint) g->point.minSize;
			break;
		case GL_POINT_SMOOTH:
			params[0] = (GLint) g->point.pointSmooth;
			break;
		case GL_POINT_SMOOTH_HINT:
			params[0] = (GLint) g->hint.pointSmooth;
			break;
		case GL_POINT_SPRITE_COORD_ORIGIN:
			params[0] = (GLint) g->point.spriteCoordOrigin;
			break;
		case GL_POLYGON_MODE:
			params[0] = (GLint) g->polygon.frontMode;
			params[1] = (GLint) g->polygon.backMode;
			break;
		case GL_POLYGON_OFFSET_FACTOR:
			params[0] = (GLint) g->polygon.offsetFactor;
			break;
		case GL_POLYGON_OFFSET_FILL:
			params[0] = (GLint) g->polygon.polygonOffsetFill;
			break;
		case GL_POLYGON_OFFSET_LINE:
			params[0] = (GLint) g->polygon.polygonOffsetLine;
			break;
		case GL_POLYGON_OFFSET_POINT:
			params[0] = (GLint) g->polygon.polygonOffsetPoint;
			break;
		case GL_POLYGON_OFFSET_UNITS:
			params[0] = (GLint) g->polygon.offsetUnits;
			break;
		case GL_POLYGON_SMOOTH:
			params[0] = (GLint) g->polygon.polygonSmooth;
			break;
		case GL_POLYGON_SMOOTH_HINT:
			params[0] = (GLint) g->hint.polygonSmooth;
			break;
		case GL_POLYGON_STIPPLE:
			params[0] = (GLint) g->polygon.polygonStipple;
			break;
		case GL_PROJECTION_MATRIX:
			params[0] = (GLint) g->transform.projectionStack.top->m00;
			params[1] = (GLint) g->transform.projectionStack.top->m01;
			params[2] = (GLint) g->transform.projectionStack.top->m02;
			params[3] = (GLint) g->transform.projectionStack.top->m03;
			params[4] = (GLint) g->transform.projectionStack.top->m10;
			params[5] = (GLint) g->transform.projectionStack.top->m11;
			params[6] = (GLint) g->transform.projectionStack.top->m12;
			params[7] = (GLint) g->transform.projectionStack.top->m13;
			params[8] = (GLint) g->transform.projectionStack.top->m20;
			params[9] = (GLint) g->transform.projectionStack.top->m21;
			params[10] = (GLint) g->transform.projectionStack.top->m22;
			params[11] = (GLint) g->transform.projectionStack.top->m23;
			params[12] = (GLint) g->transform.projectionStack.top->m30;
			params[13] = (GLint) g->transform.projectionStack.top->m31;
			params[14] = (GLint) g->transform.projectionStack.top->m32;
			params[15] = (GLint) g->transform.projectionStack.top->m33;
			break;
		case GL_PROJECTION_STACK_DEPTH:
			params[0] = (GLint) g->transform.projectionStack.depth+1;
			break;
		case GL_READ_BUFFER:
			params[0] = (GLint) __getReadBuffer(g);
			break;
		case GL_READ_FRAMEBUFFER_BINDING:
			params[0] = (GLint) (g->framebufferobject.readFB?g->framebufferobject.readFB->id:0);
			break;
		case GL_RED_BIAS:
			params[0] = (GLint) g->pixel.bias.r;
			break;
		case GL_RED_BITS:
			params[0] = (GLint) g->limits.redBits;
			break;
		case GL_RED_SCALE:
			params[0] = (GLint) g->pixel.scale.r;
			break;
		case GL_RENDERBUFFER_BINDING_EXT:
			params[0] = (GLint) (g->framebufferobject.renderbuffer?g->framebufferobject.renderbuffer->id:0);
			break;
		case GL_RENDER_MODE:
			params[0] = (GLint) g->renderMode;
			break;
		case GL_RGBA_MODE:
			params[0] = (GLint) g->limits.rgbaMode;
			break;
		case GL_SCISSOR_BOX:
			params[0] = (GLint) g->viewport.scissorX;
			params[1] = (GLint) g->viewport.scissorY;
			params[2] = (GLint) g->viewport.scissorW;
			params[3] = (GLint) g->viewport.scissorH;
			break;
		case GL_SCISSOR_TEST:
			params[0] = (GLint) g->viewport.scissorTest;
			break;
		case GL_SELECTION_BUFFER_SIZE:
			params[0] = (GLint) g->selection.bufferSize;
			break;
		case GL_SHADE_MODEL:
			params[0] = (GLint) g->lighting.shadeModel;
			break;
		case GL_SMOOTH_LINE_WIDTH_GRANULARITY:
			params[0] = (GLint) g->limits.lineWidthGranularity;
			break;
		case GL_SMOOTH_LINE_WIDTH_RANGE:
			params[0] = (GLint) g->limits.smoothLineWidthRange[0];
			params[1] = (GLint) g->limits.smoothLineWidthRange[1];
			break;
		case GL_SMOOTH_POINT_SIZE_GRANULARITY:
			params[0] = (GLint) g->limits.pointSizeGranularity;
			break;
		case GL_SMOOTH_POINT_SIZE_RANGE:
			params[0] = (GLint) g->limits.smoothPointSizeRange[0];
			params[1] = (GLint) g->limits.smoothPointSizeRange[1];
			break;
		case GL_STENCIL_BACK_FAIL:
			params[0] = (GLint) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].fail;
			break;
		case GL_STENCIL_BACK_FUNC:
			params[0] = (GLint) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].func;
			break;
		case GL_STENCIL_BACK_PASS_DEPTH_FAIL:
			params[0] = (GLint) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthFail;
			break;
		case GL_STENCIL_BACK_PASS_DEPTH_PASS:
			params[0] = (GLint) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthPass;
			break;
		case GL_STENCIL_BACK_REF:
			params[0] = (GLint) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].ref;
			break;
		case GL_STENCIL_BACK_VALUE_MASK:
			params[0] = (GLint) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_BACK:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].mask;
			break;
		case GL_STENCIL_BITS:
			params[0] = (GLint) g->limits.stencilBits;
			break;
		case GL_STENCIL_CLEAR_VALUE:
			params[0] = (GLint) g->stencil.clearValue;
			break;
		case GL_STENCIL_FAIL:
			params[0] = (GLint) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].fail;
			break;
		case GL_STENCIL_FUNC:
			params[0] = (GLint) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].func;
			break;
		case GL_STENCIL_PASS_DEPTH_FAIL:
			params[0] = (GLint) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthFail;
			break;
		case GL_STENCIL_PASS_DEPTH_PASS:
			params[0] = (GLint) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].passDepthPass;
			break;
		case GL_STENCIL_REF:
			params[0] = (GLint) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].ref;
			break;
		case GL_STENCIL_TEST:
			params[0] = (GLint) g->stencil.stencilTest;
			break;
		case GL_STENCIL_VALUE_MASK:
			params[0] = (GLint) g->stencil.buffers[g->stencil.activeStencilFace==GL_FRONT?CRSTATE_STENCIL_BUFFER_ID_FRONT:CRSTATE_STENCIL_BUFFER_ID_TWO_SIDE_BACK].mask;
			break;
		case GL_STENCIL_WRITEMASK:
			params[0] = (GLint) g->stencil.writeMask;
			break;
		case GL_STEREO:
			params[0] = (GLint) g->limits.stereo;
			break;
		case GL_SUBPIXEL_BITS:
			params[0] = (GLint) g->limits.subpixelBits;
			break;
		case GL_TEXTURE_1D:
			params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].enabled1D;
			break;
		case GL_TEXTURE_2D:
			params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].enabled2D;
			break;
		case GL_TEXTURE_3D:
			params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].enabled3D;
			break;
		case GL_TEXTURE_BINDING_1D:
			params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].currentTexture1D->id;
			break;
		case GL_TEXTURE_BINDING_2D:
			params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].currentTexture2D->id;
			break;
		case GL_TEXTURE_BINDING_3D:
			params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].currentTexture3D->id;
			break;
		case GL_TEXTURE_COORD_ARRAY:
			params[0] = (GLint) g->client.array.t[g->client.curClientTextureUnit].enabled;
			break;
		case GL_TEXTURE_COORD_ARRAY_SIZE:
			params[0] = (GLint) g->client.array.t[g->client.curClientTextureUnit].size;
			break;
		case GL_TEXTURE_COORD_ARRAY_STRIDE:
			params[0] = (GLint) g->client.array.t[g->client.curClientTextureUnit].stride;
			break;
		case GL_TEXTURE_COORD_ARRAY_TYPE:
			params[0] = (GLint) g->client.array.t[g->client.curClientTextureUnit].type;
			break;
		case GL_TEXTURE_ENV_MODE:
			params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].envMode;
			break;
		case GL_TEXTURE_GEN_Q:
			params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].textureGen.q;
			break;
		case GL_TEXTURE_GEN_R:
			params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].textureGen.r;
			break;
		case GL_TEXTURE_GEN_S:
			params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].textureGen.s;
			break;
		case GL_TEXTURE_GEN_T:
			params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].textureGen.t;
			break;
		case GL_TEXTURE_MATRIX:
			params[0] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m00;
			params[1] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m01;
			params[2] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m02;
			params[3] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m03;
			params[4] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m10;
			params[5] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m11;
			params[6] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m12;
			params[7] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m13;
			params[8] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m20;
			params[9] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m21;
			params[10] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m22;
			params[11] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m23;
			params[12] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m30;
			params[13] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m31;
			params[14] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m32;
			params[15] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m33;
			break;
		case GL_TEXTURE_STACK_DEPTH:
			params[0] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].depth+1;
			break;
		case GL_UNPACK_ALIGNMENT:
			params[0] = (GLint) g->client.unpack.alignment;
			break;
		case GL_UNPACK_IMAGE_HEIGHT:
			params[0] = (GLint) g->client.unpack.imageHeight;
			break;
		case GL_UNPACK_LSB_FIRST:
			params[0] = (GLint) g->client.unpack.psLSBFirst;
			break;
		case GL_UNPACK_ROW_LENGTH:
			params[0] = (GLint) g->client.unpack.rowLength;
			break;
		case GL_UNPACK_SKIP_IMAGES:
			params[0] = (GLint) g->client.unpack.skipImages;
			break;
		case GL_UNPACK_SKIP_PIXELS:
			params[0] = (GLint) g->client.unpack.skipPixels;
			break;
		case GL_UNPACK_SKIP_ROWS:
			params[0] = (GLint) g->client.unpack.skipRows;
			break;
		case GL_UNPACK_SWAP_BYTES:
			params[0] = (GLint) g->client.unpack.swapBytes;
			break;
		case GL_VERTEX_ARRAY:
			params[0] = (GLint) g->client.array.v.enabled;
			break;
		case GL_VERTEX_ARRAY_SIZE:
			params[0] = (GLint) g->client.array.v.size;
			break;
		case GL_VERTEX_ARRAY_STRIDE:
			params[0] = (GLint) g->client.array.v.stride;
			break;
		case GL_VERTEX_ARRAY_TYPE:
			params[0] = (GLint) g->client.array.v.type;
			break;
		case GL_VIEWPORT:
			params[0] = (GLint) g->viewport.viewportX;
			params[1] = (GLint) g->viewport.viewportY;
			params[2] = (GLint) g->viewport.viewportW;
			params[3] = (GLint) g->viewport.viewportH;
			break;
		case GL_ZOOM_X:
			params[0] = (GLint) g->pixel.xZoom;
			break;
		case GL_ZOOM_Y:
			params[0] = (GLint) g->pixel.yZoom;
			break;
#ifdef CR_ARB_vertex_buffer_object
		case GL_ARRAY_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_vertex_buffer_object) {
				params[0] = (GLint) g->bufferobject.arrayBuffer->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_EXT_blend_color
		case GL_BLEND_COLOR_EXT:
			if (g->extensions.EXT_blend_color) {
				params[0] = __clampf_to_int(g->buffer.blendColor.r);
				params[1] = __clampf_to_int(g->buffer.blendColor.g);
				params[2] = __clampf_to_int(g->buffer.blendColor.b);
				params[3] = __clampf_to_int(g->buffer.blendColor.a);
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_blend_color */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_DST_ALPHA_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLint) g->buffer.blendDstA;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_DST_RGB_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLint) g->buffer.blendDstRGB;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_minmax
		case GL_BLEND_EQUATION_EXT:
			if (g->extensions.EXT_blend_minmax) {
				params[0] = (GLint) g->buffer.blendEquation;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_blend_minmax */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_SRC_ALPHA_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLint) g->buffer.blendSrcA;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_EXT_blend_func_separate
		case GL_BLEND_SRC_RGB_EXT:
			if (g->extensions.EXT_blend_func_separate) {
				params[0] = (GLint) g->buffer.blendSrcRGB;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_blend_func_separate */
#ifdef CR_NV_register_combiners
		case GL_COLOR_SUM_CLAMP_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLint) g->regcombiner.colorSumClamp;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_EXT_secondary_color
		case GL_COLOR_SUM_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLint) g->lighting.colorSumEXT;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_ARB_texture_compression
		case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
			if (g->extensions.ARB_texture_compression) {
				params[0] = (GLint) g->limits.compressedFormats[0];
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_texture_compression */
#ifdef CR_NV_register_combiners
		case GL_CONSTANT_COLOR0_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLint) g->regcombiner.constantColor0.r;
				params[1] = (GLint) g->regcombiner.constantColor0.g;
				params[2] = (GLint) g->regcombiner.constantColor0.b;
				params[3] = (GLint) g->regcombiner.constantColor0.a;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
		case GL_CONSTANT_COLOR1_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLint) g->regcombiner.constantColor1.r;
				params[1] = (GLint) g->regcombiner.constantColor1.g;
				params[2] = (GLint) g->regcombiner.constantColor1.b;
				params[3] = (GLint) g->regcombiner.constantColor1.a;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_EXT_fog_coord
		case GL_CURRENT_FOG_COORDINATE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLint) g->current.vertexAttrib[VERT_ATTRIB_FOG][0];
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_secondary_color
		case GL_CURRENT_SECONDARY_COLOR_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLint) g->current.vertexAttrib[VERT_ATTRIB_COLOR1][0];
				params[1] = (GLint) g->current.vertexAttrib[VERT_ATTRIB_COLOR1][1];
				params[2] = (GLint) g->current.vertexAttrib[VERT_ATTRIB_COLOR1][2];
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_ARB_vertex_buffer_object
		case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_vertex_buffer_object) {
				params[0] = (GLint) g->bufferobject.elementsBuffer->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_ARRAY_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLint) g->client.array.f.enabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLint) g->client.array.f.stride;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLint) g->client.array.f.type;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_EXT_fog_coord
		case GL_FOG_COORDINATE_SOURCE_EXT:
			if (g->extensions.EXT_fog_coord) {
				params[0] = (GLint) g->fog.fogCoordinateSource;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_fog_coord */
#ifdef CR_NV_fog_distance
		case GL_FOG_DISTANCE_MODE_NV:
			if (g->extensions.NV_fog_distance) {
				params[0] = (GLint) g->fog.fogDistanceMode;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_fog_distance */
#ifdef CR_ARB_fragment_program
		case GL_FRAGMENT_PROGRAM_ARB:
			if (g->extensions.ARB_fragment_program) {
				params[0] = (GLint) g->program.fpEnabledARB;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_fragment_program */
#ifdef CR_NV_fragment_program
		case GL_FRAGMENT_PROGRAM_BINDING_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLint) g->program.fpProgramBinding;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_fragment_program
		case GL_FRAGMENT_PROGRAM_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLint) g->program.fpEnabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_SGIS_generate_mipmap
		case GL_GENERATE_MIPMAP_HINT:
			if (g->extensions.SGIS_generate_mipmap) {
				params[0] = (GLint) g->hint.generateMipmap;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_SGIS_generate_mipmap */
#ifdef CR_OPENGL_VERSION_1_2
		case GL_LIGHT_MODEL_COLOR_CONTROL:
			params[0] = (GLint) g->lighting.lightModelColorControlEXT;
			break;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_EXT_separate_specular_color
		case GL_LIGHT_MODEL_COLOR_CONTROL_EXT:
			if (g->extensions.EXT_separate_specular_color) {
				params[0] = (GLint) g->lighting.lightModelColorControlEXT;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_separate_specular_color */
#ifdef CR_ARB_texture_cube_map
		case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
			if (g->extensions.ARB_texture_cube_map) {
				params[0] = (GLint) g->limits.maxCubeMapTextureSize;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_fragment_program
		case GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLint) g->limits.maxFragmentProgramLocalParams;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_register_combiners
		case GL_MAX_GENERAL_COMBINERS_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLint) g->limits.maxGeneralCombiners;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_texture_rectangle
		case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
			if (g->extensions.NV_texture_rectangle) {
				params[0] = (GLint) g->limits.maxRectTextureSize;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_NV_fragment_program
		case GL_MAX_TEXTURE_COORDS_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLint) g->limits.maxTextureCoords;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_NV_fragment_program
		case GL_MAX_TEXTURE_IMAGE_UNITS_NV:
			if (g->extensions.NV_fragment_program) {
				params[0] = (GLint) g->limits.maxTextureImageUnits;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_fragment_program */
#ifdef CR_EXT_texture_lod_bias
		case GL_MAX_TEXTURE_LOD_BIAS_EXT:
			if (g->extensions.EXT_texture_lod_bias) {
				params[0] = (GLint) g->limits.maxTextureLodBias;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_texture_lod_bias */
#ifdef CR_EXT_texture_filter_anisotropic
		case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
			if (g->extensions.EXT_texture_filter_anisotropic) {
				params[0] = (GLint) g->limits.maxTextureAnisotropy;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_texture_filter_anisotropic */
#ifdef CR_ARB_multisample
		case GL_MULTISAMPLE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLint) g->multisample.enabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_texture_compression
		case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
			if (g->extensions.ARB_texture_compression) {
				params[0] = (GLint) g->limits.numCompressedFormats;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_texture_compression */
#ifdef CR_NV_register_combiners
		case GL_NUM_GENERAL_COMBINERS_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLint) g->regcombiner.numGeneralCombiners;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners2
		case GL_PER_STAGE_CONSTANTS_NV:
			if (g->extensions.NV_register_combiners2) {
				params[0] = (GLint) g->regcombiner.enabledPerStageConstants;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_register_combiners2 */
#ifdef CR_ARB_pixel_buffer_object
		case GL_PIXEL_PACK_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_pixel_buffer_object) {
				params[0] = (GLint) g->bufferobject.packBuffer->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_pixel_buffer_object */
#ifdef CR_ARB_pixel_buffer_object
		case GL_PIXEL_UNPACK_BUFFER_BINDING_ARB:
			if (g->extensions.ARB_pixel_buffer_object) {
				params[0] = (GLint) g->bufferobject.unpackBuffer->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_pixel_buffer_object */
#ifdef CR_ARB_point_sprite
		case GL_POINT_SPRITE_ARB:
			if (g->extensions.ARB_point_sprite) {
				params[0] = (GLint) g->point.pointSprite;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_point_sprite */
#ifdef CR_any_program
		case GL_PROGRAM_ERROR_POSITION_NV:
			if (g->extensions.any_program) {
				params[0] = (GLint) g->program.errorPos;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_any_program */
#ifdef CR_NV_register_combiners
		case GL_REGISTER_COMBINERS_NV:
			if (g->extensions.NV_register_combiners) {
				params[0] = (GLint) g->regcombiner.enabledRegCombiners;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_register_combiners */
#ifdef CR_OPENGL_VERSION_1_2
		case GL_RESCALE_NORMAL:
			params[0] = (GLint) g->transform.rescaleNormals;
			break;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_ARB_multisample
		case GL_SAMPLES_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLint) g->limits.samples;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLint) g->multisample.sampleAlphaToCoverage;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_ALPHA_TO_ONE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLint) g->multisample.sampleAlphaToOne;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_BUFFERS_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLint) g->limits.sampleBuffers;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_COVERAGE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLint) g->multisample.sampleCoverage;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_COVERAGE_INVERT_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLint) g->multisample.sampleCoverageInvert;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_ARB_multisample
		case GL_SAMPLE_COVERAGE_VALUE_ARB:
			if (g->extensions.ARB_multisample) {
				params[0] = (GLint) g->multisample.sampleCoverageValue;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_multisample */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLint) g->client.array.s.enabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLint) g->client.array.s.size;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLint) g->client.array.s.stride;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_EXT_secondary_color
		case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
			if (g->extensions.EXT_secondary_color) {
				params[0] = (GLint) g->client.array.s.type;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_EXT_secondary_color */
#ifdef CR_ARB_texture_cube_map
		case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
			if (g->extensions.ARB_texture_cube_map) {
				params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].currentTextureCubeMap->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_texture_rectangle
		case GL_TEXTURE_BINDING_RECTANGLE_NV:
			if (g->extensions.NV_texture_rectangle) {
				params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].currentTextureRect->id;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_ARB_texture_compression
		case GL_TEXTURE_COMPRESSION_HINT_ARB:
			if (g->extensions.ARB_texture_compression) {
				params[0] = (GLint) g->hint.textureCompression;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_texture_compression */
#ifdef CR_ARB_texture_cube_map
		case GL_TEXTURE_CUBE_MAP_ARB:
			if (g->extensions.ARB_texture_cube_map) {
				params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].enabledCubeMap;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_texture_cube_map */
#ifdef CR_NV_texture_rectangle
		case GL_TEXTURE_RECTANGLE_NV:
			if (g->extensions.NV_texture_rectangle) {
				params[0] = (GLint) g->texture.unit[g->texture.curTextureUnit].enabledRect;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_texture_rectangle */
#ifdef CR_ARB_transpose_matrix
		case GL_TRANSPOSE_MODELVIEW_MATRIX:
			if (g->extensions.ARB_transpose_matrix) {
				params[0] = (GLint) g->transform.modelViewStack.top->m00;
				params[1] = (GLint) g->transform.modelViewStack.top->m10;
				params[2] = (GLint) g->transform.modelViewStack.top->m20;
				params[3] = (GLint) g->transform.modelViewStack.top->m30;
				params[4] = (GLint) g->transform.modelViewStack.top->m01;
				params[5] = (GLint) g->transform.modelViewStack.top->m11;
				params[6] = (GLint) g->transform.modelViewStack.top->m21;
				params[7] = (GLint) g->transform.modelViewStack.top->m31;
				params[8] = (GLint) g->transform.modelViewStack.top->m02;
				params[9] = (GLint) g->transform.modelViewStack.top->m12;
				params[10] = (GLint) g->transform.modelViewStack.top->m22;
				params[11] = (GLint) g->transform.modelViewStack.top->m32;
				params[12] = (GLint) g->transform.modelViewStack.top->m03;
				params[13] = (GLint) g->transform.modelViewStack.top->m13;
				params[14] = (GLint) g->transform.modelViewStack.top->m23;
				params[15] = (GLint) g->transform.modelViewStack.top->m33;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_ARB_transpose_matrix
		case GL_TRANSPOSE_PROJECTION_MATRIX:
			if (g->extensions.ARB_transpose_matrix) {
				params[0] = (GLint) g->transform.projectionStack.top->m00;
				params[1] = (GLint) g->transform.projectionStack.top->m10;
				params[2] = (GLint) g->transform.projectionStack.top->m20;
				params[3] = (GLint) g->transform.projectionStack.top->m30;
				params[4] = (GLint) g->transform.projectionStack.top->m01;
				params[5] = (GLint) g->transform.projectionStack.top->m11;
				params[6] = (GLint) g->transform.projectionStack.top->m21;
				params[7] = (GLint) g->transform.projectionStack.top->m31;
				params[8] = (GLint) g->transform.projectionStack.top->m02;
				params[9] = (GLint) g->transform.projectionStack.top->m12;
				params[10] = (GLint) g->transform.projectionStack.top->m22;
				params[11] = (GLint) g->transform.projectionStack.top->m32;
				params[12] = (GLint) g->transform.projectionStack.top->m03;
				params[13] = (GLint) g->transform.projectionStack.top->m13;
				params[14] = (GLint) g->transform.projectionStack.top->m23;
				params[15] = (GLint) g->transform.projectionStack.top->m33;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_ARB_transpose_matrix
		case GL_TRANSPOSE_TEXTURE_MATRIX:
			if (g->extensions.ARB_transpose_matrix) {
				params[0] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m00;
				params[1] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m10;
				params[2] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m20;
				params[3] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m30;
				params[4] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m01;
				params[5] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m11;
				params[6] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m21;
				params[7] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m31;
				params[8] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m02;
				params[9] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m12;
				params[10] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m22;
				params[11] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m32;
				params[12] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m03;
				params[13] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m13;
				params[14] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m23;
				params[15] = (GLint) g->transform.textureStack[g->texture.curTextureUnit].top->m33;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_ARB_transpose_matrix */
#ifdef CR_NV_vertex_program
		case GL_VERTEX_PROGRAM_BINDING_NV:
			if (g->extensions.NV_vertex_program) {
				params[0] = (GLint) g->program.vpProgramBinding;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_NV_vertex_program */
#ifdef CR_any_vertex_program
		case GL_VERTEX_PROGRAM_NV:
			if (g->extensions.any_vertex_program) {
				params[0] = (GLint) g->program.vpEnabled;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
		case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
			if (g->extensions.any_vertex_program) {
				params[0] = (GLint) g->program.vpPointSize;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
		case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
			if (g->extensions.any_vertex_program) {
				params[0] = (GLint) g->program.vpTwoSide;
			}
			else {
				crStateError(__LINE__,__FILE__,GL_INVALID_ENUM, "glGetIntegerv");
			}
			break;
#endif /* CR_any_vertex_program */
		default:
			crStateError(__LINE__, __FILE__, GL_INVALID_ENUM, "glGet: Unknown enum: 0x%x", pname);
			return;
	}
}
unsigned int crStateHlpComponentsCount( GLenum pname )
{
	switch( pname )
	{

			case GL_AMBIENT: return 4;
			case GL_COLOR_INDEXES: return 3;
			case GL_CONSTANT_ATTENUATION: return 1;
			case GL_DIFFUSE: return 4;
			case GL_EMISSION: return 4;
			case GL_EYE_PLANE: return 4;
			case GL_LINEAR_ATTENUATION: return 1;
			case GL_OBJECT_PLANE: return 4;
			case GL_POSITION: return 4;
			case GL_QUADRATIC_ATTENUATION: return 1;
			case GL_SHININESS: return 1;
			case GL_SPECULAR: return 4;
			case GL_SPOT_CUTOFF: return 1;
			case GL_SPOT_DIRECTION: return 3;
			case GL_SPOT_EXPONENT: return 1;
			case GL_TEXTURE_ALPHA_SIZE: return 1;
			case GL_TEXTURE_BLUE_SIZE: return 1;
			case GL_TEXTURE_BORDER: return 1;
			case GL_TEXTURE_BORDER_COLOR: return 4;
			case GL_TEXTURE_COMPONENTS: return 1;
			case GL_TEXTURE_DEPTH: return 1;
			case GL_TEXTURE_ENV_COLOR: return 4;
			case GL_TEXTURE_ENV_MODE: return 1;
			case GL_TEXTURE_GEN_MODE: return 1;
			case GL_TEXTURE_GREEN_SIZE: return 1;
			case GL_TEXTURE_HEIGHT: return 1;
			case GL_TEXTURE_INTENSITY_SIZE: return 1;
			case GL_TEXTURE_LUMINANCE_SIZE: return 1;
			case GL_TEXTURE_MAG_FILTER: return 1;
			case GL_TEXTURE_MIN_FILTER: return 1;
			case GL_TEXTURE_RED_SIZE: return 1;
			case GL_TEXTURE_RESIDENT: return 1;
			case GL_TEXTURE_WIDTH: return 1;
			case GL_TEXTURE_WRAP_S: return 1;
			case GL_TEXTURE_WRAP_T: return 1;
#ifdef CR_ARB_texture_env_combine
			case GL_ALPHA_SCALE: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_vertex_buffer_object
			case GL_BUFFER_ACCESS_ARB: return 1;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_ARB_vertex_buffer_object
			case GL_BUFFER_MAPPED_ARB: return 1;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_ARB_vertex_buffer_object
			case GL_BUFFER_SIZE_ARB: return 1;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_ARB_vertex_buffer_object
			case GL_BUFFER_USAGE_ARB: return 1;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_NV_register_combiners
			case GL_COMBINER_AB_DOT_PRODUCT_NV: return 1;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
			case GL_COMBINER_AB_OUTPUT_NV: return 1;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
			case GL_COMBINER_BIAS_NV: return 1;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
			case GL_COMBINER_CD_DOT_PRODUCT_NV: return 1;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
			case GL_COMBINER_CD_OUTPUT_NV: return 1;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
			case GL_COMBINER_COMPONENT_USAGE_NV: return 1;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
			case GL_COMBINER_INPUT_NV: return 1;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
			case GL_COMBINER_MAPPING_NV: return 1;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
			case GL_COMBINER_MUX_SUM_NV: return 1;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
			case GL_COMBINER_SCALE_NV: return 1;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
			case GL_COMBINER_SUM_OUTPUT_NV: return 1;
#endif /* CR_NV_register_combiners */
#ifdef CR_ARB_texture_env_combine
			case GL_COMBINE_ALPHA_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_texture_env_combine
			case GL_COMBINE_RGB_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_NV_register_combiners
			case GL_CONSTANT_COLOR0_NV: return 4;
#endif /* CR_NV_register_combiners */
#ifdef CR_NV_register_combiners
			case GL_CONSTANT_COLOR1_NV: return 4;
#endif /* CR_NV_register_combiners */
#ifdef CR_ARB_point_sprite
			case GL_COORD_REPLACE_ARB: return 1;
#endif /* CR_ARB_point_sprite */
#ifdef CR_ARB_occlusion_query
			case GL_CURRENT_QUERY_ARB: return 1;
#endif /* CR_ARB_occlusion_query */
#ifdef CR_any_vertex_program
			case GL_CURRENT_VERTEX_ATTRIB_ARB: return 4;
#endif /* CR_any_vertex_program */
#ifdef CR_ARB_depth_texture
			case GL_DEPTH_TEXTURE_MODE_ARB: return 1;
#endif /* CR_ARB_depth_texture */
#ifdef CR_SGIS_generate_mipmap
			case GL_GENERATE_MIPMAP_SGIS: return 1;
#endif /* CR_SGIS_generate_mipmap */
#ifdef CR_ARB_texture_env_combine
			case GL_OPERAND0_ALPHA_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_texture_env_combine
			case GL_OPERAND0_RGB_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_texture_env_combine
			case GL_OPERAND1_ALPHA_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_texture_env_combine
			case GL_OPERAND1_RGB_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_texture_env_combine
			case GL_OPERAND2_ALPHA_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_texture_env_combine
			case GL_OPERAND2_RGB_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_occlusion_query
			case GL_QUERY_COUNTER_BITS_ARB: return 1;
#endif /* CR_ARB_occlusion_query */
#ifdef CR_ARB_occlusion_query
			case GL_QUERY_RESULT_ARB: return 1;
#endif /* CR_ARB_occlusion_query */
#ifdef CR_ARB_occlusion_query
			case GL_QUERY_RESULT_AVAILABLE_ARB: return 1;
#endif /* CR_ARB_occlusion_query */
#ifdef CR_ARB_texture_env_combine
			case GL_RGB_SCALE_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_texture_env_combine
			case GL_SOURCE0_ALPHA_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_texture_env_combine
			case GL_SOURCE0_RGB_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_texture_env_combine
			case GL_SOURCE1_ALPHA_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_texture_env_combine
			case GL_SOURCE1_RGB_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_texture_env_combine
			case GL_SOURCE2_ALPHA_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_ARB_texture_env_combine
			case GL_SOURCE2_RGB_ARB: return 1;
#endif /* CR_ARB_texture_env_combine */
#ifdef CR_OPENGL_VERSION_1_2
			case GL_TEXTURE_BASE_LEVEL: return 1;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_ARB_shadow_ambient
			case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB: return 1;
#endif /* CR_ARB_shadow_ambient */
#ifdef CR_ARB_shadow
			case GL_TEXTURE_COMPARE_FUNC_ARB: return 1;
#endif /* CR_ARB_shadow */
#ifdef CR_ARB_shadow
			case GL_TEXTURE_COMPARE_MODE_ARB: return 1;
#endif /* CR_ARB_shadow */
#ifdef CR_ARB_texture_compression
			case GL_TEXTURE_COMPRESSED: return 1;
#endif /* CR_ARB_texture_compression */
#ifdef CR_ARB_texture_compression
			case GL_TEXTURE_COMPRESSED_IMAGE_SIZE: return 1;
#endif /* CR_ARB_texture_compression */
#ifdef CR_ARB_depth_texture
			case GL_TEXTURE_DEPTH_SIZE_ARB: return 1;
#endif /* CR_ARB_depth_texture */
#ifdef CR_EXT_texture_lod_bias
			case GL_TEXTURE_LOD_BIAS_EXT: return 1;
#endif /* CR_EXT_texture_lod_bias */
#ifdef CR_EXT_texture_filter_anisotropic
			case GL_TEXTURE_MAX_ANISOTROPY_EXT: return 1;
#endif /* CR_EXT_texture_filter_anisotropic */
#ifdef CR_OPENGL_VERSION_1_2
			case GL_TEXTURE_MAX_LEVEL: return 1;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_OPENGL_VERSION_1_2
			case GL_TEXTURE_MAX_LOD: return 1;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_OPENGL_VERSION_1_2
			case GL_TEXTURE_MIN_LOD: return 1;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_OPENGL_VERSION_1_2
			case GL_TEXTURE_PRIORITY: return 1;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_OPENGL_VERSION_1_2
			case GL_TEXTURE_WRAP_R: return 1;
#endif /* CR_OPENGL_VERSION_1_2 */
#ifdef CR_any_vertex_program
			case GL_TRACK_MATRIX_NV: return 24;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
			case GL_TRACK_MATRIX_TRANSFORM_NV: return 24;
#endif /* CR_any_vertex_program */
#ifdef CR_ARB_vertex_buffer_object
			case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB: return 1;
#endif /* CR_ARB_vertex_buffer_object */
#ifdef CR_any_vertex_program
			case GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB: return 1;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
			case GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB: return 1;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
			case GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB: return 1;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
			case GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB: return 1;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
			case GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB: return 1;
#endif /* CR_any_vertex_program */
#ifdef CR_any_vertex_program
			case GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB: return 1;
#endif /* CR_any_vertex_program */

		default:
			crError( "Unknown parameter name in crStateHlpComponentsCount: %d", (int) pname );
			break;
	}
	/* NOTREACHED */
	return 0;
}

