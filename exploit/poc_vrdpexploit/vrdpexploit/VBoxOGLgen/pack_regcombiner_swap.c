/* THIS FILE IS AUTOGENERATED FROM E:/home/src/VirtualBox/src/VBox/GuestHost/OpenGL/packer/pack_regcombiner.c BY pack_swap.py */


/* Copyright (c) 2001, Stanford University
 * All rights reserved
 *
 * See the file LICENSE.txt for information on redistributing this software.
 */

#include "packer.h"
#include "cr_opcodes.h"

static GLboolean __handleCombinerParameterData(GLenum pname, const GLfloat *params, GLenum extended_opcode)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned int params_length = 0;
    unsigned int packet_length = sizeof(int) + sizeof(extended_opcode) + sizeof(pname);
    unsigned char *data_ptr;

    switch(pname)
    {
        case GL_CONSTANT_COLOR0_NV:
        case GL_CONSTANT_COLOR1_NV:
            params_length = 4 * sizeof(*params);
            break;
        case GL_NUM_GENERAL_COMBINERS_NV:
        case GL_COLOR_SUM_CLAMP_NV:
            params_length = sizeof(*params);
            break;
        default:
            __PackError(__LINE__, __FILE__, GL_INVALID_ENUM,
                                     "crPackCombinerParameterSWAP(bad pname)");
            CRASSERT(0);
            return GL_FALSE;
    }
    packet_length += params_length;
    CR_GET_BUFFERED_POINTER(pc, packet_length);
    WRITE_DATA(0, int, SWAP32(packet_length));
    WRITE_DATA(sizeof(int) + 0, GLenum, SWAP32(extended_opcode));
    WRITE_DATA(sizeof(int) + 4, GLenum, SWAP32(pname));
    WRITE_DATA(sizeof(int) + 8, GLuint, SWAPFLOAT(params[0]));
    if (params_length > sizeof(*params))
    {
        WRITE_DATA(sizeof(int) + 12, GLuint, SWAPFLOAT(params[1]));
        WRITE_DATA(sizeof(int) + 16, GLuint, SWAPFLOAT(params[2]));
        WRITE_DATA(sizeof(int) + 20, GLuint, SWAPFLOAT(params[3]));
        CRASSERT(packet_length == sizeof(int) + 20 + 4);
    }
    return GL_TRUE;
}

void PACK_APIENTRY crPackCombinerParameterfvNVSWAP(GLenum pname, const GLfloat *params)
{
    CR_GET_PACKER_CONTEXT(pc);
    if (__handleCombinerParameterData(pname, params, CR_COMBINERPARAMETERFVNV_EXTEND_OPCODE))
        WRITE_OPCODE(pc, CR_EXTEND_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackCombinerParameterivNVSWAP(GLenum pname, const GLint *params)
{
    /* floats and ints are the same size, so the packing should be the same */
    CR_GET_PACKER_CONTEXT(pc);
    if (__handleCombinerParameterData(pname, (const GLfloat *) params, CR_COMBINERPARAMETERIVNV_EXTEND_OPCODE))
        WRITE_OPCODE(pc, CR_EXTEND_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}

void PACK_APIENTRY crPackCombinerStageParameterfvNVSWAP(GLenum stage, GLenum pname, const GLfloat *params)
{
    CR_GET_PACKER_CONTEXT(pc);
    unsigned char *data_ptr;

    CR_GET_BUFFERED_POINTER(pc, 32);
    WRITE_DATA(0, GLint, SWAP32(32));
    WRITE_DATA(4, GLenum, SWAP32(CR_COMBINERSTAGEPARAMETERFVNV_EXTEND_OPCODE));
    WRITE_DATA(8, GLenum, SWAP32(stage));
    WRITE_DATA(12, GLenum, SWAP32(pname));
    WRITE_DATA(16, GLuint, SWAPFLOAT(params[0]));
    WRITE_DATA(20, GLuint, SWAPFLOAT(params[1]));
    WRITE_DATA(24, GLuint, SWAPFLOAT(params[2]));
    WRITE_DATA(28, GLuint, SWAPFLOAT(params[3]));
    WRITE_OPCODE(pc, CR_EXTEND_OPCODE);
    CR_UNLOCK_PACKER_CONTEXT(pc);
}
