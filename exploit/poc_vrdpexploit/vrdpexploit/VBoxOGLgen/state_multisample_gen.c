/* This code is AUTOGENERATED!!! */

#include "state.h"
#include "state_internals.h"

void crStateMultisampleDiff(CRMultisampleBits *b, CRbitvalue *bitID,
		CRContext *fromCtx, CRContext *toCtx)
{
	CRMultisampleState *from = &(fromCtx->multisample);
	CRMultisampleState *to = &(toCtx->multisample);
	unsigned int j, i;
	CRbitvalue nbitID[CR_MAX_BITARRAY];
	for (j = 0; j<CR_MAX_BITARRAY; j++)
		nbitID[j] = ~bitID[j];
	i = 0; /* silence compiler */
	if (CHECKDIRTY(b->enable, bitID))
	{
		glAble able[2];
		able[0] = diff_api.Disable;
		able[1] = diff_api.Enable;
		if (from->enabled != to->enabled)
		{
			able[to->enabled](GL_MULTISAMPLE_ARB);
			from->enabled = to->enabled;
		}
		if (from->sampleAlphaToCoverage != to->sampleAlphaToCoverage)
		{
			able[to->sampleAlphaToCoverage](GL_SAMPLE_ALPHA_TO_COVERAGE_ARB);
			from->sampleAlphaToCoverage = to->sampleAlphaToCoverage;
		}
		if (from->sampleAlphaToOne != to->sampleAlphaToOne)
		{
			able[to->sampleAlphaToOne](GL_SAMPLE_ALPHA_TO_ONE_ARB);
			from->sampleAlphaToOne = to->sampleAlphaToOne;
		}
		if (from->sampleCoverage != to->sampleCoverage)
		{
			able[to->sampleCoverage](GL_SAMPLE_COVERAGE_ARB);
			from->sampleCoverage = to->sampleCoverage;
		}
		CLEARDIRTY(b->enable, nbitID);
	}
	if (to->enabled)
	{
		if (CHECKDIRTY(b->sampleCoverageValue, bitID))
		{
			if (from->sampleCoverageValue != to->sampleCoverageValue ||
			    from->sampleCoverageInvert != to->sampleCoverageInvert)
			{
				diff_api.SampleCoverageARB(to->sampleCoverageValue,
				    to->sampleCoverageInvert);
				from->sampleCoverageValue = to->sampleCoverageValue;
				from->sampleCoverageInvert = to->sampleCoverageInvert;
			}
			CLEARDIRTY(b->sampleCoverageValue, nbitID);
		}
	} /*enabled*/
	CLEARDIRTY(b->dirty, nbitID);
}

void crStateMultisampleSwitch(CRMultisampleBits *b, CRbitvalue *bitID,
		CRContext *fromCtx, CRContext *toCtx)
{
	CRMultisampleState *from = &(fromCtx->multisample);
	CRMultisampleState *to = &(toCtx->multisample);
	unsigned int j, i;
	CRbitvalue nbitID[CR_MAX_BITARRAY];
	for (j = 0; j<CR_MAX_BITARRAY; j++)
		nbitID[j] = ~bitID[j];
	i = 0; /* silence compiler */
	if (CHECKDIRTY(b->enable, bitID))
	{
		glAble able[2];
		able[0] = diff_api.Disable;
		able[1] = diff_api.Enable;
		if (from->enabled != to->enabled)
		{
			able[to->enabled](GL_MULTISAMPLE_ARB);
			FILLDIRTY(b->enable);
			FILLDIRTY(b->dirty);
		}
		if (from->sampleAlphaToCoverage != to->sampleAlphaToCoverage)
		{
			able[to->sampleAlphaToCoverage](GL_SAMPLE_ALPHA_TO_COVERAGE_ARB);
			FILLDIRTY(b->enable);
			FILLDIRTY(b->dirty);
		}
		if (from->sampleAlphaToOne != to->sampleAlphaToOne)
		{
			able[to->sampleAlphaToOne](GL_SAMPLE_ALPHA_TO_ONE_ARB);
			FILLDIRTY(b->enable);
			FILLDIRTY(b->dirty);
		}
		if (from->sampleCoverage != to->sampleCoverage)
		{
			able[to->sampleCoverage](GL_SAMPLE_COVERAGE_ARB);
			FILLDIRTY(b->enable);
			FILLDIRTY(b->dirty);
		}
		CLEARDIRTY(b->enable, nbitID);
	}
	if (CHECKDIRTY(b->sampleCoverageValue, bitID))
	{
		if (from->sampleCoverageValue != to->sampleCoverageValue ||
		    from->sampleCoverageInvert != to->sampleCoverageInvert)
		{
			diff_api.SampleCoverageARB(to->sampleCoverageValue,
			    to->sampleCoverageInvert);
			FILLDIRTY(b->sampleCoverageValue);
			FILLDIRTY(b->dirty);
		}
		CLEARDIRTY(b->sampleCoverageValue, nbitID);
	}
	CLEARDIRTY(b->dirty, nbitID);
}

